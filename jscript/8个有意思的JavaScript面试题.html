<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修8个有意思的JavaScript面试题' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>8个有意思的JavaScript面试题</center></div><div class='banquan'>原文出处:本文由博客园博主Fundebug提供。<br/>
原文连接:https://www.cnblogs.com/fundebug/p/8-javascript-interview-questions.html</div><br>
    <p><strong>摘要：</strong> 神奇的JS系列。</p>
<ul>
<li>作者：前端小智</li>
<li>原文：<a href="https://segmentfault.com/a/1190000019754823">8个问题看你是否真的懂 JS</a></li>
</ul>
<p><strong><a href="https://www.fundebug.com/">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>
<p>JavaScript 是一种有趣的语言，我们都喜欢它，因为它的性质。浏览器是JavaScript的主要运行的地方，两者在我们的服务中协同工作。JS有一些概念，人们往往会对它掉以轻心，有时可能会忽略不计。原型、闭包和事件循环等概念仍然是大多数JS开发人员绕道而行的晦涩领域之一。正如我们所知，无知是一件危险的事情，它可能会导致错误。</p>
<p>接下来，来看看几个问题，你也可以试试想想，然后作答。</p>
<h3 id="问题1浏览器控制台上会打印什么">问题1：浏览器控制台上会打印什么？</h3>
<pre><code><code>var a = 10;
function foo() {
    console.log(a); // ??
    var a = 20;
}
foo();</code></pre>
<h3 id="问题2如果我们使用-let-或-const-代替-var输出是否相同">问题2：如果我们使用 let 或 const 代替 var，输出是否相同？</h3>
<pre><code><code>var a = 10;
function foo() {
    console.log(a); // ??
    let a = 20;
}
foo();     </code></pre>
<h3 id="问题3newarray中有哪些元素">问题3：“newArray”中有哪些元素？</h3>
<pre><code><code>var array = [];
for (var i = 0; i &lt; 3; i++) {
    array.push(() =&gt; i);
}
var newArray = array.map(el =&gt; el());
console.log(newArray); // ??  </code></pre>
<h3 id="问题4如果我们在浏览器控制台中运行foo函数是否会导致堆栈溢出错误">问题4：如果我们在浏览器控制台中运行'foo'函数，是否会导致堆栈溢出错误？</h3>
<pre><code><code>function foo() {
    setTimeout(foo, 0); // 是否存在堆栈溢出错误?
}</code></pre>
<h3 id="问题5-如果在控制台中运行以下函数页面选项卡的-ui-是否仍然响应">问题5: 如果在控制台中运行以下函数，页面(选项卡)的 UI 是否仍然响应</h3>
<pre><code><code>function foo() {
    return Promise.resolve().then(foo);
}   </code></pre>
<h3 id="问题6-我们能否以某种方式为下面的语句使用展开运算而不导致类型错误">问题6: 我们能否以某种方式为下面的语句使用展开运算而不导致类型错误</h3>
<pre><code><code>var obj = { x: 1, y: 2, z: 3 };
[...obj]; // TypeError</code></pre>
<h3 id="问题7运行以下代码片段时控制台上会打印什么">问题7：运行以下代码片段时，控制台上会打印什么？</h3>
<pre><code><code>var obj = { a: 1, b: 2 };
Object.setPrototypeOf(obj, { c: 3 });
Object.defineProperty(obj, &quot;d&quot;, { value: 4, enumerable: false });

// what properties will be printed when we run the for-in loop?
for (let prop in obj) {
    console.log(prop);
}</code></pre>
<h3 id="问题8xgetter-会打印什么值">问题8：xGetter() 会打印什么值？</h3>
<pre><code><code>var x = 10;
var foo = {
    x: 90,
    getX: function() {
        return this.x;
    }
};
foo.getX(); // prints 90
var xGetter = foo.getX;
xGetter(); // prints ??</code></pre>
<hr />
<h3 id="答案">答案</h3>
<p>现在，让我们从头到尾回答每个问题。我将给您一个简短的解释，同时试图揭开这些行为的神秘面纱，并提供一些参考资料。</p>
<h3 id="问题1-undefined">问题1： <code>undefined</code></h3>
<p>使用<code>var</code>关键字声明的变量在JavaScript中会被提升，并在内存中分配值<code>undefined</code>。 但初始化恰发生在你给变量赋值的地方。 另外，<code>var</code>声明的变量是<a href="https://2ality.com/2011/02/javascript-variable-scoping-and-its.html">函数作用域的</a>，而<code>let</code>和<code>const</code>是块作用域的。 所以，这就是这个过程的样子：</p>
<pre><code><code>var a = 10; // 全局使用域
function foo() {
    // var a 的声明将被提升到到函数的顶部。
    // 比如:var a

    console.log(a); // 打印 undefined

    // 实际初始化值20只发生在这里
    var a = 20; // local scope
}</code></pre>
<h3 id="问题-2referenceerrora-undefined">问题 2：<code>ReferenceError：a undefined</code></h3>
<p><code>let</code>和<code>const</code>声明可以让变量在其作用域上受限于它所使用的块、语句或表达式。与<code>var</code>不同的是，这些变量没有被提升，并且有一个所谓的<strong>暂时死区(TDZ)</strong>。试图访问<strong>TDZ</strong>中的这些变量将引发<code>ReferenceError</code>，因为只有在执行到达声明时才能访问它们。</p>
<pre><code><code>var a = 10; // 全局使用域
function foo() {
    // TDZ 开始

    // 创建了未初始化的&#39;a&#39;
    console.log(a); // ReferenceError

    // TDZ结束，&#39;a&#39;仅在此处初始化，值为20
    let a = 20;
}</code></pre>
<p>下表概述了与JavaScript中使用的不同关键字声明的变量对应的提升行为和使用域：</p>
<p><img src="./images/8个有意思的JavaScript面试题0.png" /></p>
<h3 id="问题-3-3-3-3">问题 3: <code>[3, 3, 3]</code></h3>
<p>在<code>for</code>循环的头部声明带有<code>var</code>关键字的变量会为该变量创建单个绑定（存储空间）。 阅读更多关于<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/">闭包</a>的信息。 让我们再看一次for循环。</p>
<pre><code><code>// 误解作用域:认为存在块级作用域
var array = [];
for (var i = 0; i &lt; 3; i++) {
    // 三个箭头函数体中的每个`&#39;i&#39;`都指向相同的绑定，
    // 这就是为什么它们在循环结束时返回相同的值&#39;3&#39;。
    array.push(() =&gt; i);
}
var newArray = array.map(el =&gt; el());
console.log(newArray); // [3, 3, 3]</code></pre>
<p>如果使用 <code>let</code> 声明一个具有块级作用域的变量，则为每个循环迭代创建一个新的绑定。</p>
<pre><code><code>// 使用ES6块级作用域
var array = [];
for (let i = 0; i &lt; 3; i++) {
    // 这一次，每个&#39;i&#39;指的是一个新的的绑定，并保留当前的值。
    // 因此，每个箭头函数返回一个不同的值。
    array.push(() =&gt; i);
}
var newArray = array.map(el =&gt; el());
console.log(newArray); // [0, 1, 2]</code></pre>
<p>解决这个问题的另一种方法是使用<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/">闭包</a>。</p>
<pre><code><code>let array = [];
for (var i = 0; i &lt; 3; i++) {
    array[i] = (function(x) {
        return function() {
            return x;
        };
    })(i);
}
const newArray = array.map(el =&gt; el());
console.log(newArray); // [0, 1, 2]  </code></pre>
<h3 id="问题4-不会溢出">问题4 : 不会溢出</h3>
<p>JavaScript并发模型基于“事件循环”。 当我们说“浏览器是 JS 的家”时我真正的意思是浏览器提供运行时环境来执行我们的JS代码。</p>
<p>浏览器的主要组件包括<strong>调用堆栈</strong>，<strong>事件循环，任务队列</strong>和<strong>Web API</strong>。 像<code>setTimeout</code>，<code>setInterval</code>和<code>Promise</code>这样的全局函数不是JavaScript的一部分，而是 Web API 的一部分。 JavaScript 环境的可视化形式如下所示：</p>
<p><img src="./images/8个有意思的JavaScript面试题1.png" /></p>
<p>JS调用栈是后进先出(LIFO)的。引擎每次从堆栈中取出一个函数，然后从上到下依次运行代码。每当它遇到一些异步代码，如<code>setTimeout</code>，它就把它交给<code>Web API</code>(箭头1)。因此，每当事件被触发时，<code>callback</code> 都会被发送到任务队列（箭头2）。</p>
<p><strong>事件循环(Event loop)</strong>不断地监视任务队列(Task Queue)，并按它们排队的顺序一次处理一个回调。每当<strong>调用堆栈(call stack)</strong>为空时，<strong>Event loop</strong>获取回调并将其放入<strong>堆栈(stack )</strong>(箭头3)中进行处理。请记住，如果调用堆栈不是空的，<strong>则事件循环不会将任何回调推入堆栈</strong>。</p>
<p>现在，有了这些知识，让我们来回答前面提到的问题：</p>
<h4 id="步骤">步骤</h4>
<ol>
<li>调用 <code>foo()</code>会将<code>foo</code>函数放入<strong>调用堆栈(call stack)</strong>。</li>
<li>在处理内部代码时，JS引擎遇到<code>setTimeout</code>。</li>
<li>然后将<code>foo</code>回调函数传递给<strong>WebAPIs</strong>(箭头1)并从函数返回，调用堆栈再次为空</li>
<li>计时器被设置为0，因此<code>foo</code>将被发送到<strong>任务队列<Task Queue></strong>(箭头2)。</li>
<li>由于调用堆栈是空的，事件循环将选择<code>foo</code>回调并将其推入调用堆栈进行处理。</li>
<li>进程再次重复，堆栈不会溢出。</li>
</ol>
<p>运行示意图如下所示：</p>
<p><img src="./images/8个有意思的JavaScript面试题2.png" /></p>
<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href="https://www.fundebug.com/?utm_source=xiaozhi">Fundebug</a>。</strong></p>
<h3 id="问题5-不会响应">问题5 : 不会响应</h3>
<p>大多数时候，开发人员假设在<strong>事件循环<event loop></strong>图中只有一个任务队列。但事实并非如此，我们可以有多个任务队列。由浏览器选择其中的一个队列并在该队列中<strong>处理回调<callbacks></strong>。</p>
<p>在底层来看，JavaScript中有宏任务和微任务。<code>setTimeout</code>回调是<strong>宏任务</strong>，而<code>Promise</code>回调是<strong>微任务</strong>。</p>
<p>主要的区别在于他们的执行方式。宏任务在单个循环周期中一次一个地推入堆栈，但是微任务队列总是在执行后返回到事件循环之前清空。因此，如果你以处理条目的速度向这个队列添加条目，那么你就永远在处理微任务。只有当微任务队列为空时，事件循环才会重新渲染页面、</p>
<p>现在，当你在控制台中运行以下代码段</p>
<pre><code><code>function foo() {
    return Promise.resolve().then(foo);
}</code></pre>
<p>每次调用'<code>foo</code>'都会继续在微任务队列上添加另一个'<code>foo</code>'回调，因此事件循环无法继续处理其他事件（滚动，单击等），直到该队列完全清空为止。 因此，它会阻止渲染。</p>
<h4 id="问题6-会导致typeerror错误">问题6 : 会导致TypeError错误</h4>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">for-of</a> 语句遍历<code>iterable</code>对象定义要遍历的数据。<code>Array</code> 或<code>Map</code> 是具有默认迭代行为的内置迭代器。对象不是可迭代的，但是可以通过使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol">iterable</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol">iterator</a>协议使它们可迭代。</p>
<p>在<strong>Mozilla</strong>文档中，如果一个对象实现了<code>@@iterator</code>方法，那么它就是可迭代的，这意味着这个对象(或者它原型链上的一个对象)必须有一个带有<code>@@iterator</code>键的属性，这个键可以通过常量<code>Symbol.iterator</code>获得。</p>
<p>上述语句可能看起来有点冗长，但是下面的示例将更有意义：</p>
<pre><code><code>var obj = { x: 1, y: 2, z: 3 };
obj[Symbol.iterator] = function() {
    // iterator 是一个具有 next 方法的对象，
    // 它的返回至少有一个对象
    // 两个属性：value＆done。

    // 返回一个 iterator 对象
    return {
        next: function() {
            if (this._countDown === 3) {
                const lastValue = this._countDown;
                return { value: this._countDown, done: true };
            }
            this._countDown = this._countDown + 1;
            return { value: this._countDown, done: false };
        },
        _countDown: 0
    };
};
[...obj]; // 打印 [1, 2, 3]</code></pre>
<p>还可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator</a> 函数来定制对象的迭代行为：</p>
<pre><code><code>var obj = { x: 1, y: 2, z: 3 };
obj[Symbol.iterator] = function*() {
    yield 1;
    yield 2;
    yield 3;
};
[...obj]; // 打印 [1, 2, 3]</code></pre>
<h3 id="问题7-a-b-c">问题7 : a, b, c</h3>
<p><code>for-in</code>循环遍历对象本身的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举属性</a>以及对象从其原型继承的属性。 可枚举属性是可以在<code>for-in</code>循环期间包含和访问的属性。</p>
<pre><code><code>var obj = { a: 1, b: 2 };
var descriptor = Object.getOwnPropertyDescriptor(obj, &quot;a&quot;);
console.log(descriptor.enumerable); // true
console.log(descriptor);
// { value: 1, writable: true, enumerable: true, configurable: true }</code></pre>
<p>现在你已经掌握了这些知识，应该很容易理解为什么我们的代码要打印这些特定的属性</p>
<pre><code><code>var obj = { a: 1, b: 2 }; //a，b 都是 enumerables 属性

// 将{c：3}设置为&#39;obj&#39;的原型，并且我们知道
// for-in 循环也迭代 obj 继承的属性
// 从它的原型，&#39;c&#39;也可以被访问。
Object.setPrototypeOf(obj, { c: 3 });

// 我们在&#39;obj&#39;中定义了另外一个属性&#39;d&#39;，但是
// 将&#39;enumerable&#39;设置为false。 这意味着&#39;d&#39;将被忽略。
Object.defineProperty(obj, &quot;d&quot;, { value: 4, enumerable: false });

for (let prop in obj) {
    console.log(prop);
}
// 打印
// a
// b</code></pre>
<h3 id="问题8-10">问题8 : 10</h3>
<p>在全局范围内初始化<code>x</code>时，它成为window对象的属性(不是严格的模式)。看看下面的代码:</p>
<pre><code><code>var x = 10; // global scope
var foo = {
    x: 90,
    getX: function() {
        return this.x;
    }
};
foo.getX(); // prints 90
let xGetter = foo.getX;
xGetter(); // prints 10</code></pre>
<p>咱们可以断言：</p>
<pre><code><code>window.x === 10; // true</code></pre>
<p><code>this</code> 始终指向调用方法的对象。因此，在<code>foo.getx()</code>的例子中，它指向<code>foo</code>对象，返回<code>90</code>的值。而在<code>xGetter()</code>的情况下，<code>this</code>指向 window对象, 返回 <strong>window</strong> 中的<code>x</code>的值，即<code>10</code>。</p>
<p>要获取 <code>foo.x</code>的值，可以通过使用<code>Function.prototype.bind</code>将<code>this</code>的值绑定到<code>foo</code>对象来创建新函数。</p>
<pre><code><code>let getFooX = foo.getX.bind(foo);
getFooX(); // 90</code></pre>
<p>就这样！ 如果你的所有答案都正确，那么干漂亮。 咱们都是通过犯错来学习的。 这一切都是为了了解背后的“原因”。</p>
<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href="https://www.fundebug.com/?utm_source=xiaozhi">Fundebug</a>。</strong></p>
<h3 id="关于fundebug">关于Fundebug</h3>
<p><a href="https://www.fundebug.com/">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有阳光保险、核桃编程、荔枝FM、掌门1对1、微脉、青团社等众多品牌企业。欢迎大家免费试用！</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>