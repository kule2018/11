<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ECMA6新增语法（待续...）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ECMA6新增语法（待续...）</center></div><div class='banquan'>原文出处:本文由博客园博主等到晴天提供。<br/>
原文连接:https://www.cnblogs.com/qingtianya/p/11819368.html</div><br>
    <p><strong>块级作用域:&nbsp;<span style="color: #ff0000;"> ES6允许你使用块级作用域,不过目前大多数的ES6语法只允许在严格模式下使用("use strict&rdquo; )。</span></strong></p>
<p><strong>1 let关键字</strong></p>
<p>&nbsp;&nbsp; &nbsp;作用:声明变量,一个花括号就是一个作用域(每个花括号内就是全新变量).</p>
<p>&nbsp; &nbsp;&nbsp;特点:不在进行声明提升,在块作用域外无法访问变量,和const一样只能声明一次.</p>
<p>&nbsp; &nbsp; 关键字:let , const，function，class ES6下都可以以块为作用域 借鉴:<a href="https://blog.csdn.net/kittyjie/article/details/50337031" target="_blank">https://blog.csdn.net/kittyjie/article/details/50337031</a></p>
<p>　</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">var 声明的变量作用在定时器外的函数里的 </span>
<span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i=<span style="color: #800080;">0</span>; i&lt;<span style="color: #800080;">5</span>; i++<span style="color: #000000;">){ 
   setTimeout(function(){ 
       alert(i); 
   },</span><span style="color: #800080;">1000</span><span style="color: #000000;">);
} </span><span style="color: #008000;">//</span><span style="color: #008000;">结果为:5 5 5 5 5

</span><span style="color: #008000;">//</span><span style="color: #008000;">因为let以花括号作为作用域,for每次循环的时候都会重新let一个变量 理解let在for循环中:</span><span style="color: #008000; text-decoration: underline;">https://zhuanlan.zhihu.com/p/51966830</span>
<span style="color: #008000;">//</span><span style="color: #008000;">let变量作用在括号,且外部无法访问 </span>
<span style="color: #0000ff;">for</span>(let i=<span style="color: #800080;">0</span>; i&lt;<span style="color: #800080;">5</span>; i++<span style="color: #000000;">){ 
   setTimeout(function(){ 
       alert(i); 
   },</span><span style="color: #800080;">1000</span><span style="color: #000000;">);
}</span><span style="color: #008000;">//</span><span style="color: #008000;">结果为:1 2 3 4 5</span><em id="__mceDel" style="background-color: #ffffff; font-family: 'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px;">&nbsp;</em></pre>
</div>
<p><strong>2 const声明常量</strong></p>
<p>&nbsp; &nbsp; &nbsp; 作用:定义一个常量</p>
<p>&nbsp; &nbsp; &nbsp; 特点:不会声明提升,以块为作用域,值无法更改,只能声明一次.</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">将对象设置为常量,它的值是可以修改的</span><span style="color: #008000;">
//</span><span style="color: #008000;">因为我们常量的值,只是在栈内存中保存的指向对象的指针 数据类型的栈和堆内存:<a href="https://www.cnblogs.com/liveoutfun/p/8962019.html" target="_blank">https://www.cnblogs.com/liveoutfun/p/8962019.html</a></span>
const obj = {a:1,b:2,c:3<span style="color: #000000;">}
obj.a </span>= 100<span style="color: #000000;">;
console.log(obj.a); </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>3 箭头函数</strong></p>
<p>&nbsp; &nbsp; &nbsp;作用:通过简洁的格式声明一个函数</p>
<p>　 特点:比传统函数格式简洁(省略了function,return,单个形参时括号)，且this指向是上级函数的指向</p>
<p>　&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">普通函数声明格式</span>
<span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
   </span><span style="color: #0000ff;">return</span> 1+1<span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">箭头函数声明格式</span>
<span style="color: #0000ff;">var</span> a = x =&gt;<span style="color: #000000;">{
　　</span>1 + 1<span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">多个参数</span>
<span style="color: #0000ff;">var</span> a = (x,y,z) =&gt;<span style="color: #000000;">{
　　</span>1 + 1<span style="color: #000000;">;
}</span></pre>
</div>
<p><strong>4 Destructuring解构</strong></p>
<p>&nbsp; &nbsp; &nbsp; 作用:可以通过解构方式来取值</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">一般定义变量写法</span>
<span style="color: #0000ff;">var</span> x=10,y=20,z=30<span style="color: #000000;">;

</span><span style="color: #008000;">//</span><span style="color: #008000;">解构赋值允许你给多个变量赋值</span>
let [x,y,z] = [10,20,30<span style="color: #000000;">]; 
let [x,[a,b],y] </span>= [10,[15,18],20<span style="color: #000000;">];
这并不是在定义数组，而是通过等号两边的结构匹配，进行赋值。

</span><span style="color: #008000;">//</span><span style="color: #008000;">解构赋值允许你少取一个值：</span>
let [x,y] = [10,20,30]; <span style="color: #008000;">//</span><span style="color: #008000;">结果x=10,y=20 </span>
let [x,[a,b],y] = [10,[5],20]; <span style="color: #008000;">//</span><span style="color: #008000;">结果x=10,a=5,y=20,b=undefined</span>
<span style="color: #000000;">浏览器并不会报错，依然赋值成功。

</span><span style="color: #008000;">//</span><span style="color: #008000;">可以使用对象不按照顺序取值<br /></span><span style="color: #0000ff;">var</span> {id,name,age} = {name:'yt',age:30,id=30}</pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">用途</span><span style="color: #008000;">
//</span><span style="color: #008000;">可以方便的交换两个变量的值</span>
[a,b] =<span style="color: #000000;"> [b,a];<br />
</span><span style="color: #008000;">//</span><span style="color: #008000;">可以一次为多个变量取值</span>
[a,b] = () =&gt;{ <span style="color: #0000ff;">return</span> [1,2<span style="color: #000000;">] }<br />
</span><span style="color: #008000;">//</span><span style="color: #008000;">对象格式可以不考虑取值顺序</span>
{a,b,c} = {b:1,a:2,c:3<span style="color: #000000;">}<br />
</span><span style="color: #008000;">//从数组或对象的某一项</span>
var {a:NewName} = obj; <span style="color: #008000;">//</span><span style="color: #008000;">对象</span>
var [0:NewName] = arr; <span style="color: #008000;">//</span><span style="color: #008000;">数组</span></pre>
</div>
<p>总结:数组格式的可以批量取值,对象格式的可以打乱顺序取值</p>
<p><strong>5 字符串的一些方法</strong></p>
<p>&nbsp; &nbsp; &nbsp; 作用:ECMA6字符串可以更快捷的拼接字符串</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">快捷的字符串拼接</span>
<span style="color: #0000ff;">var</span> str =<span style="color: #000000;"> `我是ECMA${变量、表达式}字符串`

</span><span style="color: #008000;">//</span><span style="color: #008000;">字符串中的换行不会报错</span>
<span style="color: #0000ff;">var</span> str =<span style="color: #000000;"> `
不会报错</span>!!<span style="color: #000000;">
`</span></pre>
</div>
<p>6 数组的一些方法</p>
<p>&nbsp; &nbsp; Array.from(伪数组) &nbsp;//可以将伪数组转换为数组</p>
<p>　Array.copyWithin(被替换元素下标,截取开始下标,截取结束下标); //复制元素替换元素(一条龙服务)</p>
<p>　Array.find(function(value,index,arr){ return value &gt; 10 }) &nbsp;//和过滤类似,只找一次符合条件的元素.　</p>
<p>&nbsp; &nbsp;&nbsp;findIndex(function(value, index, arr){}) //和find类似,不过返回的是符合一次要求的元素的下标</p>
<p>7 Object.assign</p>
<div>&nbsp; &nbsp;&nbsp;Object.assign({a:1},{b:2},{b:4,c:3}); //将相同的属性合并,返回一个独立属性对象</div>
<p>8 第七种数据类型Symbol</p>
<p>9 Set和Map集合</p>
<p>10 Map集合，即映射</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>