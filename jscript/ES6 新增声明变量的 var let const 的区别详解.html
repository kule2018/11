<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ES6 新增声明变量的 var let const 的区别详解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ES6 新增声明变量的 var let const 的区别详解</center></div><div class='banquan'>原文出处:本文由博客园博主张小中提供。<br/>
原文连接:https://www.cnblogs.com/zjz666/p/11088347.html</div><br>
    <p><span style="font-size: 18pt;"><strong>var</strong></span></p>
<p>如果使用关键字 var 声明一个变量，那么这个变量就属于当前的函数作用域，如果声明是发生在任何函数外的顶层声明，那么这个变量就属于全局作用域。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;"> let</span></strong><br />        <strong>1、</strong>let 声明的变量具有块作用域的特征。<br />        <strong>2、</strong>在同一个块级作用域，不能重复声明变量。<br />            　　function foo(){<br />                　　　　let a = 1;<br />                　　　　let a = 2;//Uncaught SyntaxError: Identifier 'a' has already been declared<br />            　　}</p>
<p><strong>        3、</strong>let 声明的变量不存在变量提升，换一种说法，就是 let 声明存在暂时性死区（TDZ）。</p>
<p>            　　<strong><span style="color: #000000;">for (var i = 0; i &lt; 5; i++) {</span></strong><br /><strong><span style="color: #000000;">                　　　　setTimeout(function(){</span></strong><br /><strong><span style="color: #000000;">                    　　　　　　console.log(i);</span></strong><br /><strong><span style="color: #000000;">                　　　　},100)</span></strong><br /><strong><span style="color: #000000;">            　　};</span></strong><br />            <strong>会打印4个4   ：</strong>setTimeout是异步执行的，100毫秒后向任务队列里添加一个任务，只有主线上的全部执行完才会执行任务队列里的任务，所以当主线程for循环执行完之后 i 的值为5，这个时候再去任务队列中执行任务，i全部为5；每次for循环的时候setTimeout都会执行，但是里面的function则不会执行被放入任务队列，因此放了5次；for循环的5次执行完之后不到1000毫秒；1000毫秒后全部执行任务队列中的函数，所以就是输出五个5啦</p>
<p>            　　<strong>for (let i = 0; i &lt; 5; i++) {</strong><br /><strong>                　　　　setTimeout(function(){</strong><br /><strong>                    　　　　　　console.log(i);</strong><br /><strong>                　　　　},100)</strong><br /><strong>            　　};</strong><br />            会打印0,1,2,3,4：假如把var换成let，那么输出结果为0,1,2,3,4；因为let  i  的是区块变量，每个i只能存活到大括号结束，并不会把后面的for循环的  i  值赋给前面的setTimeout中的i；而var i  则是局部变量，这个 i 的生命周期不受for循环的大括号限制；</p>
<p><br />    <span style="font-size: 18pt;"><strong>const</strong></span></p>
<p> 声明方式，除了具有 let 的上述特点外，其还具备一个特点，即 const 定义的变量，一旦定义后，就不能修改，即 const 声明的为常量。</p>
<p>            const obj = {a:1,b:2};<br />            console.log(obj.a);//1<br />            obj.a = 3;<br />            console.log(obj.a);//3</p>
<p>            所以准确的说，是 const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，<strong>只是变量标识符不能重新分配。</strong></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>