<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ES6新特性' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ES6新特性</center></div><div class='banquan'>原文出处:本文由博客园博主任风来去匆匆提供。<br/>
原文连接:https://www.cnblogs.com/ruhaoren/p/11575179.html</div><br>
    <p><span style="font-size: 14px;">ECMAScript 6 是ECMA于2015.06发布的版本，作为一个分界点，现在我们通常把这之后的版本统称为ES6。ES6带来了许多全新的语法，同时添加了类的概念，可以预见的是，JavaScript正朝着工程化语言迈进，我们并不知道这对于年轻的JavaScript来说是好还是坏，因为它最开始是做为一款轻量级的脚本语言而风靡全球的。</span></p>
<p><span style="font-size: 14px;">&nbsp;</span></p>
<p><span style="font-size: 16px;"><strong>一　　新的原始类型和变量申明</strong></span></p>
<p><span style="font-size: 14px;"><strong>　　1，symbol</strong></span></p>
<p><span style="font-size: 14px;"><strong>　　</strong>在ES6之前，我们知道JavaScript支持6种数据类型：object，string，boolean，number，null，undefined。现在，ES6新增了一种原始数据类型：symbol，表示独一无二的值，即每个symbol类型的值都不相同。这让我想起了另一个特殊的值：NaN，想一想，他们是不是有一点类似呢！</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">var</span> sy = Symbol('test'<span style="color: #000000;">);
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">var</span> sy1 = Symbol('test'<span style="color: #000000;">);
</span><span style="color: #008080;">3</span> console.log(tepeof sy);<span style="color: #008000;">//</span><span style="color: #008000;">'symbol'</span>
<span style="color: #008080;">4</span> sy == sy1;<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #008080;">5</span> <span style="color: #0000ff;">var</span> sy2 = <span style="color: #0000ff;">new</span> Symbol('test');<span style="color: #008000;">//</span><span style="color: #008000;">error : Symbol is not a constructor</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　创建symbol数据类型的值时，需要给Symbol函数传递一个字符串，并且有一点特殊的是：不能使用new关键字调用它。另外，每个symbol类型值都是独一无二的，即使传递的是相同的字符串。</span></p>
<p><span style="font-size: 14px;">　　<strong>2，let和const</strong></span></p>
<p><span style="font-size: 14px;">　　ES6新增了两个申明变量的关键字：let和const。他们申明的变量仅在let和const关键字所在的代码块内起作用，即在使用let和const的那一对大括号{}内起作用，也称块级作用域（ES6之前只有函数作用域和全局作用域）。let和const申明变量不会在预编译过程中有提升行为(在全局申明也不会变成window的属性)，且不能重复申明。所以要使用这类变量，只能在let和const关键字之后使用它们。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> <span style="color: #000000;">{
</span><span style="color: #008080;">2</span>     let a = 0<span style="color: #000000;">;
</span><span style="color: #008080;">3</span>     console.log(a);<span style="color: #008000;">//</span><span style="color: #008000;">0</span>
<span style="color: #008080;">4</span> <span style="color: #000000;">}
</span><span style="color: #008080;">5</span> console.log(a);<span style="color: #008000;">//</span><span style="color: #008000;">error a is not defined</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　const用来申明一个常量，申明时必须赋值，且一旦申明就不能改变。</span></p>
<p><span style="font-size: 14px;">　　其实说const变量不能更改是不准确的，请看下面的例子：</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> const obj =<span style="color: #000000;"> {
</span><span style="color: #008080;">2</span>     name:'ren'<span style="color: #000000;">,
</span><span style="color: #008080;">3</span>     age:12
<span style="color: #008080;">4</span> <span style="color: #000000;">};
</span><span style="color: #008080;">5</span> obj = {};<span style="color: #008000;">//</span><span style="color: #008000;">error</span>
<span style="color: #008080;">6</span> obj.sex =<span style="color: #000000;"> male;
</span><span style="color: #008080;">7</span> consol.log(obj);<span style="color: #008000;">//</span><span style="color: #008000;">{name:'ren',age:12;sex:'male'}</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　const申明的如果是一个原始值，那么上面的说法是准确的，如果const申明的是一个引用值，那么更准确的说法应该是一个不能被重新赋值的变量。</span></p>
<p><span style="font-size: 14px;">　　<strong>3，解构赋值</strong>　</span></p>
<p><span style="font-size: 14px;">　　解构赋值是对赋值运算符的扩展。它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;">let [a,b,c] = [1,2,3<span style="color: #000000;">];
console.log(a,b,c);</span><span style="color: #008000;">//</span><span style="color: #008000;">1,2,3</span>
**************************<span style="color: #000000;">
let [a,b,c] </span>= [1,,3<span style="color: #000000;">];
console.log(a,b,c);</span><span style="color: #008000;">//</span><span style="color: #008000;">1,undefined,3</span>
**************************<span style="color: #000000;">
let [a,,b] </span>= [1,2,3<span style="color: #000000;">];
console.log(a,b);</span><span style="color: #008000;">//</span><span style="color: #008000;">1,3</span>
**************************<span style="color: #000000;">
let [a,..b] </span>= [1,2,3];<span style="color: #008000;">//</span><span style="color: #008000;">...是剩余运算符，表示赋值运算符右边除第一个值外剩余的都赋值给b</span>
console.log(a,b);<span style="color: #008000;">//</span><span style="color: #008000;">1,[2,3]</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　事实上所有可枚举（iterable）的对象都可以使用结构赋值，例如数组，字符串对象，以及ES6新增的Map和Set类型。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let arr = 'hello'<span style="color: #000000;">;
</span><span style="color: #008080;">2</span> let [a,b,c,d,e] =<span style="color: #000000;"> arr;
</span><span style="color: #008080;">3</span> console.log(a,b,c,d,e);<span style="color: #008000;">//</span><span style="color: #008000;">'h','e','l','l','o'</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　对象的解构赋值和数组类似，不过左边的变量名需要使用对象的属性名，并且用大括号{}而非中括号[]：</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let obj = {name:'ren',age:12,sex:'male'<span style="color: #000000;">};
</span><span style="color: #008080;">2</span> let {name,age,sex} =<span style="color: #000000;"> obj;
</span><span style="color: #008080;">3</span> console.log(name,age,sex);<span style="color: #008000;">//</span><span style="color: #008000;">'ren',12,'male';</span></span></pre>
</div>
<p><span style="font-size: 14px;">&nbsp;　　</span></p>
<p><span style="font-size: 16px;"><strong>二　　新的对象和方法</strong></span></p>
<p><span style="font-size: 14px;">　　<strong>1，Map和Set</strong></span></p>
<p><span style="font-size: 14px;">　　Map对象用于保存键值对，任何值JavaScript支持的值都可以作为一个键或者一个值。这听起来和对象差不多啊？其实它们还是有区别的：</span></p>
<p><span style="font-size: 14px;">　　　　a) object的键只能是字符串或ES6的symbol值，而Map可以是任何值。</span></p>
<p><span style="font-size: 14px;">　　　　b) Map对象有一个size属性，存储了键值对的个数，而object对象没有类似属性。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let myMap = <span style="color: #0000ff;">new</span> Map([['name','ren'],['age',12<span style="color: #000000;">]]);
</span><span style="color: #008080;">2</span> console.log(myMap);<span style="color: #008000;">//</span><span style="color: #008000;">{'name'=&gt;'ren','age'=&gt;12}</span>
<span style="color: #008080;">3</span> myMap.set('sex','male'<span style="color: #000000;">);
</span><span style="color: #008080;">4</span> console.log(myMap);<span style="color: #008000;">//</span><span style="color: #008000;">{'name'=&gt;'ren','age'=&gt;12,'sex'=&gt;'male'}</span>
<span style="color: #008080;">5</span> myMap.get('name');<span style="color: #008000;">//</span><span style="color: #008000;">'ren'</span>
<span style="color: #008080;">6</span> myMap.has('age');<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">7</span> myMap.<span style="color: #0000ff;">delete</span>('age');<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">8</span> myMap.has('age');<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #008080;">9</span> myMap.get('age');<span style="color: #008000;">//</span><span style="color: #008000;">undefined</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　Map构造函数接收一个二维数组来创建一个Map对象。数组元素的第0位表示Map对象的key，第1位表示Map对象的value。</span></p>
<p><span style="font-size: 14px;">　　Map对象使用set方法来新增数据，set方法接收两个参数，第一个表示key，第二个表示value。使用get方法获取数据，参数是对象的key。</span></p>
<p><span style="font-size: 14px;">　　Map对象使用delete方法来删除数据，接收一个参数，表示需要被删除的key。</span></p>
<p><span style="font-size: 14px;">　　Map对象使用has方法检测是否已经具有某个属性，返回boolean值。</span></p>
<p><span style="font-size: 14px;">　　Set对象和Map对象类似，但它是用来存储一组唯一值的，而不是键值对。类似数组，但它的每个元素都是唯一的。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let mySet = <span style="color: #0000ff;">new</span> Set([1,2,3<span style="color: #000000;">]);
</span><span style="color: #008080;">2</span> console.log(mySet);<span style="color: #008000;">//</span><span style="color: #008000;">{1,2,3}</span>
<span style="color: #008080;">3</span> mySet.add(4<span style="color: #000000;">);
</span><span style="color: #008080;">4</span> console.log(mySet);<span style="color: #008000;">//</span><span style="color: #008000;">{1,2,3,4}</span>
<span style="color: #008080;">5</span> mySet.<span style="color: #0000ff;">delete</span>(1);<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">6</span> mySet.has(1);<span style="color: #008000;">//</span><span style="color: #008000;">false</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　利用Set对象唯一性的特点，可以轻松实现数组的去重：</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let arr = [1,1,2,3,4,4<span style="color: #000000;">];
</span><span style="color: #008080;">2</span> let mySet = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Set(arr);
</span><span style="color: #008080;">3</span> let newArr =<span style="color: #000000;"> Array.from(mySet);
</span><span style="color: #008080;">4</span> console.log(newArr);<span style="color: #008000;">//</span><span style="color: #008000;">[1,2,3,4]</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　<strong>2，对象新特性</strong></span></p>
<p><span style="font-size: 14px;">　　创建对象的字面量方式可以更加简洁。直接使用变量名作为属性，函数体作为方法，最终变量值变成属性值，函数名变成方法名。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;"> 1</span> let name = 'ren'<span style="color: #000000;">;
</span><span style="color: #008080;"> 2</span> let age = 12<span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span> let myself =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    name,
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">    age,
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">    say(){
</span><span style="color: #008080;"> 7</span>         console.log(<span style="color: #0000ff;">this</span><span style="color: #000000;">.name);
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">};
</span><span style="color: #008080;">10</span> console.log(myself);<span style="color: #008000;">//</span><span style="color: #008000;">{name:'ren',age:12,say:fn}</span>
<span style="color: #008080;">11</span> myself.say();<span style="color: #008000;">//</span><span style="color: #008000;">'ren'</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　对象的拓展运算符(...)三点。用于拷贝目标对象所有可遍历的属性到当前对象。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let obj = {name:'ren',age:12<span style="color: #000000;">};
</span><span style="color: #008080;">2</span> let person =<span style="color: #000000;"> {...obj};
</span><span style="color: #008080;">3</span> console.log(person);<span style="color: #008000;">//</span><span style="color: #008000;">{name:'ren',age:12}</span>
<span style="color: #008080;">4</span> obj == person;<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #008080;">5</span> let another = {sex:'male'<span style="color: #000000;">};
</span><span style="color: #008080;">6</span> let someone =<span style="color: #000000;"> {...person,...another};<span style="color: #339966;">//合并对象
</span></span><span style="color: #008080;">7</span> console.log(someone);<span style="color: #008000;">//</span><span style="color: #008000;">{name:'ren',age:12,sex:'male'}</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　ES6对象新增了两个方法，assign和is。</span></p>
<p><span style="font-size: 14px;">　　assign用于浅拷贝源对象可枚举属性到目标对象。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let source = {a:{ b: 1},b: 2<span style="color: #000000;">};
</span><span style="color: #008080;">2</span> let target = {c: 3<span style="color: #000000;">};
</span><span style="color: #008080;">3</span> <span style="color: #000000;">Object.assign(target, source);
</span><span style="color: #008080;">4</span> console.log(target);<span style="color: #008000;">//</span><span style="color: #008000;">{c: 3, a: {b:1}, b: 2}</span>
<span style="color: #008080;">5</span> source.a.b = 2<span style="color: #000000;">;
</span><span style="color: #008080;">6</span> console.log(target.a.b);<span style="color: #008000;">//</span><span style="color: #008000;">2</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　如果有同名属性，那么目标对象的属性值会被源对象的属性值覆盖。所以数组的表现就有一点特别了：</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> Object.assign([1,2,3],[11,22,33,44]);<span style="color: #008000;">//</span><span style="color: #008000;">[11,22,33,44]</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　数组的index就是属性名，当使用assign方法时，从第0位开始，目标数组的值便开始被源数组的值覆盖了。</span></p>
<p><span style="font-size: 14px;">　　is方法和（===）功能基本类似，用于判断两个值是否绝对相等。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> Object.is(1,1);<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">2</span> Object.is(1,<span style="color: #0000ff;">true</span>);<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #008080;">3</span> Object.is([],[]);<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #008080;">4</span> Object.is(+0,-0);<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #008080;">5</span> Object.is(NaN,NaN);<span style="color: #008000;">//</span><span style="color: #008000;">true</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　他们仅有的两点区别是，is方法可以区分+0还是-0，还有就是它认为NaN是相等的。</span></p>
<p><span style="font-size: 14px;">　　<strong>3，字符串新方法</strong></span></p>
<p><span style="font-size: 14px;">　　includes()判断字符串是否包含参数字符串，返回boolean值。如果想要知道参数字符串出现的位置，还是需要indexOf或lastIndexOf方法。</span></p>
<p><span style="font-size: 14px;">　　startsWith()/endsWith()，判断字符串是否以参数字符串开头或结尾。返回boolean值。这两个方法可以有第二个参数，一个数字，表示开始查找的位置。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let str = 'blue,red,orange,white'<span style="color: #000000;">;
</span><span style="color: #008080;">2</span> str.includes('blue');<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">3</span> str.startsWith('blue');<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">4</span> str.endsWith('blue');<span style="color: #008000;">//</span><span style="color: #008000;">false</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　repeat()方法按指定次数返回一个新的字符串。如果次数是大于0的小数则向下取整，0到-1之间的小数则向上取整，其他负数将抛出错误。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> console.log('hello'.repeat(2));<span style="color: #008000;">//</span><span style="color: #008000;">'hellohello'</span>
<span style="color: #008080;">2</span> console.log('hello'.repeat(1.9));<span style="color: #008000;">//</span><span style="color: #008000;">'hello'</span>
<span style="color: #008080;">3</span> console.log('hello'.repeat(-0.9));<span style="color: #008000;">//</span><span style="color: #008000;">''</span>
<span style="color: #008080;">4</span> console.log('hello'.repeat(-1.9));<span style="color: #008000;">//</span><span style="color: #008000;">error</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　padStart()/padEnd()，用参数字符串按给定长度从前面或后面补全字符串，返回新字符串。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let arr = 'hell'<span style="color: #000000;">;
</span><span style="color: #008080;">2</span> console.log(arr.padEnd(5,'o'));<span style="color: #008000;">//</span><span style="color: #008000;">'hello'</span>
<span style="color: #008080;">3</span> console.log(arr.padEnd(6,'o'));<span style="color: #008000;">//</span><span style="color: #008000;">'helloo'</span>
<span style="color: #008080;">4</span> console.log(arr.padEnd(6));<span style="color: #008000;">//</span><span style="color: #008000;">'hell  ',如果没有指定将用空格代替</span>
<span style="color: #008080;">5</span> console.log(arr.padStart(5,'o'));<span style="color: #008000;">//</span><span style="color: #008000;">'ohell'</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　另外，如果字符串加上补全的字符串超出了给定的长度，那么，超出的部分将被截去。</span></p>
<p><span style="font-size: 14px;">　　<strong>4，数组的新方法</strong></span></p>
<p><span style="font-size: 14px;">　　of()是ES6新增的用于创建数组的方法。of把传入的参数当做数组元素，形成新的数组。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let arr = Array.of(1,'2',[3<span style="color: #000000;">],{});
</span><span style="color: #008080;">2</span> console.log(arr);<span style="color: #008000;">//</span><span style="color: #008000;">[1,'2',[3],{}]</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　from()方法可以将可迭代对象转换为新的数组。函数可接受3个参数：第一个表示将被转换的可迭代对象，第二个是回调函数，将对每个数组元素应用该回调函数，然后返回新的值到新数组，第三个是回到函数内this的指向。后两个参数是可选的。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let obj =<span style="color: #000000;"> {
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">double</span><span style="color: #000000;">(n) {
</span><span style="color: #008080;">3</span>         <span style="color: #0000ff;">return</span> n * 2<span style="color: #000000;">;
</span><span style="color: #008080;">4</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">5</span> <span style="color: #000000;">}
</span><span style="color: #008080;">6</span> let arr = [1, 2, 3<span style="color: #000000;">];
</span><span style="color: #008080;">7</span> console.log(Array.from(arr, <span style="color: #0000ff;">function</span><span style="color: #000000;"> (n){
</span><span style="color: #008080;">8</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">double</span><span style="color: #000000;">(n);
</span><span style="color: #008080;">9</span> }, obj)); <span style="color: #008000;">//</span><span style="color: #008000;"> [2, 4, 6]</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　find()和findIndex()，查找数组中符合条件的元素值或索引，方法不会修改原数组。</span></p>
<p><span style="font-size: 14px;">　　接受一个回调函数作为参数，函数可以接受四个参数，分别是当前遍历到的元素，当前遍历到的索引，数组本身以及函数内this的指向。方法会把回调函数作用于每一个遍历到的元素，如果遍历到某一个元素可以使回调函数返回true，那么find方法会立即返回该元素，findIndex方法会返回该元素的索引。并终止继续遍历。</span></p>
<p><span style="font-size: 14px;">　　如果有多个符合条件的，也将只返回第一个。如果遍历完整个数组也无法是回调函数返回true，那么find方法将返回undefined，findIndex方法将返回-1。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> let arr = [1,2,3,4,5<span style="color: #000000;">];
</span><span style="color: #008080;">2</span> console.log(arr.find((ele) =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">return</span> ele === 1<span style="color: #000000;">;
</span><span style="color: #008080;">4</span> }));<span style="color: #008000;">//</span><span style="color: #008000;">1</span>
<span style="color: #008080;">5</span> console.log(arr.findIndex((ele) =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">6</span>     <span style="color: #0000ff;">return</span> ele &gt; 4<span style="color: #000000;">;
</span><span style="color: #008080;">7</span> }));<span style="color: #008000;">//</span><span style="color: #008000;">4</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 14px;">　　fill()/copyWithin()，替换数组中部分元素，会修改原数组。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let arr = [1,2,3,4,5<span style="color: #000000;">];
</span><span style="color: #008080;">2</span> console.log(arr.fill(0,0,3));<span style="color: #008000;">//</span><span style="color: #008000;">[0,0,0,4,5]</span>
<span style="color: #008080;">3</span> <span style="color: #008000;">//</span><span style="color: #008000;">参数1表示目标值，参数2，3表示替换的始末位置，左闭右开区间。</span>
<span style="color: #008080;">4</span> console.log(arr.copyWithin(0,2,4));<span style="color: #008000;">//</span><span style="color: #008000;">[0,4,0,4,5]</span>
<span style="color: #008080;">5</span> <span style="color: #008000;">//</span><span style="color: #008000;">参数1表示修改的起始位置，参数2，3表示用来替换的数据的始末位置，左闭右开区间。</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　fill()用指定的值替换，copyWithin()使用数组中原有的某一部分值替换。</span></p>
<p><span style="font-size: 14px;"><strong>　　</strong>includes()用于检测数组是否包含某个值，可以指定开始位置。<br /></span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let arr = [1,2,3,4,5<span style="color: #000000;">];
</span><span style="color: #008080;">2</span> console.log(arr.includes(2));<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">3</span> console.log(arr.includes(1,1));<span style="color: #008000;">//</span><span style="color: #008000;">false</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　</span></p>
<p><span style="font-size: 16px;"><strong>三　　函数</strong></span></p>
<p><span style="font-size: 14px;"><strong>　　1，参数默认值</strong></span></p>
<p><span style="font-size: 14px;">　　ES6首次添加了参数默认值。我们再也不用在函数内部编写容错代码了。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">function</span> add(a=1,b=2<span style="color: #000000;">){
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
</span><span style="color: #008080;">3</span> <span style="color: #000000;">}
</span><span style="color: #008080;">4</span> add();<span style="color: #008000;">//</span><span style="color: #008000;">3</span>
<span style="color: #008080;">5</span> add(2);<span style="color: #008000;">//</span><span style="color: #008000;">4</span>
<span style="color: #008080;">6</span> add(3,4);<span style="color: #008000;">//</span><span style="color: #008000;">7</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　和参数默认值一起，ES6还带来了不定参。它的功能和使用arguments差不多。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> add(...num){
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">return</span> num.reduce(<span style="color: #0000ff;">function</span><span style="color: #000000;">(result,value){
</span><span style="color: #008080;">3</span>         <span style="color: #0000ff;">return</span> result +<span style="color: #000000;"> value;
</span><span style="color: #008080;">4</span> <span style="color: #000000;">    });
</span><span style="color: #008080;">5</span> <span style="color: #000000;">}
</span><span style="color: #008080;">6</span> add(1,2,3,4);<span style="color: #008000;">//</span><span style="color: #008000;">10</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　下面介绍的箭头函数没有arguments属性，如果箭头函数内要实现不定参，上述方式就是一个不错的选择了。</span></p>
<p><span style="font-size: 14px;">　　<strong>2，箭头函数</strong></span></p>
<p><span style="font-size: 14px;">　　箭头函数实现了一种更加简洁的书写方式，并且也解决了关键字声明方式的一些麻烦事儿。箭头函数内部没有arguments，也没有prototype属性，所以不能用new关键字调用箭头函数。</span></p>
<p><span style="font-size: 14px;">　　箭头函数的书写方式：参数 =&gt; 函数体。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> let add = (a,b) =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">return</span> a+<span style="color: #000000;">b;
</span><span style="color: #008080;">3</span> <span style="color: #000000;">}
</span><span style="color: #008080;">4</span> let print = () =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">5</span>     console.log('hi'<span style="color: #000000;">);
</span><span style="color: #008080;">6</span> <span style="color: #000000;">}
</span><span style="color: #008080;">7</span> let fn = a =&gt; a *<span style="color: #000000;"> a;
</span><span style="color: #008080;">8</span> <span style="color: #008000;">//</span><span style="color: #008000;">当只有一个参数时，括号可以省略，函数体只有单行return语句时，大括号也可以省略，强烈建议不要省略它们，是真的难以阅读</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　当函数需要直接返回对象时，建议用变量保存，然后返回变量名，或用小括号把对象包裹起来。否则将抛出错误。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">var</span> returnObj = () =&gt;<span style="color: #000000;">{
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">var</span> obj = {name:'ren',age:12<span style="color: #000000;">};
</span><span style="color: #008080;">3</span> <span style="color: #000000;">    retufn obj;
</span><span style="color: #008080;">4</span> <span style="color: #000000;">};
</span><span style="color: #008080;">5</span> <span style="color: #008000;">//</span><span style="color: #008000;">var returnObj = () =&gt; ({name:'ren',age:12});</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　箭头函数和普通函数最大的区别在于其内部this永远指向其父级AO对象的this。</span></p>
<p><span style="font-size: 14px;">　　普通函数在预编译环节会在AO对象上添加this属性，保存一个对象（请参照<a href="https://www.cnblogs.com/ruhaoren/p/11534871.html" target="_blank">《JavaScript之深入对象（二）》</a>）。每个普通函数在执行时都有一个特定的this对象，而箭头函数执行时不会在自己的this属性上添加一个新对象，而是直接引用父级AO对象上this绑定的对象。普通函数的AO对象只有在函数执行时才产生，换言之，普通函数的this是由函数执行时的环境决定。而箭头函数的特别之处在于，当函数被定义时，就引用了其父级AO对象的this，即箭头函数的this由定义时的环境决定。</span></p>
<p><span style="font-size: 14px;">　　根据箭头函数的特点，不难推测：如果定义对象的方法直接使用箭头函数，那么函数内的this将直接指向window。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span>  <span style="color: #0000ff;">var</span> age = 123<span style="color: #000000;">;
</span><span style="color: #008080;">2</span>  let obj =<span style="color: #000000;"> {
</span><span style="color: #008080;">3</span>      age:456<span style="color: #000000;">,
</span><span style="color: #008080;">4</span>      say:() =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">5</span>          console.log(<span style="color: #0000ff;">this</span><span style="color: #000000;">.age);
</span><span style="color: #008080;">6</span> <span style="color: #000000;">     }
</span><span style="color: #008080;">7</span> <span style="color: #000000;"> };
</span><span style="color: #008080;">8</span> obj.say();<span style="color: #008000;">//</span><span style="color: #008000;">123</span>
<span style="color: #008080;">9</span> <span style="color: #008000;">//</span><span style="color: #008000;">对象是没有执行期上下文的（AO对象），定义对象的方法实际上是在全局作用域下，即window</span></span></pre>
</div>
<p><span style="font-size: 14px;">&nbsp;　　如果你一定要在箭头函数中让this指向当前对象，其实也还是有办法的（但是没必要这么麻烦啊，直接使用普通函数不是更好吗？）：</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;"> 1</span>  <span style="color: #0000ff;">var</span> age = 123<span style="color: #000000;">;
</span><span style="color: #008080;"> 2</span>  let obj =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 3</span>      age:456<span style="color: #000000;">,
</span><span style="color: #008080;"> 4</span>      say:<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;"> 5</span>          <span style="color: #0000ff;">var</span> fn = () =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;"> 6</span>          console.log(<span style="color: #0000ff;">this</span><span style="color: #000000;">.age);
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 8</span>          <span style="color: #0000ff;">return</span><span style="color: #000000;"> fn();
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">     }
</span><span style="color: #008080;">10</span> <span style="color: #000000;"> };
</span><span style="color: #008080;">11</span> obj.say();<span style="color: #008000;">//</span><span style="color: #008000;">456</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　我们来分析一下这是怎么做到的：首先，我们使用obj调用say方法时，say内创建了AO对象，并且该AO对象的this属性指向了obj（这里不明白的请回去复习一下我的<a href="https://www.cnblogs.com/ruhaoren/p/11459963.html" target="_blank">《JavaScript之深入函数/对象》</a>），然后，say内部又声明了一个箭头函数。我们说箭头函数在声明时就要强行引用父级AO的this属性，那么现在该箭头函数的父级AO是谁呢？当然就是say的AO啦，所以这里箭头函数的this直接就绑定了obj，最后箭头函数在执行时拿到的this，实际上就是say方法的AO.this，即obj本身。</span></p>
<p><span style="font-size: 14px;">　　上面是在对象中使用箭头函数，如果那让你难于理解，那么请看下面这种方式：在普通函数中使用箭头函数。</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">var</span> obj = {name:'ren'<span style="color: #000000;">};
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> test(){
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">var</span> fn = () =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">4</span>         console.log(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">5</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">6</span> <span style="color: #000000;">    fn();
</span><span style="color: #008080;">7</span> <span style="color: #000000;">}
</span><span style="color: #008080;">8</span> test();<span style="color: #008000;">//</span><span style="color: #008000;">window</span>
<span style="color: #008080;">9</span> test.call(obj);<span style="color: #008000;">//</span><span style="color: #008000;">{name:'ren'}</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　test函数在全局执行时，其this指向window，这时也产生了箭头函数的定义，于是箭头函数内的this也被指向了window，所以最终打印出window对象。</span></p>
<p><span style="font-size: 14px;">　　当我们手动改变test函数执行时this的指向时，箭头函数定义所绑定的this实际上也被我们修改了。所以最终打印出obj。</span></p>
<p><span style="font-size: 14px;">&nbsp;</span></p>
<p><span style="font-size: 14px;"><span style="font-size: 16px;"><strong>四　　class（类）</strong></span>　　</span></p>
<p><span style="font-size: 14px;">　　class 作为对象的模板被引入ES6，你可以通过 class 关键字定义类。class 的本质依然是一个函数。</span></p>
<p><span style="font-size: 14px;">　　1，创建类</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;"> 1</span> class Ex {<span style="color: #008000;">//</span><span style="color: #008000;">关键字申明方式</span>
<span style="color: #008080;"> 2</span> <span style="color: #000000;">    constructor(name){
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">this</span>.say = () =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;"> 5</span>             console.log(<span style="color: #0000ff;">this</span><span style="color: #000000;">.name);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    methods(){
</span><span style="color: #008080;"> 9</span>         console.log('hello ' + <span style="color: #0000ff;">this</span><span style="color: #000000;">.name);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span>     static a = 123<span style="color: #000000;">;
</span><span style="color: #008080;">12</span>     static m = () =&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;">13</span>         console.log(<span style="color: #0000ff;">this</span><span style="color: #000000;">.a);
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">15</span> <span style="color: #000000;">}
</span><span style="color: #008080;">16</span> <span style="color: #008000;">//</span><span style="color: #008000;">let ex = class{}  字面量方式</span>
<span style="color: #008080;">17</span> <span style="color: #0000ff;">var</span> example = <span style="color: #0000ff;">new</span> Ex('ren'<span style="color: #000000;">);
</span><span style="color: #008080;">18</span> example.say();<span style="color: #008000;">//</span><span style="color: #008000;">'ren'</span>
<span style="color: #008080;">19</span> Ex.m();<span style="color: #008000;">//</span><span style="color: #008000;">123<br /><span style="color: #008080;">20</span> <span style="color: #000000;">example.methods();</span>//'hello ren'</span></span></pre>
</div>
<pre><code><span style="font-size: 14px;">　　constructor是创建类必须的方法，当使用new调用类创建实例时，将自动执行该方法，该方法和构造函数类似，默认返回this对象。<strong>实例的方法和属性都定义在constructor内部</strong>。相当于构造函数的this方式。<br /></span></pre>
<pre><code><span style="font-size: 14px;">　　类保留了prototype属性，类中的方法不需要使用function关键字，并且方法之间不需要逗号隔开。<strong>类中定义的方法实际上还是保存在类的prototype属性上</strong>。</span></pre>
<pre><code><span style="font-size: 14px;">　　使用static关键字定义类的静态属性和方法。类中不能定义共有属性，要想定义实例的共有属性还是需要使用prototype属性：Ex.prototype.属性名 = 属性值。<br /><br />　　创建实例依然使用new关键字。<br /><br />　　<strong>2，类的继承</strong><br />　　类的继承通过extends关键字实现。</span></pre>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008080;"> 1</span> <span style="color: #000000;">class Person {
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">    constructor (name,age){
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">    say(){
</span><span style="color: #008080;"> 7</span>         console.log(<span style="color: #0000ff;">this</span>.name + ':' + <span style="color: #0000ff;">this</span><span style="color: #000000;">.age);
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">}
</span><span style="color: #008080;">10</span> <span style="color: #000000;">class Student extends Person{
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    constructor (name,age,sex){
</span><span style="color: #008080;">12</span> <span style="color: #000000;">        super(name,age);
</span><span style="color: #008080;">13</span>         <span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">15</span> <span style="color: #000000;">}
</span><span style="color: #008080;">16</span> <span style="color: #0000ff;">var</span> student = <span style="color: #0000ff;">new</span> Student('ren',12,'male'<span style="color: #000000;">);
</span><span style="color: #008080;">17</span> student.name;<span style="color: #008000;">//</span><span style="color: #008000;">'ren'</span>
<span style="color: #008080;">18</span> student.sex;<span style="color: #008000;">//</span><span style="color: #008000;">'male'</span>
<span style="color: #008080;">19</span> student.say();<span style="color: #008000;">//</span><span style="color: #008000;">'ren:12'</span></span></pre>
</div>
<p><span style="font-size: 14px;">　　子类继承自父类，不会隐式的创建自己的this对象，而是通过super()引用父类的this。这个过程和在子构造函数内使用父构造函数call(this)很像，但他们有本质的区别。另外，ES6规定，super()必须在子类的this之前执行。所以一般我们把super()放在子类constructor方法的第一行，这样准没错！</span></p>
<p><span style="font-size: 14px;">&nbsp;</span></p>
<p><span style="font-size: 16px;"><strong>五　　异步机制</strong></span></p>
<p><span style="font-size: 14px;"><strong>　　</strong>ES6新增了两种实现异步的新机制，Promise和Generator。文笔有限，怕讲的不清楚，误人子弟，请有兴趣的同学去下面的链接继续学习，廖老师的教程也是受很多人推崇的，当然MDN更官方。（实际上是需要较大篇幅才能讲明白，这里就偷个懒了）</span></p>
<p><span style="font-size: 14px;">　　<strong>1，Promise</strong></span></p>
<p><span style="font-size: 14px;">　　<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></span></p>
<p><span style="font-size: 14px;">　　<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544">https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544</a></span></p>
<p><span style="font-size: 14px;">　　<strong>2，Generator</strong></span></p>
<p><span style="font-size: 14px;">　　<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator</a></span></p>
<p><span style="font-size: 14px;">　　<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112">https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112</a></span></p>
<p><span style="font-size: 14px;">　　</span></p>
<p><span style="font-size: 14px;">&nbsp;</span></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>