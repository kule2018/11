<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ES6简述' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ES6简述</center></div><div class='banquan'>原文出处:本文由博客园博主兰为鹏提供。<br/>
原文连接:https://www.cnblogs.com/lanweipeng/p/10992884.html</div><br>
    <h1 id="啥是es6">啥是ES6</h1>
<p>大家都知道，JavaScript由DOM、BOM、ECMAScript组成，ECMAScript是标准。<br />
ES6的全称其实是ES2015（6.0）每年更新，依次类推<br />
ES2016(7)<br />
...<br />
ES2019(10)</p>
<h1 id="为啥要推es6">为啥要推ES6</h1>
<p>两个字：方便。不用ES6也能写，使用ES6就是为了方便，能用更少的代码去做更多的事情，为了提高工程性。</p>
<h1 id="es6有哪些东西">ES6有哪些东西</h1>
<h2 id="变量">变量</h2>
<p>let用于声明变量<br />
const用于声明常量，且不可修改<br />
相比var，ES6的变量有啥好处<br />
<strong>1.禁止重复声明</strong><br />
ES5</p>
<pre><code><code>var a = 12;
var a = 5;
console.log(a)</code></pre>
<p>输出为5，一点问题没有<br />
ES6</p>
<pre><code><code>let a = 12;
let a = 5;
console.log(5)</code></pre>
<blockquote>
<p><img src="./images/ES6简述0.png" alt="image.png" /><br />
它会告诉你a已经被定义过了，不能重复定义</p>
</blockquote>
<p><strong>2.控制修改</strong></p>
<pre><code><code>const a = 5;
a = 12;
console.log(a);</code></pre>
<blockquote>
<p><img src="./images/ES6简述1.png" alt="image.png" /><br />
它告诉你你给常量赋值，这是不行的</p>
</blockquote>
<p><strong>3.支持块级作用域</strong><br />
ES5只有函数级作用域</p>
<pre><code><code>function sum(a, b) {
  return a+b;
}
console.log(a)</code></pre>
<blockquote>
<p><img src="./images/ES6简述2.png" alt="image.png" /></p>
</blockquote>
<p>这时候它在外面是访问不到a的<br />
ES6有块级作用域</p>
<ul>
<li>{}</li>
<li>if(){}</li>
<li>for(){}</li>
<li>{}</li>
</ul>
<pre><code><code>{
  var a = 12;
}
console.log(a);</code></pre>
<p>输出12</p>
<pre><code><code>{
  let a = 12;
}
console.log(a);</code></pre>
<blockquote>
<p><img src="./images/ES6简述3.png" alt="image.png" /></p>
</blockquote>
<h2 id="解构赋值">解构赋值</h2>
<p>不用解构赋值</p>
<pre><code><code>//后台读取的数据
var json = {age: 12,height: 168}
console.log(json.age,json.height);</code></pre>
<p>用完解构赋值</p>
<pre><code><code>let {age,height} = {age: 12,height: 168};
console.log(age,height)</code></pre>
<p>你就不需要去点了<br />
<strong>注意事项</strong><br />
1.左右两边一样</p>
<pre><code><code>let {a,b,c}={a: 12, b: 55, c: 99};//同是对象
let [a,b,c]=[12,5,8];//同是数组</code></pre>
<p>2.右边得是个东西</p>
<pre><code><code>let {a,b,c} = {12,5,13};//右边是啥，对象？数组？都不是</code></pre>
<blockquote>
<p><img src="./images/ES6简述4.png" alt="image.png" /></p>
</blockquote>
<h2 id="函数">函数</h2>
<h3 id="箭头函数">箭头函数</h3>
<p>使用箭头函数不仅写起来简单而且能修复this的问题<br />
1.简单<br />
ES5</p>
<ul>
<li>function xx() {}</li>
<li>var xx = function() {}<br />
ES6<br />
let xx = (参数)=&gt;{}</li>
<li>有且仅有一个参数 ()可以省略</li>
<li>有且仅有一条语句 return {}可以省略</li>
</ul>
<pre><code><code>let show=()=&gt;({a: 12, b: 5});//用()包一下</code></pre>
<p>2.修复this<br />
ES5<br />
在ES5，谁调用this，this就是谁<br />
在ES6,this绑定在当前的环境</p>
<h3 id="参数展开">参数展开</h3>
<p><strong>(1)剩余参数</strong></p>
<pre><code><code>function show(a, b, ...arr){
  console.log(a, b, arr);
}
show(12,5,44,7,85,34,33);</code></pre>
<blockquote>
<p>12,5,44,7,85,34,33</p>
</blockquote>
<p><strong>注意</strong>：必须是最后一个</p>
<pre><code><code>function show(a, b, ...arr, c){
  console.log(a, b, arr, c);
}
show(12,5,44,7,85,34,33);</code></pre>
<blockquote>
<p><img src="./images/ES6简述5.png" alt="image.png" /><br />
剩余参数必须得是最后一个形参</p>
</blockquote>
<p><strong>(2)数组展开</strong><br />
...arr等价于1,5,12,3</p>
<pre><code><code>let arr = [1,5,12,3];
var sum=(a, b, c, d)=&gt;a+b+c+d;
console.log(sum(...arr))</code></pre>
<blockquote>
<p>21</p>
</blockquote>
<pre><code><code>let arr = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = [...arr1, ...arr2];
console.log(arr3);</code></pre>
<blockquote>
<p>1,2,3,4,5,6</p>
</blockquote>
<h2 id="系统对象">系统对象</h2>
<h3 id="array">Array</h3>
<p>4个API，由对象来调用<br />
map 映射<br />
forEach 循环<br />
filter 过滤（删除）<br />
reduce 减少<br />
<strong>(1)map</strong><br />
映射：1对1，进去100个，出来100个</p>
<pre><code><code>var scores = [100,60,52,48,98,13,45,66,75,98];
//两个参数item，index
var res = scores.map((item)=&gt;item&gt;=60);
console.log(scores,res);</code></pre>
<blockquote>
<p><img src="./images/ES6简述6.png" alt="image.png" /></p>
</blockquote>
<p><strong>(2)forEach</strong><br />
把true筛出来</p>
<pre><code><code>let arr = [1,5,12];
arr.forEach((item,index)=&gt;{
  console.log(`第${index}个：${item}`);
});</code></pre>
<blockquote>
<p>第0个：1<br />
第1个：5<br />
第2个：12</p>
</blockquote>
<p><strong>(3)filter</strong></p>
<pre><code><code>let scores = [1,2,3,5,6,95,63,45,68,60];
let pass = scores.filter((item)=&gt;item&gt;=60);
console.log(pass)</code></pre>
<blockquote>
<p>(4) [95, 63, 68, 60]</p>
</blockquote>
<p><strong>(4)reduce</strong><br />
求和</p>
<pre><code><code>let arr = [1,5,3,16];
    let res = arr.reduce((temp,item,index)=&gt;{
        console.log(`temp:${temp}`);
        return temp+item;
    });
    console.log(`res:${res}`);</code></pre>
<blockquote>
<p>temp:1//第一次是第一个数<br />
temp:6//后面都是和<br />
temp:9<br />
<a href="res:25" class="uri">res:25</a></p>
</blockquote>
<p>求平均数</p>
<pre><code><code>let arr = [1,5,3,16];
    let res = arr.reduce((temp,item,index)=&gt;{
        if(index&lt;arr.length - 1)
            return temp+item;
        else
            return (temp+item)/2;
    });
    console.log(`res:${res}`);</code></pre>
<h3 id="string">String</h3>
<p><strong>(1)字符串模板</strong></p>
<pre><code><code>let name = &#39;小明&#39;;
console.log(`name : ${name}`);</code></pre>
<blockquote>
<p>name : 小明</p>
</blockquote>
<p><strong>好处：</strong>能折行，对于大段的东西很适用</p>
<pre><code><code>let str = `&lt;div&gt;
&lt;p&gt;第一行${item1}&lt;/p&gt;
&lt;span&gt;第二行${item2}&lt;/span&gt;
&lt;/div&gt;`;</code></pre>
<p><strong>(2)startsWith</strong></p>
<pre><code><code>let url = &#39;http://www.baidu.com&#39;;
if(url.startsWith(&#39;http&#39;)||url.startsWith(&#39;https&#39;)) console.log(&#39;是网址&#39;);
else console.log(&#39;不是网址&#39;)</code></pre>
<p><strong>(3)endsWith</strong></p>
<h3 id="json">JSON</h3>
<p>标准写法：</p>
<pre><code><code>let json = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:12};</code></pre>
<ul>
<li>stringify：对象转json</li>
</ul>
<pre><code><code>let xiaoming = {
  name: &#39;xiaoming&#39;,
  age: 25
};
console.log(JSON.stringify(xiaoming));</code></pre>
<blockquote>
<p>{&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:25}</p>
</blockquote>
<ul>
<li>parse：字符串转对象</li>
</ul>
<pre><code><code>let json = &#39;{&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:25}&#39;;
console.log(JSON.parse(json));</code></pre>
<blockquote>
<p>{name: &quot;xiaoming&quot;, age: 25}</p>
</blockquote>
<h2 id="异步操作">异步操作</h2>
<ul>
<li>优点：程序性能好，资源利用率高、用户体验好</li>
<li>缺点：程序员体验不好</li>
</ul>
<p><strong>问题</strong>：按顺序拉取数据<br />
<strong>环境</strong>：服务器<br />
我用的是WampServer</p>
<p>data/1.json</p>
<pre><code><code>{a: 1}</code></pre>
<p>./data/2.json</p>
<pre><code><code>{b: 12}</code></pre>
<p>./data/3.json</p>
<pre><code><code>{c: 16}</code></pre>
<p>./html</p>
<pre><code><code> $.ajax({
      url: &#39;data/1.json&#39;,
      dataType: &#39;json&#39;,
      success(data1) {
        $.ajax({
          url: &#39;data/2.json&#39;,
          dataType: &#39;json&#39;,
          success(data2) {
            $.ajax({
               url: &#39;data/3.json&#39;,
            dataType: &#39;json&#39;,
            success(data3) {
              console.log(data1,data2,data3)
            }
          });
          }
        });
      }
    });</code></pre>
<blockquote>
<p>{a: 1} {b: 12} {c: 16}</p>
</blockquote>
<p>因为这种写法恶心，所以Promise出现了<br />
了解一下Promise，其实jQuery的ajax也是Promise</p>
<pre><code><code>let p=new Promise(function (resolve, reject){//resolve成功，reject失败
      $.ajax({
        url: &#39;data/1.json&#39;,
        dataType: &#39;json&#39;,
        success(data){
          resolve(data);
        },
        error(res){
          reject(res);
        }
      });
    });

    p.then(function (data){
      alert(&#39;成功&#39;);
      console.log(data);
    }, function (res){
      alert(&#39;失败&#39;);
      console.log(res);
    });</code></pre>
<p>怎么用</p>
<pre><code><code>Promise.all([
      $.ajax({url:&#39;data/1.json&#39;, dataType: &#39;json&#39;}),
      $.ajax({url:&#39;data/2.json&#39;, dataType: &#39;json&#39;}),
      $.ajax({url:&#39;data/3.json&#39;, dataType: &#39;json&#39;})
      ]).then(([data1,data2,data3])=&gt;{
        console.log(data1,data2,data3);
    },(res)=&gt;{
      alert(&#39;错了&#39;)//一个接口出错就不渲染
    })</code></pre>
<blockquote>
<p>{a: 1}a: 1__proto__: Object<br />
{b: 12}b: 12__proto__: Object<br />
{c: 16}c: 16__proto__: Object</p>
</blockquote>
<p>但是Promise有个致命的缺点，处理不了逻辑（第一个数据可能决定后面读什么）<br />
因此async/await登场了，专门配合Promise，用同步的方法来写异步。<br />
但是其实编译完还是恶心的嵌套，只不过不需要我们程序员来写，编译就完了</p>
<pre><code><code>let show = async ()=&gt; {
  let data1 = await $.ajax({url: &#39;data/1.json&#39;, dataType: &#39;json&#39;});//await后面跟的是Promise
  let data2 = await $.ajax({url: &#39;data/2.json&#39;, dataType: &#39;json&#39;});
  let data3 = await $.ajax({url: &#39;data/3.json&#39;, dataType: &#39;json&#39;});
  console.log(data1,data2,data3)
}
show();</code></pre>
<blockquote>
<p>{a: 1} {b: 12} {c: 16}</p>
</blockquote>
<p>处理逻辑</p>
<pre><code><code>let show = async ()=&gt; {
      let data1 = await $.ajax({url: &#39;data/1.json&#39;, dataType: &#39;json&#39;});
      if(data1&lt;10) {
        let data2 = await $.ajax({url: &#39;data/2.json&#39;, dataType: &#39;json&#39;});
        console.log(data1,data2)
      }else {
        let data3 = await $.ajax({url: &#39;data/3.json&#39;, dataType: &#39;json&#39;});
        console.log(data1,data3)
      }
    }
    show();</code></pre>
<blockquote>
<p>{a: 1} {c: 16}</p>
</blockquote>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>