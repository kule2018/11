<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaScript 面向对象' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaScript 面向对象</center></div><div class='banquan'>原文出处:本文由博客园博主0807提供。<br/>
原文连接:https://www.cnblogs.com/qirui-/p/11360278.html</div><br>
    <p><strong>1. 什么是对象？</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>对象object 是一些相关的变量和方法的软件集。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;特性： 属性和方法</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;JavaScript中的所有事物都是对象。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;创建对象的方法：</p>
<ol>
<li>字面量</li>
<li>new Object()&nbsp; 创建</li>
<li>自定义构造函数</li>
<li>Object.create() 创建</li>
<li>工厂函数</li>
</ol>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
</span><span style="color: #008000;">//</span><span style="color: #008000;"> obj是对象，Object是类</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 对象是类的实例和具体，类是对象的集合</span></pre>
</div>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;建立一个工厂函数</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> createStudent(name,age,ClassName){
            </span><span style="color: #0000ff;">var</span> obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
            obj.name </span>=<span style="color: #000000;"> name;
            obj.age </span>=<span style="color: #000000;"> age;
            obj.ClassName </span>=<span style="color: #000000;"> ClassName;
            obj.study </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
                console.log(</span>"学习Css"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> obj;
        }</span></pre>
<pre><code>        var ming=  createStudent("明",20,"1811"<span>);
        var hong=  createStudent("红",21,"1811"<span>);</span></span></pre>
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 可以很好减少代码量</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>2.什么是面向对象？</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong>面向对象是一个思想，就是把解决问题的注意力集中到对象上。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 面向对象的三大特点：封装 继承 多态。&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 封装：把所有相关的属性和方法封装在一个对象里。<br />&nbsp; &nbsp; &nbsp; &nbsp; 继承：自己没有的属性或者方法，可以把别的拿过来用<br />&nbsp; &nbsp; &nbsp; &nbsp; 多态：不同的对象根据事件情况，执行代码不同。js可以模拟实现。</p>
<p><strong>3.常用的内置对象（构造函数）</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">Number String Boolean
Array Date Math RegExp
Function Object
Global Error<br /></span></pre>
</div>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong>构造函数: new&nbsp; 后面就是构造函数，构造函数中的this就是指向当前对象。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> arr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
</span><span style="color: #008000;">//</span><span style="color: #008000;"> arr 是对象，Array 是类。 对象是由类所构造的。</span>
<span style="color: #008000;">//</span><span style="color: #008000;"> Array() 是构造函数</span></pre>
</div>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;把工厂函数变换成构造函数</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> createStudent(name,age,ClassName){
            </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
            </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
            </span><span style="color: #0000ff;">this</span>.ClassName =<span style="color: #000000;"> ClassName;
            </span><span style="color: #0000ff;">this</span>.study = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
                console.log(</span>"学习Css"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> obj;
        }

        </span><span style="color: #0000ff;">var</span> ming= <span style="color: #0000ff;">new</span> createStudent("明",20,"1811"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">var</span> hong= <span style="color: #0000ff;">new</span> createStudent("红",21,"1811"<span style="color: #000000;">);

         ming.study();
         hong.study();

         </span><span style="color: #008000;">//</span><span style="color: #008000;"> ming 是对象  createStudent是类  createStudent是构造函数</span>
         <span style="color: #008000;">//</span><span style="color: #008000;"> 类的本质还是函数</span>
        </pre>
</div>
<p>&nbsp;</p>
<p><strong>4.原型对象</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;js就是基于原型的对象。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(){

}
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
</span><span style="color: #008000;">//</span><span style="color: #008000;">1. 每个类（函数） 天生有一个prototype 的属性，创建了一个对象，而这个对象的就是这个函数的原型，这个对象里有个constructor(构造函数) 的属性，属性值是类本身。</span><span style="color: #008000;">
//</span><span style="color: #008000;">2. 我们所有new 一个类的时候，其实是调用它的构造函数。构造函数里的属性都是私有的，构造函数里的this都是实例对象。</span><span style="color: #008000;">
//</span><span style="color: #008000;">3. 每个对象上天生有一个__proto__ ，指向类的原型。</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>5.原型链</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp;</strong>&nbsp; &nbsp; &nbsp;原型链： 由各级对象的__proto__逐级继承形成的关系。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;原型链的作用也是节省空间。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __proto__和prototype:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.&nbsp; prototype 是类的或者函数的， __proto__ 是对象的。<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp; __proto__是查找机制 ,prototype是存储机制。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age){  
        </span><span style="color: #0000ff;">this</span>.name=<span style="color: #000000;"> name;
}

 </span><span style="color: #0000ff;">var</span> zhang = <span style="color: #0000ff;">new</span> Person("zhang"<span style="color: #000000;">);
 console.log(zhang.name);  </span><span style="color: #008000;">//</span><span style="color: #008000;">zhang</span>
 console.log(zhang.age);  <span style="color: #008000;">//</span><span style="color: #008000;">undefined</span>

<span style="color: #008000;">//</span><span style="color: #008000;">当zhang 查找某个属性时(比如:name)：</span><span style="color: #008000;">
//</span><span style="color: #008000;">zhang 这个对象首先看name 是私有的，是就直接使用，不是的就通过 __proto__ 往它的 //类的prototype 上查找，有就直接使用，没有就继续向上查找，直到查找到基类object ,没有 //就是undefined  ,有就直接使用。这种查找机制 叫原型链。</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> 所以zhang.name 返回的是zhang，而zhang.age 返回undefined</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>6.继承</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 父类</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name){
     </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
     </span><span style="color: #0000ff;">this</span>.eat= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
      console.log(</span>"chi"<span style="color: #000000;">);
}
}
Person.prototype.age </span>= 10; <span style="color: #008000;">//</span><span style="color: #008000;"> 添加原型属性</span></pre>
</div>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>1. 原型继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Son(){
      </span><span style="color: #0000ff;">this</span>.age = 23<span style="color: #000000;">;
}
</span><span style="color: #0000ff;">var</span> p1 = <span style="color: #0000ff;">new</span> Person("zhang"<span style="color: #000000;">);
Son.prototype </span>=<span style="color: #000000;"> p1;
</span><span style="color: #0000ff;">var</span> s1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Son;
console.dir(s1.name); </span><span style="color: #008000;">//</span><span style="color: #008000;"> zhang</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> 将父类的实例赋值给子类的原型：私有的公有的都继承为共有的。</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>2. call继承 (call方法是函数/类天生自带的一个方法。);</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Son(){
      </span><span style="color: #0000ff;">this</span>.age = 23<span style="color: #000000;">;
      Person.call(</span><span style="color: #0000ff;">this</span>,"<span style="color: #000000;">123"8);
}
var p1 = new Person(</span>"zhang"<span style="color: #000000;">);
var s1 = new Son;
console.log(s1.age); // 23
console.log(s1.name); // 123

//只继承了父类构造函数的属性，没有继承父类原型的属性。</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;冒充对象继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> p1 = <span style="color: #0000ff;">new</span> Person("zhang"<span style="color: #000000;">);

</span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> key <span style="color: #0000ff;">in</span><span style="color: #000000;"> p1){
        console.log(key); </span><span style="color: #008000;">//</span><span style="color: #008000;">name in </span>
<span style="color: #000000;">}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 将父类私有的和公有的都继承为子类私有的 使用for in</span><span style="color: #008000;">
//</span><span style="color: #008000;"> for in 可以遍历对象的共有属性fn就是公有的</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 4. 混合继承&nbsp; (call 继承和原型继承的结合)</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 父类</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name){
     </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
}
Person.prototype.age </span>= 10; <span style="color: #008000;">//</span><span style="color: #008000;"> 添加原型属性</span>

<span style="color: #0000ff;">var</span> p1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person;
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Son() {
   Person.call(</span><span style="color: #0000ff;">this</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> 私有的继承为私有的了</span>
<span style="color: #000000;">}
Son.prototype</span>=<span style="color: #000000;">p1;
</span><span style="color: #0000ff;">var</span> s1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Son;
console.log(s1); </span><span style="color: #008000;">//</span><span style="color: #008000;"> zhang</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> 私有的继承为私有的 私有的和公有的再次继承为公有的。</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5. 组合继承</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<div class="cnblogs_code">
<pre><code>         <span style="color: #008000;">//</span><span style="color: #008000;"> 父类</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(){   
            </span><span style="color: #0000ff;">this</span>.name ="zhang"<span style="color: #000000;">;
        }
        Person.prototype.fn</span>=<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            console.log(</span>111<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">var</span> p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person;

         </span><span style="color: #008000;">//</span><span style="color: #008000;"> 子类</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> Son(){
            Person.call(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">);
        }
        Son.prototype</span>=<span style="color: #000000;">Object.create(Person.prototype);
        </span><span style="color: #0000ff;">var</span> s = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Son;
        s.__proto__.fn</span>=<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            console.log(</span>222<span style="color: #000000;">);
        }
        s.fn(); </span><span style="color: #008000;">//</span><span style="color: #008000;">222</span>
        p.fn(); <span style="color: #008000;">//</span><span style="color: #008000;">111</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6.&nbsp; 中间类继承</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(a,b,c){
            arguments.__proto__ </span>=<span style="color: #000000;"> Array.prototype;
            arguments.push(</span>89<span style="color: #000000;">);
            console.log(arguments);
}
fn(</span>45,56,23); <span style="color: #008000;">//</span><span style="color: #008000;">45,56,23,89</span></pre>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>