<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaScript学习笔记(6月份)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaScript学习笔记(6月份)</center></div><div class='banquan'>原文出处:本文由博客园博主难过_开心_好_不好提供。<br/>
原文连接:https://www.cnblogs.com/SupHumer/p/11147553.html</div><br>
    <blockquote>
<p>由于笔记比较杂，本身学习程度并不理想，所以暂时没有整理这些繁杂的笔记。<br />
ps:博客园markdown用起来和看起来都舒服太多了，这才是我了解的那个markdown，又回来了！</p>
</blockquote>
<h1 id="笔记">笔记</h1>
<h2 id="dom对象-document-object-model">DOM对象 document object model</h2>
<h3 id="dom-中节点种类一共有三种">DOM 中节点种类一共有三种</h3>
<p>注：在JS中所有的节点都是对象<br />
<code>&lt;div title=&quot;属性节点&quot;&gt;文本内容&lt;/div&gt;</code></p>
<pre><code><code>&lt;div&gt;&lt;/div&gt; =&gt; 元素节点 
title =&gt; 属性节点
文本内容 =&gt; 文本节点</code></pre>
<h3 id="查找元素节点方法">查找元素节点方法</h3>
<ol>
<li><code>document.getElementById(id);</code>//通过当前元素节点的id，获取对应元素节点<br />
</li>
</ol>
<ul>
<li>元素节点对象：<br />
通过这个节点对象(note)，访问它的一系列属性，以下就是对象名称：
<ol>
<li>note.tagname 获取元素节点的标签名<br />
</li>
<li>note.innerHTML 获取元素节点标签间的内容<br />
</li>
<li>note.id</li>
<li>note.className</li>
<li>note.title</li>
<li>note.style等</li>
</ol></li>
<li>HTML属性的属性（对应元素节点的对象）：<br />
id  <br />
title  <br />
style  <br />
innerHTML  <br />
className<br />
元素节点.属性<br />
元素节点[属性]<br />
</li>
</ul>
<pre><code><code>    document.getElementsByTagName()
    node.getElementsByTagName();</code></pre>
<ul>
<li><p>从node节点开始，找出符合的标签节点<br />
参数：标签名；<br />
功能：获取当前页面上所有符合改标签的元素节点<br />
返回值：一个装有符合条件的元素节点的数组</p></li>
<li><p>document.getElementsByName(); 只能从document调用 ps：许多的name可以一样<br />
参数：name的值<br />
返回值：装有符合条件的元素节点的数组</p></li>
<li><p>document.getElementsByClassName() ps：可以从某一个元素节点去查找<br />
参数：class<br />
返回值：所有符合条件的元素节点组合的数组。<br />
在第版本的ie浏览器中是不支持的 处理办法<br />
获取父节点的所有元素，然后进行一一判断，符合className等于参数class就可以加入数组中。</p></li>
</ul>
<h2 id="封装函数setattributechildnotesattributesparentnode">封装函数·setAttribute·childNotes·Attributes·parentNode</h2>
<ul>
<li>id document.getElementById()</li>
<li>class document.getElementsByClassName();</li>
<li>name document.getElementsByName();</li>
<li>tagName note.getElementsByTagName();</li>
</ul>
<p>通过封装函数，简化上述操作。</p>
<h3 id="css选择器">css选择器</h3>
<ul>
<li>#id //通过id获取元素节点</li>
<li>.class //通过className获取元素节点</li>
<li>tagName //通过tagName获取元素节点</li>
<li>name=xxx //通过name获取元素节点</li>
</ul>
<p>详情看$()方法 //通过封装css选择器的方法，来快速的获取对应的标签</p>
<p>作用：操作当前元素的某一个属性的<br><br />
get/setAttribute() 获取元素属性的两种方法<br><br />
removeAttribute()</p>
<ol>
<li>和点出来的class属性范围区别：点操作是通过元素节点点出className参数，<br>而set/get是通过传入class参数来获取 例如：<code>Obtn.className == Obtn.getAttribute(&quot;class&quot;)</code></li>
<li>用户自定义属性的支持。自定义xxx=&quot;yyyy&quot; <code>Obtn.setAttribute(&quot;xxx&quot;,&quot;yyy&quot;)</code><br><code>document.getElementsById(&quot;btn&quot;).getAttribute(&quot;id&quot;)</code></li>
</ol>
<p>childNotes(); 获取当前节点的所有子节点，包括三种节点类型 nodeName,nodeType,nodeValue</p>
<p>DOM节点类型<br />
元素节点 属性节点 文本节点<br />
作用:<br />
(1)删除子节点中的空白节点<br />
方法：使用正则表达式进行删除。/^\s+$/.test() 判断是否value为空<br />
删除空白节点的时候必须是倒序删除，原因自己想，想不到撞死，提示：他是一个数组类型</p>
<p>(2)不知道</p>
<p>ownerDocument 结果一般是document<br />
parentNode 父亲节点 previousSibling 同级别的上一个节点 nextSibling 同级别的下一个元素节点</p>
<p>attributes 返回该节点的属性节点,[集合]<br />
集合特点:1.不重复;2.无序<br />
其中一种访问方法：node.attributes.getNamedItem(&quot;id&quot;);</p>
<h2 id="dom创建带文本的元素节点">dom创建带文本的元素节点</h2>
<ul>
<li>document.write() //写入</li>
<li>document.createElement(&quot;div&quot;) 插入标签</li>
<li>note.appendChild()</li>
<li>parent.replaceChild(newNode,oldNode)</li>
<li>note.cloneNode() 参数：true则将文本内容传入，否则默认只克隆标签<br />
ps:系统没有提供同时插入文本和标签的方法</li>
</ul>
<pre class="javascript"><code>    var note = document.createElement(&quot;span&quot;)
    var Ntext = document.createTextNode(&quot;文本内容&quot;) 插入文本内容
    note.appendChild(Ntext)
    odiv.appendChild(note)</code></pre>
<h2 id="事件">事件</h2>
<h3 id="事件基础">1. 事件基础</h3>
<p>访问web界面的用户引起的一系列操作<br />
鼠标事件，键盘事件，HTML事件<br />
函数：on+事件名称</p>
<h3 id="事件流">2. 事件流</h3>
<p>事件：捕获，目标，冒泡<br />
阻止冒泡：</p>
<pre><code><code>    evt.cancelBubble = true //对主流浏览器和ie生效
    evt.stopPropagation() //只对主流浏览器生效</code></pre>
<p>事件委托：利用事件冒泡原理，把本应添加在元素上的事件委托给他的父级（外层）<br />
多个重复的事件，可以把这个事件委托到父级来实现。更加简洁</p>
<p>阻止默认事件<br />
比如<code>&lt;a&gt;&lt;/a&gt;</code>href跳转标签</p>
<ol>
<li>onclick 方法里面,return false</li>
<li>evt.preventDefault();</li>
<li>evt.returnValue = false;</li>
</ol>
<h3 id="dom2级事件">3. DOM2级事件</h3>
<p>DOM2级事件处理程序<br />
添加事件监听器：addEventListener(事件名，处理函数，布尔值)<br />
移除事件监听器：removeEventListener(事件名，处理函数)<br />
IE下的事件监听器：attachEvent(事件名，处理函数) detachEvent(事件名，处理函数)</p>
<p>ps:普通事件中点击事件会被后一个点击事件给覆盖，而二级事件不会被其他事件所覆盖。可以重复添加<br />
布尔值为false的时候，为正常的冒泡事件，true为捕获（从外往内）</p>
<h2 id="cookie">cookie</h2>
<ul>
<li>http协议</li>
<li>cookie的概念</li>
<li>cookie的基本操作</li>
<li>cookie的封装</li>
</ul>
<p>http：超文本传输协议，用于从web服务器传输超文本到本地浏览器的传输协议，是一个无状态的协议<br />
cookie：缓存存在本地浏览器中的数据，包括增删改查的四个部分</p>
<pre><code><code>document.cookie = &quot;userName=paikle&quot;;
//这种方式添加的cookie会随着浏览器的关闭而消失，要设置时间限制的cookie需要在后面添加date限制</code></pre>
<p>设置时间来让cookie过期，从而达到删除的效果。</p>
<pre><code><code>var oDate = new Date(); //创建时间
oDate.setDate(oDate.getDate()+3) //将时间设置为三天之后
document.cookie = &quot;user = paikle;expires=&quot;+oDate; //将cookie过期时间设置为三天后</code></pre>
<h3 id="cookie的封装">cookie的封装</h3>
<p>setcookie(name,value,day) //设置cookie<br />
getcookie() //获取cookie<br />
removecookie() //移除cookie</p>
<h2 id="正则表达式">正则表达式</h2>
<p>正则表达式是由普通字符和特殊字符组成的对字符串进行过滤的逻辑公式</p>
<h3 id="修饰符-g-i">修饰符 g i</h3>
<p>g 表示会全部搜索，返回符合的数字,i 表示忽略大小写</p>
<pre><code><code> var reg = /abc/g;
 var str = &#39;abcabc&#39;;</code></pre>
<h3 id="test方法">1.test方法</h3>
<p>正则表达式方法，检测字符串是否又符合规则的字串，有返回true，无为false</p>
<pre class="javascript"><code>//两种构造方法
var rge = /abc/;
var reg = new RegExp(&quot;abc&quot;);

var str = &quot;ab&quot;;

var flag = reg.test(str)
</code></pre>
<h3 id="match方法-字符串方法">2.match方法 字符串方法</h3>
<p>console.log(str.match(reg))</p>
<h3 id="search方法-字符串的方法-用于查找符合规则的字串的位置只返回第一个匹配的位置">3.search方法 字符串的方法 用于查找符合规则的字串的位置，只返回第一个匹配的位置</h3>
<p>var rg = /bc/<br />
console.log(str.search(rg))</p>
<h3 id="split方法">4.split方法</h3>
<h3 id="replace方法">5.replace方法</h3>
<p>var tmd = /tmd/gi<br />
var str = &quot;abc tmd tmd TMd sabi&quot;;<br />
console.log(str.replace(tmd,&quot;*&quot;));</p>
<h3 id="exec-正则表达式的方法-将匹配成功的内容放到数组内没有匹配成功返回null">6.exec 正则表达式的方法 将匹配成功的内容放到数组内，没有匹配成功返回null</h3>
<p>和match差不多的用法，不过在配置全局匹配的时候不能一次出来</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">.</td>
<td>除了换行符之外的所有单个字符</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td>var rag = /g..gle/gi;var str = 'googlegole';console.log(rag.test(str))</td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td>重复多次匹配，匹配任意次数 不管中间多少次（0-n）</td>
</tr>
<tr class="even">
<td style="text-align: center;">+</td>
<td>至少有一次重复匹配</td>
</tr>
<tr class="odd">
<td style="text-align: center;">?</td>
<td>进行0或者1次匹配</td>
</tr>
<tr class="even">
<td style="text-align: center;">[]</td>
<td>一个字母表示可出现的范围，[0-9] [a-z]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\w</td>
<td>数组字母下划线等同于[0-9a-zA-Z_]</td>
</tr>
<tr class="even">
<td style="text-align: center;">\W</td>
<td>非数字字母下划线</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\d</td>
<td>数字0-9</td>
</tr>
<tr class="even">
<td style="text-align: center;">\D</td>
<td>非数字</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\s</td>
<td>匹配空格 \S 非空格</td>
</tr>
<tr class="even">
<td style="text-align: center;">{m,n}</td>
<td>至少匹配m次，至多匹配n次</td>
</tr>
<tr class="odd">
<td style="text-align: center;">/^开头.*结尾&amp;/</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;">|</td>
<td>或 /a</td>
</tr>
<tr class="odd">
<td style="text-align: center;">()</td>
<td>分组 将内容作为一个整体去匹配</td>
</tr>
</tbody>
</table>
<h2 id="es6">ES6</h2>
<ul>
<li>let的使用</li>
<li>解构赋值</li>
<li>模板字符串</li>
<li>箭头函数</li>
<li>set结构和map结构</li>
<li>生成器函数</li>
<li>类class</li>
</ul>
<h3 id="let的使用">1.let的使用</h3>
<p>用来声明变量。用法类似于var ，但是所声明的变量，只在let命令所在的代码块有效。<br />
存在块级作用域 <code>{}</code><br />
不存在声明提升<br />
不允许重复声明(包括普通变量和函数参数)<br />
const使用 用来声明常量，不要试图改变常量的值，其他语法参照let</p>
<h3 id="解构赋值">2.解构赋值</h3>
<pre class="javascript"><code>    //默认赋值
    let [a,b,c] = [1,2,3]
    [a,b=2] = [3] // a = 3,b = 2
    let c ; //undifined;
    [a=1] = [c] //a = 1
    //对象
    let {a,b} = {a:&#39;100&#39;,b:&#39;200&#39;} // a = 100 , b = 200
    let {a:b} = {a:111} // b = 111;
    let {a,b = 4} = {a:1} //a = 1;b = 4
</code></pre>
<h3 id="箭头函数">3.箭头函数</h3>
<ol>
<li>只有一个表达式</li>
<li>含有多条语句</li>
<li>this的指向问题<br />
在箭头函数内的this指向定义时的作用域，而不是执行时的作用域。</li>
</ol>
<pre class="javascript"><code>var name = &quot;作用域1&quot;
    var obj = {
        &#39;name&#39;:&#39;jonson&#39;,
        &#39;syHello&#39;:()=&gt;{
            this.name;//this指向定义的作用域，则返回：作用域1
        }
    }
//ps
var obj = {
    &#39;name&#39;:&quot;joson&quot;,
    &quot;syHello&quot;:function(){
        this.name;//joson
    }
}</code></pre>
<h3 id="set结构-map结构">3.set结构 &amp; map结构</h3>
<h4 id="set">set</h4>
<p>set的值是不能重复的，相当于集合<br />
var set = new Set([1,3,2,2,34,1,3])<br />
<code>var arr = [...set]</code> 扩展运算符，将类数组对象转换以逗号分割的序列，set转换为数组的方式<br />
arr 为数组形式<br />
使用for of 遍历set or 数组</p>
<pre class="html"><code>for(let et of set){ //et直接代表元素
    console.log(et)
}</code></pre>
<p>set.size 长度 set.add() 添加一个 set.delete() 删除某一个 set.has() 是否包含某一个 set.clear() 清空<br />
keys() 返回键名<br />
values() 返回键值<br />
entries() 返回键值对</p>
<p>forEach()</p>
<h4 id="map">map</h4>
<p><code>let map = new Map([['name':'john'],['age':'30']])</code><br />
map.set(key,value) 添加元素<br />
map.set(key,value) map.get(key) map.delete() map.has(key) map.clear();</p>
<p>keys() 返回键名<br />
values() 返回键值<br />
entries() 返回键值对<br />
forEach() map.forEarch((value,key) =&gt; console.log(value*2))</p>
<h3 id="生成器函数">4.生成器函数</h3>
<h3 id="class">5.class</h3>
<pre class="javascript"><code>    class Person{
        constructor(name){
            this.name = name;
        }
    }</code></pre>
<h2 id="js动画-7.1记">JS动画 （7.1记）</h2>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>