<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaScript数据结构——栈的实现与应用' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaScript数据结构——栈的实现与应用</center></div><div class='banquan'>原文出处:本文由博客园博主Jaxu提供。<br/>
原文连接:https://www.cnblogs.com/jaxu/p/11264017.html</div><br>
    <p>　　在计算机编程中，栈是一种很常见的数据结构，它遵从后进先出（LIFO&mdash;&mdash;Last In First Out）原则，新添加或待删除的元素保存在栈的同一端，称作栈顶，另一端称作栈底。在栈中，新元素总是靠近栈顶，而旧元素总是接近栈底。</p>
<p>　　让我们来看看在JavaScript中如何实现栈这种数据结构。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Stack() {<br />    let items = [];<br />
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 向栈添加新元素</span>
    <span style="color: #0000ff;">this</span>.push = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (element) {
      items.push(element);
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 从栈内弹出一个元素</span>
    <span style="color: #0000ff;">this</span>.pop = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> items.pop();
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回栈顶的元素</span>
    <span style="color: #0000ff;">this</span>.peek = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
      </span><span style="color: #0000ff;">return</span> items[items.length - 1<span style="color: #000000;">];
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 判断栈是否为空</span>
    <span style="color: #0000ff;">this</span>.isEmpty = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #0000ff;">return</span> items.length === 0<span style="color: #000000;">;
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回栈的长度</span>
    <span style="color: #0000ff;">this</span>.size = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> items.length;
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 清空栈</span>
    <span style="color: #0000ff;">this</span>.clear = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
      items </span>=<span style="color: #000000;"> [];
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 打印栈内的所有元素</span>
    <span style="color: #0000ff;">this</span>.print = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
      console.log(items.toString());
    };
}</span></pre>
</div>
<p>　　我们用最简单的方式定义了一个Stack类。在JavaScript中，我们用function来表示一个类。然后我们在这个类中定义了一些方法，用来模拟栈的操作，以及一些辅助方法。代码很简单，看起来一目了然，接下来我们尝试写一些测试用例来看看这个类的一些用法。</p>
<div class="cnblogs_code">
<pre><code>let stack = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stack();
console.log(stack.isEmpty()); </span><span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #000000;">
stack.push(</span>5<span style="color: #000000;">);
stack.push(</span>8<span style="color: #000000;">);
console.log(stack.peek()); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 8</span>
<span style="color: #000000;">
stack.push(</span>11<span style="color: #000000;">);
console.log(stack.size()); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 3</span>
console.log(stack.isEmpty()); <span style="color: #008000;">//</span><span style="color: #008000;"> false</span>
<span style="color: #000000;">
stack.push(</span>15<span style="color: #000000;">);
stack.pop();
stack.pop();
console.log(stack.size()); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 2</span>
stack.print(); <span style="color: #008000;">//</span><span style="color: #008000;"> 5,8</span>
<span style="color: #000000;">
stack.clear();
stack.print(); </span><span style="color: #008000;">//</span> </pre>
</div>
<p>　　返回结果也和预期的一样！我们成功地用JavaScript模拟了栈的实现。但是这里有个小问题，由于我们用JavaScript的function来模拟类的行为，并且在其中声明了一个私有变量items，因此这个类的每个实例都会创建一个items变量的副本，如果有多个Stack类的实例的话，这显然不是最佳方案。我们尝试用ES6（ECMAScript 6）的语法重写Stack类。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">class Stack {
    constructor () {
        </span><span style="color: #0000ff;">this</span>.items =<span style="color: #000000;"> [];
    }

    push(element) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.items.push(element);
    }

    pop() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.items.pop();
    }

    peek() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.items[<span style="color: #0000ff;">this</span>.items.length - 1<span style="color: #000000;">];
    }

    isEmpty() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.items.length === 0<span style="color: #000000;">;
    }

    size() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.items.length;
    }

    clear() {
        </span><span style="color: #0000ff;">this</span>.items =<span style="color: #000000;"> [];
    }

    print() {
        console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.items.toString());
    }
}</span></pre>
</div>
<p>　　没有太大的改变，我们只是用ES6的简化语法将上面的Stack函数转换成了Stack类。类的成员变量只能放到constructor构造函数中来声明。虽然代码看起来更像类了，但是成员变量items仍然是公有的，我们不希望在类的外部访问items变量而对其中的元素进行操作，因为这样会破坏栈这种数据结构的基本特性。我们可以借用ES6的Symbol来限定变量的作用域。</p>
<div class="cnblogs_code">
<pre><code>let _items =<span style="color: #000000;"> Symbol();

class Stack {
    constructor () {
        </span><span style="color: #0000ff;">this</span>[_items] =<span style="color: #000000;"> [];
    }

    push(element) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">[_items].push(element);
    }

    pop() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">[_items].pop();
    }

    peek() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>[_items][<span style="color: #0000ff;">this</span>[_items].length - 1<span style="color: #000000;">];
    }

    isEmpty() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>[_items].length === 0<span style="color: #000000;">;
    }

    size() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">[_items].length;
    }

    clear() {
        </span><span style="color: #0000ff;">this</span>[_items] =<span style="color: #000000;"> [];
    }

    print() {
        console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">[_items].toString());
    }
}</span></pre>
</div>
<p>　　这样，我们就不能再通过Stack类的实例来访问其内部成员变量_items了。但是仍然可以有变通的方法来访问_items：</p>
<div class="cnblogs_code">
<pre><code>let stack = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stack();
let objectSymbols </span>= Object.getOwenPropertySymbols(stack);</pre>
</div>
<p>　　通过Object.getOwenPropertySymbols()方法，我们可以获取到类的实例中的所有Symbols属性，然后就可以对其进行操作了，如此说来，这个方法仍然不能完美实现我们想要的效果。我们可以使用ES6的WeakMap类来确保Stack类的属性是私有的：</p>
<div class="cnblogs_code">
<pre><code>const items = <span style="color: #0000ff;">new</span><span style="color: #000000;"> WeakMap();

class Stack {
    constructor () {
        items.set(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">, []);
    }

    push(element) {
        let s </span>= items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        s.push(element);
    }

    pop() {
        let s </span>= items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s.pop();
    }

    peek() {
        let s </span>= items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> s[s.length - 1<span style="color: #000000;">];
    }

    isEmpty() {
        </span><span style="color: #0000ff;">return</span> items.get(<span style="color: #0000ff;">this</span>).length === 0<span style="color: #000000;">;
    }

    size() {
        </span><span style="color: #0000ff;">return</span> items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">).length;
    }

    clear() {
        items.set(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">, []);
    }

    print() {
        console.log(items.get(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">).toString());
    }
}</span></pre>
</div>
<p>　　现在，items在Stack类里是真正的私有属性了，但是，它是在Stack类的外部声明的，这就意味着谁都可以对它进行操作，虽然我们可以将Stack类和items变量的声明放到<a href="https://www.w3schools.com/js/js_function_closures.asp" target="_blank">闭包</a>中，但是这样却又失去了类本身的一些特性（如扩展类无法继承私有属性）。所以，尽管我们可以用ES6的新语法来简化一个类的实现，但是毕竟不能像其它强类型语言一样声明类的私有属性和方法。有许多方法都可以达到相同的效果，但无论是语法还是性能，都会有各自的优缺点。</p>
<div class="cnblogs_code">
<pre><code>let Stack = (<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    const items </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WeakMap();
    class Stack {
        constructor () {
            items.set(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">, []);
        }

        push(element) {
            let s </span>= items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
            s.push(element);
        }

        pop() {
            let s </span>= items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s.pop();
        }

        peek() {
            let s </span>= items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> s[s.length - 1<span style="color: #000000;">];
        }

        isEmpty() {
            </span><span style="color: #0000ff;">return</span> items.get(<span style="color: #0000ff;">this</span>).length === 0<span style="color: #000000;">;
        }

        size() {
            </span><span style="color: #0000ff;">return</span> items.get(<span style="color: #0000ff;">this</span><span style="color: #000000;">).length;
        }

        clear() {
            items.set(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">, []);
        }

        print() {
            console.log(items.get(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">).toString());
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Stack;
})();</span></pre>
</div>
<p>&nbsp;</p>
<p>　　下面我们来看看栈在实际编程中的应用。</p>
<h3>进制转换算法</h3>
<p>　　将十进制数字10转换成二进制数字，过程大致如下：</p>
<p>　　10 / 2 = 5，余数为0</p>
<p>　　5 / 2 = 2，余数为1</p>
<p>　　2 / 2 = 1，余数为0</p>
<p>　　1 / 2 = 0, 余数为1</p>
<p>　　我们将上述每一步的余数颠倒顺序排列起来，就得到转换之后的结果：1010。</p>
<p>　　按照这个逻辑，我们实现下面的算法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> divideBy2(decNumber) {
   let remStack </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stack();
   let rem, binaryString </span>= ''<span style="color: #000000;">;

   </span><span style="color: #0000ff;">while</span>(decNumber &gt; 0<span style="color: #000000;">) {
       rem </span>= Math.floor(decNumber % 2<span style="color: #000000;">);
       remStack.push(rem);
       decNumber </span>= Math.floor(decNumber / 2<span style="color: #000000;">);
   }

   </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">remStack.isEmpty()) {
       binaryString </span>+=<span style="color: #000000;"> remStack.pop().toString();
   }

   </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> binaryString;
}

console.log(divideBy2(</span>233)); <span style="color: #008000;">//</span><span style="color: #008000;"> 11101001</span>
console.log(divideBy2(10)); <span style="color: #008000;">//</span><span style="color: #008000;"> 1010</span>
console.log(divideBy2(1000)); <span style="color: #008000;">//</span><span style="color: #008000;"> 1111101000</span></pre>
</div>
<p>　　Stack类可以自行引用本文前面定义的任意一个版本。我们将这个函数再进一步抽象一下，使之可以实现任意进制之间的转换。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> baseConverter(decNumber, base) {
    let remStack </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stack();
    let rem, baseString </span>= ''<span style="color: #000000;">;
    let digits </span>= '0123456789ABCDEF'<span style="color: #000000;">;

    </span><span style="color: #0000ff;">while</span>(decNumber &gt; 0<span style="color: #000000;">) {
        rem </span>= Math.floor(decNumber %<span style="color: #000000;"> base);
        remStack.push(rem);
        decNumber </span>= Math.floor(decNumber /<span style="color: #000000;"> base);
    }

    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">remStack.isEmpty()) {
        baseString </span>+=<span style="color: #000000;"> digits[remStack.pop()];
    }

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> baseString;
}

console.log(baseConverter(</span>233, 2)); <span style="color: #008000;">//</span><span style="color: #008000;"> 11101001</span>
console.log(baseConverter(10, 2)); <span style="color: #008000;">//</span><span style="color: #008000;"> 1010</span>
console.log(baseConverter(1000, 2)); <span style="color: #008000;">//</span><span style="color: #008000;"> 1111101000</span>
<span style="color: #000000;">
console.log(baseConverter(</span>233, 8)); <span style="color: #008000;">//</span><span style="color: #008000;"> 351</span>
console.log(baseConverter(10, 8)); <span style="color: #008000;">//</span><span style="color: #008000;"> 12</span>
console.log(baseConverter(1000, 8)); <span style="color: #008000;">//</span><span style="color: #008000;"> 1750</span>
<span style="color: #000000;">
console.log(baseConverter(</span>233, 16)); <span style="color: #008000;">//</span><span style="color: #008000;"> E9</span>
console.log(baseConverter(10, 16)); <span style="color: #008000;">//</span><span style="color: #008000;"> A</span>
console.log(baseConverter(1000, 16)); <span style="color: #008000;">//</span><span style="color: #008000;"> 3E8</span></pre>
</div>
<p>　　我们定义了一个变量digits，用来存储各进制转换时每一步的余数所代表的符号。如：二进制转换时余数为0，对应的符号为digits[0]，即0；八进制转换时余数为7，对应的符号为digits[7]，即7；十六进制转换时余数为11，对应的符号为digits[11]，即B。</p>
<h3>汉诺塔</h3>
<p>　　有关汉诺塔的传说和由来，读者可以自行百度。这里有两个和汉诺塔相似的小故事，可以跟大家分享一下。</p>
<p>　　1. 有一个古老的传说，印度的舍罕王（Shirham）打算重赏国际象棋的发明人和进贡者，宰相西萨&middot;班&middot;达依尔（Sissa Ben Dahir）。这位聪明的大臣的胃口看来并不大，他跪在国王面前说：&ldquo;陛下，请您在这张棋盘的第一个小格内，赏给我一粒小麦；在第二个小格内给两粒，第三格内给四粒，照这样下去，每一小格内都比前一小格加一倍。陛下啊，把这样摆满棋盘上所有64格的麦粒，都赏给您的仆人吧！&rdquo;。&ldquo;爱卿。你所求的并不多啊。&rdquo;国王说道，心里为自己对这样一件奇妙的发明所许下的慷慨赏诺不致破费太多而暗喜。&ldquo;你当然会如愿以偿的。&rdquo;说着，他令人把一袋麦子拿到宝座前。计数麦粒的工作开始了。第一格内放一粒，第二格内放两粒，第三格内放四粒，......还没到第二十格，袋子已经空了。一袋又一袋的麦子被扛到国王面前来。但是，麦粒数一格接以各地增长得那样迅速，很快就可以看出，即便拿来全印度的粮食，国王也兑现不了他对西萨&middot;班&middot;达依尔许下的诺言了，因为这需要有18 446 744 073 709 551 615颗麦粒呀！</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/JavaScript数据结构——栈的实现与应用0.png" alt="" /></p>
<p>　　这个故事其实是一个数学级数问题，这位聪明的宰相所要求的麦粒数可以写成数学式子：1 + 2 + 2<sup>2</sup> + 2<sup>3</sup> + 2<sup>4</sup> +&nbsp;...... 2<sup>62</sup> + 2<sup>63&nbsp;</sup></p>
<p>　　推算出来就是：</p>
<p>　　<img src="./images/JavaScript数据结构——栈的实现与应用1.png" alt="" /></p>
<p>　　其计算结果就是18 446 744 073 709 551 615，这是一个相当大的数！如果按照这位宰相的要求，需要全世界在2000年内所生产的全部小麦才能满足。</p>
<p>　　2. 另外一个故事也是出自印度。在世界中心贝拿勒斯的圣庙里，安放着一个黄铜板，板上插着三根宝石针。每根针高约1腕尺，像韭菜叶那样粗细。梵天在创造世界的时候，在其中的一根针上从下到上放下了由大到小的64片金片。这就是所谓的梵塔。不论白天黑夜，都有一个值班的僧侣按照梵天不渝的法则，把这些金片在三根针上移来移去：一次只能移一片，并且要求不管在哪一根针上，小片永远在大片的上面。当所有64片都从梵天创造世界时所放的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，梵塔、庙宇和众生都将同归于尽。这其实就是我们要说的汉诺塔问题，和第一个故事一样，要把这座梵塔全部64片金片都移到另一根针上，所需要的时间按照数学级数公式计算出来：1 + 2 + 2<sup>2</sup> + 2<sup>3</sup> + 2<sup>4</sup> + ...... 2<sup>62</sup> + 2<sup>63</sup> = 2<sup>64</sup> - 1 = 18 446 744 073 709 551 615</p>
<p>　　一年有31 558 000秒，假如僧侣们每一秒钟移动一次，日夜不停，节假日照常干，也需要将近5800亿年才能完成！</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/JavaScript数据结构——栈的实现与应用2.png" alt="" /></p>
<p>　　好了，现在让我们来试着实现汉诺塔的算法。</p>
<p>　　为了说明汉诺塔中每一个小块的移动过程，我们先考虑简单一点的情况。假设汉诺塔只有三层，借用百度百科的图，移动过程如下：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/JavaScript数据结构——栈的实现与应用3.png" alt="" /></p>
<p>　　一共需要七步。我们用代码描述如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> hanoi(plates, source, helper, dest, moves =<span style="color: #000000;"> []) {
    </span><span style="color: #0000ff;">if</span> (plates &lt;= 0<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> moves;
    }
    </span><span style="color: #0000ff;">if</span> (plates === 1<span style="color: #000000;">) {
        moves.push([source, dest]);
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        hanoi(plates </span>- 1<span style="color: #000000;">, source, dest, helper, moves);
        moves.push([source, dest]);
        hanoi(plates </span>- 1<span style="color: #000000;">, helper, source, dest, moves);
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> moves;
}</span></pre>
</div>
<p>　　下面是执行结果：</p>
<div class="cnblogs_code">
<pre><code>console.log(hanoi(3, 'source', 'helper', 'dest'));</pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">[
  [ </span><span style="color: #800000;">'</span><span style="color: #800000;">source</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">dest</span><span style="color: #800000;">'</span><span style="color: #000000;"> ],
  [ </span><span style="color: #800000;">'</span><span style="color: #800000;">source</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">helper</span><span style="color: #800000;">'</span><span style="color: #000000;"> ],
  [ </span><span style="color: #800000;">'</span><span style="color: #800000;">dest</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">helper</span><span style="color: #800000;">'</span><span style="color: #000000;"> ],
  [ </span><span style="color: #800000;">'</span><span style="color: #800000;">source</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">dest</span><span style="color: #800000;">'</span><span style="color: #000000;"> ],
  [ </span><span style="color: #800000;">'</span><span style="color: #800000;">helper</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">source</span><span style="color: #800000;">'</span><span style="color: #000000;"> ],
  [ </span><span style="color: #800000;">'</span><span style="color: #800000;">helper</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">dest</span><span style="color: #800000;">'</span><span style="color: #000000;"> ],
  [ </span><span style="color: #800000;">'</span><span style="color: #800000;">source</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">dest</span><span style="color: #800000;">'</span><span style="color: #000000;"> ]
]</span></pre>
</div>
<p>　　可以试着将3改成大一点的数，例如14，你将会得到如下图一样的结果：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/JavaScript数据结构——栈的实现与应用4.png" alt="" width="571" height="608" /></p>
<p>　　如果我们将数改成64呢？就像上面第二个故事里所描述的一样。恐怕要令你失望了！这时候你会发现你的程序无法正确返回结果，甚至会由于超出递归调用的嵌套次数而报错。这是由于移动64层的汉诺塔所需要的步骤是一个很大的数字，我们在前面的故事中已经描述过了。如果真要实现这个过程，这个小程序恐怕很难做到了。</p>
<p>　　搞清楚了汉诺塔的移动过程，我们可以将上面的代码进行扩充，把我们在前面定义的栈的数据结构应用进来，完整的代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> towerOfHanoi(plates, source, helper, dest, sourceName, helperName, destName, moves =<span style="color: #000000;"> []) {
    </span><span style="color: #0000ff;">if</span> (plates &lt;= 0<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> moves;
    }
    </span><span style="color: #0000ff;">if</span> (plates === 1<span style="color: #000000;">) {
        dest.push(source.pop());
        const move </span>=<span style="color: #000000;"> {};
        move[sourceName] </span>=<span style="color: #000000;"> source.toString();
        move[helperName] </span>=<span style="color: #000000;"> helper.toString();
        move[destName] </span>=<span style="color: #000000;"> dest.toString();
        moves.push(move);
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        towerOfHanoi(plates </span>- 1<span style="color: #000000;">, source, dest, helper, sourceName, destName, helperName, moves);
        dest.push(source.pop());
        const move </span>=<span style="color: #000000;"> {};
        move[sourceName] </span>=<span style="color: #000000;"> source.toString();
        move[helperName] </span>=<span style="color: #000000;"> helper.toString();
        move[destName] </span>=<span style="color: #000000;"> dest.toString();
        moves.push(move);
        towerOfHanoi(plates </span>- 1<span style="color: #000000;">, helper, source, dest, helperName, sourceName, destName, moves);
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> moves;
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> hanoiStack(plates) {
    const source </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stack();
    const dest </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stack();
    const helper </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stack();

    </span><span style="color: #0000ff;">for</span> (let i = plates; i &gt; 0; i--<span style="color: #000000;">) {
        source.push(i);
    }

    </span><span style="color: #0000ff;">return</span> towerOfHanoi(plates, source, helper, dest, 'source', 'helper', 'dest'<span style="color: #000000;">);
}</span></pre>
</div>
<p>　　我们定义了三个栈，用来表示汉诺塔中的三个针塔，然后按照函数hanoi()中相同的逻辑来移动这三个栈中的元素。当plates的数量为3时，执行结果如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">[
  {
    source: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    helper: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    dest: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">
  },
  {
    source: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    dest: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    helper: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">
  },
  {
    dest: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    source: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    helper: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">
  },
  {
    source: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    helper: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    dest: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">
  },
  {
    helper: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    dest: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    source: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">
  },
  {
    helper: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    source: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    dest: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">
  },
  {
    source: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    helper: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">,
    dest: </span><span style="color: #800000;">'</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">'</span><span style="color: #000000;">
  }
]</span></pre>
</div>
<p>&nbsp;　　栈的应用在实际编程中非常普遍，下一章我们来看看另一种数据结构：队列。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>