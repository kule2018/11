<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaScript的__proto__、prototype和继承' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaScript的__proto__、prototype和继承</center></div><div class='banquan'>原文出处:本文由博客园博主半天想不出昵称的斌提供。<br/>
原文连接:https://www.cnblogs.com/top-housekeeper/p/11394866.html</div><br>
    <p>JavaScript也是可以&ldquo;继承&rdquo;的！</p>
<p>各位看官或是好奇，或是一知半解。<strong>什么是prototype，__proto__，constructor、哪种继承方式好</strong>。今天就在这交流交流。</p>
<hr />
<h1><strong>什么是prototype，__proto__，constructor</strong></h1>
<p><a href="https://blog.csdn.net/cc18868876837/article/details/81211729" target="_blank">https://blog.csdn.net/cc18868876837/article/details/81211729</a>&nbsp;（<span style="text-decoration: underline;"><span style="color: #ff0000; text-decoration: underline;">尊重原作者，这是篇超级好的文章，一定要点进去细细研读</span></span>）</p>
<p>上面文章已经讲的很明白了，最后对文章总结再解释一下</p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/JavaScript的__proto__、prototype和继承0.png" alt="" /></p>
<p>第一点主要强调，我们拿到一个对象，主要看它什么，因为JavaScript中一切都是对象，所以在理解的时候很容易因为它有其他变量也混淆，所以我们研究一个对象，首先要确定我们的目标是什么，如果目标是对象，则抓住__proto__和constructor属性，如果目标是函数则抓住prototype属性，这样才能快速找到自己想要的东西解决问题。</p>
<p>第2,3,4点是关于哪种继承方式好的关键，一定要弄懂，下面再解释一下new关键词做了什么（没准你不懂上面文章写的，看懂我的例子）。</p>
<hr />
<p>&nbsp;</p>
<h1>new关键词做了什么</h1>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #008000;">//</span><span style="color: #008000;">例如</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">var</span> child = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Parent();
</span><span style="color: #008080;">3</span> 
<span style="color: #008080;">4</span> <span style="color: #008000;">//</span><span style="color: #008000;">上面这句代码就等于下面三句</span>
<span style="color: #008080;">5</span> <span style="color: #0000ff;">var</span> child =<span style="color: #000000;"> {};
</span><span style="color: #008080;">6</span> child.__proto__ =<span style="color: #000000;"> Parent.prototype;
</span><span style="color: #008080;">7</span> Parent.call(child);</pre>
</div>
<p>咳咳，就跟教育孩子一样，孩子出生是张白纸（var child = {}），然后<strong>继承</strong>了父母的一些行为（就是方法），例如怎么说话啊，喜欢吃什么啊（child.__proto__ = Parent.prototype;），最后得到父母的一些人生经验，就是复制了属性变量（Parent.call(child)）。</p>
<p>这里需要注意，孩子是不能生孩子的，即</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> child2 = <span style="color: #0000ff;">new</span> child()</pre>
</div>
<p>绝对报错的，对象是对象，并不是函数，也不会变成函数。</p>
<hr />
<h1>&nbsp;<strong>哪种继承方式好</strong></h1>
<p>继承能够代码复用，能让逻辑更清晰，所以是很有必要的，那怎么样继承效果最好呢</p>
<p><a href="https://www.cnblogs.com/humin/p/4556820.html#" target="_blank">https://www.cnblogs.com/humin/p/4556820.html#</a>（<span style="text-decoration: underline; color: #ff0000;">尊重原作者，这是篇超级好的文章，一定要点进去细细研读</span>，这话好像有点熟悉）</p>
<p>推荐给大家一个方法，打开谷歌浏览器，按F12，在里面可以进行简单的练习</p>
<p><img src="./images/JavaScript的__proto__、prototype和继承1.png" alt="" /></p>
<p>文章最好从第一个继承开始，就自己动手模拟一下，看看变量的__proto__和prototype到底指什么</p>
<p>而且从第一个继承方法演变到最完美的一个，这个思考过程是十分重要的。</p>
<p>我来再解释一下最完美的继承模式：<strong>寄生组合继承</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> Cat(name){
</span><span style="color: #008080;"> 2</span>   Animal.call(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 3</span>   <span style="color: #0000ff;">this</span>.name = name || 'Tom'<span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 5</span> (<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;"> 6</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> 创建一个没有实例方法的类</span>
<span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">var</span> Super = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){};
</span><span style="color: #008080;"> 8</span>   Super.prototype =<span style="color: #000000;"> Animal.prototype;
</span><span style="color: #008080;"> 9</span>   <span style="color: #008000;">//</span><span style="color: #008000;">将实例作为子类的原型</span>
<span style="color: #008080;">10</span>   Cat.prototype = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Super();
</span><span style="color: #008080;">11</span> <span style="color: #000000;">})();
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #008000;">//</span><span style="color: #008000;"> Test Code</span>
<span style="color: #008080;">14</span> <span style="color: #0000ff;">var</span> cat = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
</span><span style="color: #008080;">15</span> <span style="color: #000000;">console.log(cat.name);
</span><span style="color: #008080;">16</span> <span style="color: #000000;">console.log(cat.sleep());
</span><span style="color: #008080;">17</span> console.log(cat <span style="color: #0000ff;">instanceof</span> Animal); <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;">18</span> console.log(cat <span style="color: #0000ff;">instanceof</span> Cat); <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">19</span> 
<span style="color: #008080;">20</span> <span style="color: #000000;">感谢 @bluedrink 提醒，该实现没有修复constructor。
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span> Cat.prototype.constructor = Cat; <span style="color: #008000;">//</span><span style="color: #008000;"> 需要修复下构造函数</span></pre>
</div>
<p>第7-10行的代码为什么这样做</p>
<p><span style="color: #ff0000;">通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点&nbsp;<span style="color: #000000;">这句话什么意思</span></span></p>
<p><span style="color: #ff0000;"><span style="color: #000000;">回到刚才对new的解释，假设如组合5：组合继承一样</span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> Cat(name){
</span><span style="color: #008080;">2</span>   Animal.call(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">3</span>   <span style="color: #0000ff;">this</span>.name = name || 'Tom'<span style="color: #000000;">;
</span><span style="color: #008080;">4</span> <span style="color: #000000;">}
</span><span style="color: #008080;">5</span> Cat.prototype = <span style="color: #0000ff;">new</span> Animal();<br /><br />第5行代码相当于：<br />Cat.prototype = {} <br />Cat.prototype.__proto__ = Animal.prototype    <br />Animal.call(Cat.prototype)                    //这一步是多余的并不需要<br /><br />所以 var Super = function(){};  一个空方法来代替，因为只需要<br /><br />Cat.prototype.__proto__ = Animal.prototype 就可以了</pre>
<pre><code>而现在Super.prototype = Animal.prototype 因此这个方法是最完美的</pre>
</div>
<p>&nbsp;</p>
<p>以上就是本次内容的分享，感谢各位老哥的阅读</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>