<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaScript的array方法' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaScript的array方法</center></div><div class='banquan'>原文出处:本文由博客园博主哇卡卡卡卡提供。<br/>
原文连接:https://www.cnblogs.com/heihaquyu/p/12102282.html</div><br>
    <h1 id="javascript高级函数"><strong>JavaScript高级函数</strong></h1>
<h2 id="mapreduce">1.map/reduce</h2>
<h3 id="map">map()</h3>
<p>map()是array的一个方法</p>
<p>作用: 对array中每一个元素调用自定义函数</p>
<pre><code><code>&#39;use strict&#39;;
function pow(x){
return x*x;
}
var arr=[1,2,3,4,5]
var newarray=arr.map(pow)</code></pre>
<p>map的回调函数有三个参数:</p>
<p><strong>callback(currentValue, index, array)</strong>通常只要第一个参数</p>
<p>PS: map()传入的参数是pow,即函数对象本身</p>
<p>通常map调用的自定义方法只包含一个参数</p>
<h3 id="reduce">reduce()</h3>
<p>reduce()也是array的一个方法</p>
<p>作用: 从数组的前两个元素开始,作为函数参数,传入函数得到结果,</p>
<p>结果再和下一个数组元素再一次调用函数,直到数组尽头</p>
<pre><code><code>[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</code></pre>
<p>PS: 通常reduce()调用的自定义方法只包含两个个参数</p>
<h2 id="filter筛选">2.filter(筛选)</h2>
<p>作用:把<code>Array</code>的某些元素过滤掉,然后返回剩下的元素.</p>
<p>和<code>map()</code>类似，<code>Array</code>的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>//去掉空字符串</p>
<pre><code><code>var arr = [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, null, undefined, &#39;C&#39;, &#39;  &#39;];
var r = arr.filter(function (s) {
    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre>
<h3 id="回调函数">回调函数</h3>
<p>通常我们仅使用第一个参数，表示<code>Array</code>的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身:</p>
<pre><code><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
var r = arr.filter(function (element, index, self) {
    console.log(element); // 依次打印&#39;A&#39;, &#39;B&#39;, &#39;C&#39;
    console.log(index); // 依次打印0, 1, 2
    console.log(self); // self就是变量arr
    return true;
});</code></pre>
<p>筛选素数:</p>
<pre><code><code>function get_primes(arr){
if(elem===1){
return false;
}
for(var i=2;i&lt;=elem/2;i++){
if(elem%i==0)
{
return false;
}
}
return true;
});
return x;
}</code></pre>
<p>PS: 关键在于正确实现一个“筛选”函数</p>
<h2 id="sort排序">3.sort(排序)</h2>
<p>默认排序会把所有元素转成String在排序,根据一个元素的ASCII值进行排序(非递减)(TimSort算法)</p>
<p>两两比较,当回调函数返回值大于0时,交换元素值</p>
<p>自定义数字排序</p>
<pre><code><code>&#39;use strict&#39; 
var arr=[10,20,1,2];

arr.sort(function(x,y){
    if (x &lt; y) {
        return -1;
    }
    if (x &gt; y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]</code></pre>
<p>数字倒序排列</p>
<pre><code><code>var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x &lt; y) {
        return 1;
    }
    if (x &gt; y) {
        return -1;
    }
    return 0;
}); // [20, 10, 2, 1]</code></pre>
<h2 id="其他的array方法">4.其他的Array方法</h2>
<h3 id="every和some">every()和some()</h3>
<p>作用: 可以判断数组的所有元素是否满足测试条件(通过函数提供)</p>
<ul>
<li><p>every()是全部满足的时候返回true,一个不满足返回false,并终止检测</p></li>
<li><p>some()是全部不满足的时候返回false,有一个满足就返回true</p></li>
</ul>
<h3 id="find">find()</h3>
<p>作用: 查找第一个符合条件的元素</p>
<p>查找符合条件的第一个元素,如果找到了就返回这个元素,否则,返回undefined</p>
<h3 id="findindex">findindex()</h3>
<p>作用: 查找第一个符合条件的元素的索引</p>
<p>查找符合条件的第一个元素,找到这个元素就返回他的索引,如果没有找到就返回-1</p>
<h3 id="foreach">forEach()</h3>
<p>作用: 常用于遍历数组</p>
<p>(和map类似)把数组每个元素依次传入函数,但不会返回新的数组.</p>
<h3 id="函数作为返回值">函数作为返回值</h3>
<p>函数里再定义一个函数,返回值为里面定义的函数</p>
<p>调用函数作为返回值的函数式,每次调用都会返回一个新的函数,即使传入相同参数</p>
<pre><code><code>function lazy_sum(arr) {
    var sum = function () {
        return arr.reduce(function (x, y) {
            return x + y;
        });
    }
    return sum;
}
//此时返回的是求和函数
var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()
f(); // 15 此时调用,才进行计算</code></pre>
<p>在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力.</p>
<h3 id="闭包懵逼了吐彩虹">闭包(懵逼了)(吐彩虹)</h3>
<p>有权访问另一个函数作用域内变量的函数都是闭包。</p>
<p>函数里面的函数会随着外部定义函数而改变</p>
<p>PS: ==因为返回值就是一个函数,调用的时候要加小括号==</p>
<p><strong>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<h3 id="箭头函数强哒">箭头函数(=&gt;)(==强哒==)</h3>
<p>(参数...)=&gt;{函数体}等价于function(参数...){函数体}</p>
<p>当返回的是一个对象时函数体大括号外边加小括号</p>
<p>x=&gt;({foo:x})</p>
<h4 id="this">this</h4>
<p>箭头函数内部的this是词法作用域,由上下文确定</p>
<pre><code><code>var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25</code></pre>
<p>箭头函数完全修复了this指向,this总是指向词法作用域,也就是外层调用 obj</p>
<h3 id="generator生成器">generator(生成器)</h3>
<p><strong>ES6引入借鉴Python同名函数</strong></p>
<p>写法和函数类似,只是在function后加*,通过yield多次返回值,也可通过return返回值</p>
<p>函数在执行过程中，如果没有遇到<code>return</code>语句（函数末尾如果没有<code>return</code>，就是隐含的<code>return undefined;</code>），控制权无法交回被调用的代码。</p>
<p>function* (x){</p>
<p>yield x</p>
<p>}</p>
<pre><code><code>function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n &lt; max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}
fib(5); // fib {[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window}</code></pre>
<p>直接调用一个generator和调用函数不一样，<code>fib(5)</code>仅仅是创建了一个generator对象，还没有去执行它。</p>
<p>调用generator对象有两个方法，</p>
<ol>
<li><p>一是不断地调用generator对象的<code>next()</code>方法：next()<code>方法会执行generator的代码，然后，每次遇到</code>yield x;<code>就返回一个对象</code>{value: x, done: true/false}<code>，然后“暂停”。返回的</code>value<code>就是</code>yield<code>的返回值，</code>done<code>表示这个generator是否已经执行结束了。如果</code>done<code>为</code>true<code>，则</code>value<code>就是</code>return<code>的返回值。当执行到</code>done<code>为</code>true<code>时，这个generator对象就已经全部执行完毕，不要再继续调用</code>next()`了。</p>
<pre><code><code>var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}</code></pre></li>
<li><p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：</p></li>
</ol>
<pre><code><code>for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
</code></pre>
<p>generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。</p>
<pre><code><code>try {
    r1 = yield ajax(&#39;http://url-1&#39;, data1);
    r2 = yield ajax(&#39;http://url-2&#39;, data2);
    r3 = yield ajax(&#39;http://url-3&#39;, data3);
    success(r3);
}
catch (err) {
    handle(err);
}</code></pre>
<p>看上去是同步的代码，实际执行是异步的。</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>