<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaScript篇   深入理解JavaScript函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaScript篇   深入理解JavaScript函数</center></div><div class='banquan'>原文出处:本文由博客园博主MokeyCode提供。<br/>
原文连接:https://www.cnblogs.com/mokeycode/p/10700805.html</div><br>
    <h2>JavaScript中的函数</h2>
<h3>1. 函数的定义</h3>
<ul>
<li>两种定义形式:<span class="Apple-converted-space"><span class="Apple-converted-space">&nbsp;</span></span>
<ul>
<li>通过<strong>函数定义表达式</strong>来定义<span class="Apple-converted-space">&nbsp;</span></li>
</ul>
<ul>
<li>通过<strong>函数声明语句</strong>来定义</li>
</ul>
</li>
</ul>
<p>函数声明语句定义一个函数</p>
<pre><code><code>//计算阶乘的递归函数

function factorial(x){
    if (x&lt;=1) return 1;
    return x*factotial(x-1);
}
</code></pre>
<p>函数定义表达式定义一个函数</p>
<pre><code><code>var s= function sum(x,y){
    return x+y;
}

</code></pre>
<p>tips:以表达式方式定义的函数(特别适合用来定义那些只会用到一次的函数)，函数名是可选的，<br />也就可以直接写成这样</p>
<pre><code><code>var s= function(x,y){
    return x+y;
}
</code></pre>
<h3>2.函数命名</h3>
<ul>
<li>函数的名称通常是动词或者以动词为前缀的词组 如：funciton saveMessage(){}</li>
<li>函数名的第一个字符通常为小写</li>
<li>当我们命名的函数名比较长时，一种是驼峰式命名 如：function readSystemFile(){}<br />另一种是以下划线分割单词，如：function make_products_iPhones(){}</li>
<li>有一些函数是用作内部函数或者私有函数的，通常以一条下划线为前缀。 如： _login()</li>


</ul>
<h3>3.函数的调用</h3>
<ul>
<li>普通的函数调用</li>


</ul>
<blockquote>
<p>example:</p>


</blockquote>
<pre><code><code>printprops({x:1})
var total = distance(0,1,2)+ distance(3,4,5)
var probability = factorial(5)/factoral(10)
</code></pre>
<ul>
<li>对象方法的调用</li>
</ul>
<blockquote>
<p>概念：如果函数表达式是一个属性访问表达式（即该函数是一个对象的属性或者数组的一个函数），<br />那么该调用表达式就是一个方法调用表用表达式。<br />example:</p>


</blockquote>
<pre><code><code class="language-">//定义一个对象
    var person = {  
    name: lihua ,  
    age:  18 ,  
    sex:  女 ，  
    send: function(){//返回 person的name、age、sex
            this.message = this.name + this.age + this.age;
        } 
    };
    person.send();//这条语句就是函数的方法调用
    person.message; //得到name、age、sex相关信息
</code></pre>
<blockquote>
<p><strong>tips:</strong><br />1.函数返回的值倘若是因为解释器到达结尾，返回值就是undefined；倘若函数返回是因为解释器执行到一条return语句，<br />则返回return语句后面的值；如果return语句后面没有值则返回undefined。<br />2.在<strong>ECMAScript3</strong>和在非严格模式下的<strong>ECMAScript5</strong>的函数调用规定中，<strong>this的值</strong>（调用上下文）的值是全局对象，但是在<br /><strong>严格模式</strong>下this的值却是undefined,因此可也用this来判断当前环境是否为严格模式，此外<strong>ECMAScript2015</strong><span class="Apple-converted-space">&nbsp;(简称es6)严格模式请参考以下地址。<br />ECMAScipt的第六个版本&nbsp;&nbsp;<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a><br />3.方法调用和普通的函数调用的一个重要区别就是：调用上下文（即this的值），通常this关键字指向成为<strong>调用上下文</strong>的对象，<br />属性访问表达式：对象名.方法名（通常使用.运算符访问属性）或者"[]"进行属性访问操作。(this关键字的相关内容是十分重要的)<br /><a href="&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this&quot;">更多this相关内容请参看此链接</a></span></p>


</blockquote>
<ul>
<li>构造函数的调用<span class="Apple-converted-space">&nbsp;</span></li>


</ul>
<p>构造函数就是用来初始化先创建的对象，通常使用关键字<strong>new</strong>来调用构造函数，当使用<strong>new</strong>关键字来调用构造函数的时候就会自动<br />创建一个新的的空对象，而构造函数只需要初始化这个新对象的状态(属性和方法)，调用构造函数的话，新的对象的原型(prototype)等于<br />构造函数的<strong>原型(prototype)属性</strong>,由此引出一个特性：通过同一个构造函数创建的所有对象都继承同一个相同的对象。</p>
<p>凡是没有形参的构造函数都可以省略圆括号，以下两行代码是等价的。<br />var fn = new Object();<br />var fn = new Object;</p>
<blockquote>
<p>tips：<br />1.构造函数通常不使用return关键字，进行初始化新对象，执行完函数体，就调用构造函数表达式的计算结果作为新对象的值，显示返回。<br />2.倘若构造函数使用return语句返回一个对象，那么调用表达式的值就是这个对象，而不是this指向的对象。<br />3.构造函数里没有显式调用return时，默认是返回this对象，也就是新创建的实例对象。<br />4.return的是五种简单数据类型：String，Number，Boolean，Null，Undefined。这种情况下，忽视return值，依然返回this对象</p>


</blockquote>
<ul>
<li>间接调用<br />JavaScript中的函数也是对象，所以函数对象也可以包含方法。函数的间接调用用到的call()和apply()方法。<br />这两个方法都能显示指定调用所需的<strong>this</strong>的值,这就引出一个特性：任何函数都可以作为对象的方法来调用，<br />哪怕这个函数不是那个对象的方法。(这也就是在实际开发中我们也会常用这两个方法的原因之一)<span class="Apple-converted-space">&nbsp;</span></li>


</ul>
<blockquote>
<p>1.call()方法调用一个函数, 其具有一个指定的this值和分别地提供的<strong>参数(参数的列表)</strong><span class="Apple-converted-space">&nbsp;this的值并不一定就是该函数执行真正的this值，在非严格模式下，倘若this的值指向<strong>null</strong>和<strong>undefined</strong>的话<br />会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。<br />2.apply()方法调用一个具有给定this值的函数，以及作为一个<strong>数组</strong>(或类似数组对象)提供的参数。<br />为this指定一个对象，使用apply时只需要写一次这个方法然后再另一个对象中继承它，继而不用在这个新的对象重新来写它。</span></p>


</blockquote>
<blockquote>
<p>tips:call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。</p>


</blockquote>
<h3>4.函数中的形参与实参</h3>
<ul>
<li>可选的形参</li>
<li>可变长的实参列表：实参对象 arguments 它是一个类数组对象，通过数字下表就能够访问传入函数的实参值，它包含length属性，让函数可以操作任意数量的实参。<span class="Apple-converted-space">&nbsp;</span></li>
<li>callee和caller属性<br />callee属性指代当前正在执行的函数，caller指代调用当前正在执行的函数的函数，它可以访问栈。而callee可以来递归调用自身。</li>


</ul>
<h3>5.函数的闭包（!important）</h3>
<ul>
<li>概念:通俗地讲函数的闭包就是在一个函数内部定义另一个函数，而这个内部的函数(子函数)可以调用包裹它的函数(父函数等、"爷爷、太爷爷...")的变量。<br />也可以认为闭包就是能够读取其他函数内部变量的函数。</li>
<li>变量作用域：<br />全局变量：任何函数内部都可以访问全局作用域<br />局部变量：在函数外部无法读取变量<span class="Apple-converted-space">&nbsp;</span></li>


</ul>
<blockquote>
<p>tips<br />javascript是没有像Java、C++那样用一对&ldquo;{}&rdquo;括起来的块级作用域，但是在es6中可以使用let关键字实现块级作用域。</p>


</blockquote>
<ul>
<li>词法作用域：变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。<br />with和eval除外，所以只能说JS的作用域机制非常接近词法作用域（Lexical scope）。</li>


</ul>
<pre><code><code class="language-">var scope = "global scope";  
function checkScope(){
    var scope = "local scope";
    function f(){return scope;}  
    return f();
}
checkScope();  //输出可以得到 local scope
</code></pre>
<ul>
<li>
<p>闭包的用途<br />i. 读取函数内部的变量、函数嵌套函数<br />ii. 让这些变量的值始终保持在内存中(全局变量的值不会在被函数调用过后自动清除，由GC回收)<br />iii. 避免全局变量的污染、让私有成员存在<span class="Apple-converted-space">&nbsp;</span></p>


</li>
<li>
<p>闭包的注意事项<br />i. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致<strong>内存泄露</strong>。<br />解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br />ii. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），<br />把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。<br />以下例子来检验自己是否已经掌握了闭包的运行机制。<br />example 0ne:</p>


</li>


</ul>
<pre><code><code>　　var name = "The Window";

　　var object = {
　　　　name : "My Object",

　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};

　　　　}

　　};

　　alert(object.getNameFunc()());
</code></pre>
<p>example Two:</p>
<pre><code><code>　　var name = "The Window";

　　var object = {
　　　　name : "My Object",

　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};

　　　　}

　　};

　　alert(object.getNameFunc()());
</code></pre>
<h3>6.函数的属性、方法以及构造函数</h3>
<ul>
<li>length属性<br />argument.length属性表示传入函数的实参的个数，而函数本身的length属性则有不同含义，它表示函数定义时的实际形参个数。</li>
<li>prototype（原型）属性<br />这个属性指向对象的引用，而这个对象就被称为<strong>原型对象</strong>(prototype object),每个函数都包含这个属性,都包含不同的原型对象；<br />在JavaScript中每个函数都有一个特殊的属性叫作<strong>原型（prototype）</strong></li>


</ul>
<pre><code><code>function doSomething(){}
console.log(doSomething.prototype);
-----------------------------------  
结果：  这就是 原型对象
{
 constructor: &fnof; doSomething(), //构造函数
  /* 这些又是这个构造函数里面的方法或者属性 
    arguments: null
    caller: null
    length: 0
    name: "doSomething"
    prototype: {constructor: &fnof;} 构造函数的原型属性
     __proto__: &fnof; ()*/

 __proto__: { //原型属性
     constructor: &fnof; Object(),
     hasOwnProperty: &fnof; hasOwnProperty(),
     isPrototypeOf: &fnof; isPrototypeOf(),
     propertyIsEnumerable: &fnof; propertyIsEnumerable(),
     toLocaleString: &fnof; toLocaleString(),
     toString: &fnof; toString(),
     valueOf: &fnof; valueOf()
    }
 }   
-------------------------------  
function doSomething(){}  
doSomething.prototype.eat = "food" //doSomething函数的原型(prototype)属性对象添加eat的属性
var doSomeInstancing  =new doSomething() //创建doSomething函数的实例  通过new关键字来调用该函数，它返回这个函数的实例化对象给doSomeInstancing  
doSomeInstancing.prop = "add value";  //给对象doSomeInstancing添加一个&ldquo;name为prop值为add value&rdquo;的属性
console.log(doSomeInstancing);   //输出这个doSomeIntancing对象 结果现实这个对象有两个属性，一个是：prop: "add value" 另一个是：__proto__: Object
console.log(doSomething.prototype); //输出doSomething.prototype的值是一个对象{eat: "food"，constructor: &fnof; doSomething(), __proto__: Object
显然doSomeInstancing.__proto__属性与doSomething.prototype(构造函数的原型属性的值是相同)它们的值是相等的。（可以通过===来判断 __ptototype__为隐式原型）

</code></pre>
<ul>
<li>call()、apply()和bind()方法 在前面的函数的间接调用中已经介绍了call()以及apply(),在这里就不再叙说，就详细介绍ECMAScript5新增的bind()方法<span class="Apple-converted-space">&nbsp;</span></li>
</ul>
<blockquote>
<p>bind()方法中的<strong>bind</strong>翻译过来就是<strong>捆绑、绑定</strong>之意,作用就是将函数绑定至某个对象中,倘若一个函数调用了bind()方法并传入一个对象作为参数，那么这个方法将返回新的函数。</p>
</blockquote>
<pre><code><code>function f(y){return this.x+y;} //待绑定的函数
var o = {x ：1}；//将要被绑定的对象
var g = f.bind(o); //将函数f绑定至对象o  相当于var o={x:1, f:function f(y){return this.x+y;}}
console.log(g(2));  //通过g(y)调用o.f(y) 输出3
</code></pre>
<blockquote>
<p>bind()方法除了除了第一个实参之外，传入bind()的实参也会绑定至this.这种应用是一种常见的函数式编程技术，被称为<strong>柯里化(currying)</strong></p>
</blockquote>
<pre><code><code>var sum = function(x,y){return x+y;}  
var succ = sum.bind(null,1);
succ(2)
</code></pre>
<ul>
<ul>
<li>toString()方法<br />该方法返回字符串</li>
<li>Function()构造函数</li>
<li>高阶函数
<ul>
<li>记忆(memorization)</li>


</ul>


</li>


</ul>

</ul>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>