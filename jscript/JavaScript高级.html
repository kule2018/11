<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaScript高级' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaScript高级</center></div><div class='banquan'>原文出处:本文由博客园博主我是个高手提供。<br/>
原文连接:https://www.cnblogs.com/wsuyi/p/11443551.html</div><br>
    <div>
<div class="cnblogs_code" onclick="cnblogs_code_show('85d0b4b3-f82f-4f4a-9e48-6354afafaf8e')">&nbsp;</div>
<p>&nbsp;</p>
<h2><strong>1.面向过程与面向对象</strong></h2>
</div>
<div>
<div>　1.1面向过程</div>
<div>　　面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</div>
<div>　　面向过程是 实现代码逻辑的 步骤，主要是把重心点放在实现功能上，不太去考虑封装</div>
<div>　　优点： 效率高，但是维护起来太麻烦　　</div>
<div>　 1.2面向对象</div>
<div>　　面向对象是把事务分解成一个个对象，然后由对象之间分工合作。</div>
<div>　　主要的重心点，先放在功能模块的划分，然后想着什么功能模块可以去进行复用（可以进行抽取）</div>
<div>　　优点： 会让我们功能具备模块化开发，一个模块就负责一个功能，后续方便我们的维护</div>
<div>　　<span style="background-color: #ff6600;">三大特性：继承性、封装性、多态性（抽象性）</span></div>
<div>&nbsp;</div>
<h2><span style="background-color: #ff6600;"><strong><span style="background-color: #ffffff;">2.对象与类</span></strong><br /></span></h2>
<div><span style="background-color: #ff6600;"><strong><span style="background-color: #ffffff;">　 </span></strong><span style="background-color: #ffffff;">2.1 对象</span></span><span style="background-color: #ff6600;"><span style="background-color: #ff6600;"><span style="background-color: #ffffff;">　</span></span></span></div>
<div>
<div>　　对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物</div>
<div>　　属性：事物的特征，在对象中用属性来表示（常用名词）</div>
<div>　　方法：事物的行为，在对象中用方法来表示（常用动词）</div>





















</div>
<div>　　创建对象的两种方法</div>
<div>　　　　1.字面量创建对象　　　　</div>
<div>
<div>　　　　　　var ldh = {</div>
<div>　　　　　　name: '刘德华',</div>
<div>　　　　　　age: 18</div>
<div>　　　　　　}</div>
<div>　　　　　　console.log(ldh);</div>





















</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>　　　　2.构造函数创建对象</div>
<div>　　　　　　function Star(uname,age){<br />　　　　　　　　this.uname = name;</div>
<div>　　　　　　　　this.age = age;</div>
<div>　　　　　　}</div>
<div>　　　　　　var ldh = new Star('刘德华'，18)； //实例化对象</div>
<div>　　　　　　console.log(ldh);</div>
<div>　2.2 类　</div>
<div>
<div>　　在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实</div>
<div>　　例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，</div>
<div>　　通过类实例化一个具体的对象</div>
<div>　　&nbsp;</div>
<div>　　2.2.1创建类</div>
<div>　　 &nbsp; 语法：　　</div>
<div>
<div>　　　 &nbsp;&nbsp; //步骤1 使用class关键字</div>
<div>　　　　class name {</div>
<div>　　　　// class body</div>
<div>　　　　}</div>
<div>　　　　//步骤2使用定义的类创建实例 注意new关键字</div>
<div>　　　　var xx = new name();</div>
<div>　　2.2.2类创建添加属性和方法　　</div>
<div>
<div>　　　　// 1. 创建类 class 创建一个类</div>
<div>　　　　class Star {</div>
<div>　　　　　　// 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数</div>
<div>　　　　　　constructor(uname, age) {</div>
<div>　　　　　　this.uname = uname;</div>
<div>　　　　　　this.age = age;</div>
<div>　　　　　　}//‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;注意,方法与方法之间不需要添加逗号</div>
<div>　　　　　　sing(song) {</div>
<div>　　　　　　console.log(this.uname + '唱' + song);</div>
<div>　　　　　　}</div>
<div>　　　　}</div>
<div>　　// 2. 利用类创建对象 new 实例化</div>
<div>　　var ldh = new Star('刘德华', 18);</div>
<div>　　console.log(ldh); &nbsp; // Star {uname: "刘德华", age: 18}</div>
<div>　　ldh.sing('冰雨'); &nbsp; &nbsp; // 刘德华唱冰雨</div>





















</div>
<div>&nbsp;</div>





















</div>
<div>
<div>　　<span style="background-color: #ff6600;">注意点：</span></div>
<div><span style="background-color: #ff6600;">　　　　1. 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</span></div>
<div><span style="background-color: #ff6600;">　　　　2. 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</span></div>
<div><span style="background-color: #ff6600;">　　　　3. constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</span></div>
<div><span style="background-color: #ff6600;">　　　　4. 多个函数方法之间不需要添加逗号分隔</span></div>
<div><span style="background-color: #ff6600;">　　　　5. 生成实例 new 不能省略</span></div>
<div><span style="background-color: #ff6600;">　　　　6. 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</span></div>
<div>&nbsp;</div>
<div><span style="background-color: #ffffff;">　2.2.3 类的继承</span></div>
<div><span style="background-color: #ffffff;">　　语法 ： &nbsp; class Father { }; // 父类</span></div>
<div><span style="background-color: #ffffff;">　　　　　　class Son extends Father { } // 子类继承父类 extends</span></div>
<div><span style="background-color: #ffffff;"><span style="background-color: #ffffff;">　　示例 ： &nbsp;&nbsp;</span></span>
<div>　　　　　　class Father {</div>
<div>　　　　　　　　constructor(surname) {</div>
<div>　　　　　　　　this.surname= surname;</div>
<div>　　　　　　　　}</div>
<div>　　　　　　　　say() {</div>
<div>　　　　　　　　　　console.log('你的姓是' + this.surname);</div>
<div>　　　　　　　　}</div>
<div>　　　　　　}</div>
<div>　　　　　　class Son extends Father{ &nbsp; &nbsp; // 这样子类就继承了父类的属性和方法</div>
<div>　　　　　　}</div>
<div>　　　　　　var damao= new Son('刘');</div>
<div>　　　　　　damao.say(); // 输出结果是 &nbsp; 你的姓是刘</div>
<div>　　
<div>　　子类使用super关键字访问父类的方法</div>
<div>　　　
<div>　　　　//定义了父类</div>
<div>　　　　class Father {</div>
<div>　　　　　　constructor(x, y) {</div>
<div>　　　　　　this.x = x;</div>
<div>　　　　　　this.y = y;</div>
<div>　　　　　　}</div>
<div>　　　　　　sum() {</div>
<div>　　　　　　　　console.log(this.x + this.y);</div>
<div>　　　　　　}</div>
<div>　　　　}</div>
<div>　　　　//子元素继承父类</div>
<div>　　　　class Son extends Father {</div>
<div>　　　　　　constructor(x, y) {</div>
<div>　　　　　　　　super(x, y); //使用super调用了父类中的构造函数</div>
<div>　　　　　　}</div>
<div>　　　　}</div>
<div>　　　　var son = new Son(1, 2);</div>
<div>　　　　son.sum(); &nbsp; &nbsp; //结果为3</div>
<div>&nbsp;</div>
<div>
<div>　　注意:</div>
<div>　　　　1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</div>
<div>　　　　2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</div>
<div>　　　　<span style="background-color: #ff9900;">3. 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用</span></div>
<div>&nbsp;</div>
<div><span style="background-color: #ffffff;">　2.2.4 时刻注意this的指向问题</span></div>
<div><span style="background-color: #ffffff;">　　　　我们在类中，去使用属性或者是调用方法千万不要忘记了用 this，</span></div>
<div><span style="background-color: #ffffff;">　　　　需要去关注的就是this的指向问题： </span></div>
<div><span style="background-color: #ffffff;">　　　　 &nbsp;&nbsp; 默认情况下，类中的this都指向的是当前实例化的对象，</span></div>
<div><span style="background-color: #ffffff;"><span style="background-color: #ffffff;">　　　　 &nbsp;&nbsp; 除非 </span></span>绑定事件之后this指向的就是触发事件的事件源</div>





















</div>





















</div>





















</div>





















</div>
<div>　</div>
<h2>3.构造函数和原型</h2>
<p>　　3.1 静态成员和实例成员</p>
<p>　　　　实例成员 ：实例成员就是构造函数内部通过this添加的成员，实例成员只能通过实例化的对象来访问</p>
<p>&nbsp;　　　　以下代码里的 uname&nbsp; age sing就是实例成员</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Star(uname, age) {
     </span><span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> uname; 
     </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age; 
     </span><span style="color: #0000ff;">this</span>.sing = <span style="color: #0000ff;">function</span><span style="color: #000000;">() { 
            console.log(</span>'我会唱歌'<span style="color: #000000;">); 
      } 
}
</span><span style="color: #0000ff;">var</span> ldh = <span style="color: #0000ff;">new</span> Star('刘德华', 18<span style="color: #000000;">); 
console.log(ldh.uname);    </span><span style="color: #008000;">//</span><span style="color: #008000;">实例成员只能通过实例化的对象来访问    </span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;　　　　静态成员 ：在构造函数本身上添加的成员 静态成员只能通过构造函数来访问 &nbsp;&nbsp; 在ES5中只要被static修饰的属性和方法都是静态成员</p>
<p>&nbsp;　　　　下列代码中 sex 就是静态成员</p>
<p>&nbsp;　　</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Star(uname, age) { 
         </span><span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> uname; 
         </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age; 
         </span><span style="color: #0000ff;">this</span>.sing = <span style="color: #0000ff;">function</span><span style="color: #000000;">() { 
               console.log(</span>'我会唱歌'<span style="color: #000000;">); 
         } 
}
Star.sex </span>= '男'<span style="color: #000000;">; 
</span><span style="color: #0000ff;">var</span> ldh = <span style="color: #0000ff;">new</span> Star('刘德华', 18<span style="color: #000000;">);
 console.log(Star.sex);          </span><span style="color: #008000;">//</span><span style="color: #008000;">静态成员只能通过构造函数来访问</span></pre>
</div>
<p>　　3.2构造函数的问题</p>
<p>　　　　存在浪费内存的问题</p>
<p>　　　　</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Star(uname , age) {
      </span><span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> uname;
      </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;        
      </span><span style="color: #0000ff;">this</span>.sing = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
             console.log(</span>'我会唱歌'<span style="color: #000000;">)
      }
}
</span><span style="color: #0000ff;">var</span> ldh = <span style="color: #0000ff;">new</span> Star("刘德华"，18<span style="color: #000000;">)；
</span><span style="color: #0000ff;">var</span> shuji= <span style="color: #0000ff;">new</span> Star("书记"，22<span style="color: #000000;">)；
ldh.sing();
shuji.sing();</span></pre>
</div>
<p>&nbsp;&nbsp; 以上代码在调用sing方法时都会在内存开辟一个新的空间，如果有多个对象来调用sing方法就会占用过多内存，所以我们就用到了构造函数的原型 prototype。</p>
<p>　　3.3 构造函数原型prototype</p>
<p>　　　　构造函数通过原型分配的函数是所有对象所共享的。</p>
<p>&nbsp;　　　　JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p>
<p>&nbsp;　　　　我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p>
<p>&nbsp;　　　　构造函数.prototype就可以获取原型对象</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Star(uname, age) { 
         </span><span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> uname; 
         </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
 }
Star.prototype.sing </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">() {
         console.log(</span>'我会唱歌'<span style="color: #000000;">); 
}
</span><span style="color: #0000ff;">var</span> ldh = <span style="color: #0000ff;">new</span> Star('刘德华', 18<span style="color: #000000;">); 
</span><span style="color: #0000ff;">var</span> zxy = <span style="color: #0000ff;">new</span> Star('张学友', 19<span style="color: #000000;">); 
ldh.sing();  </span><span style="color: #008000;">//</span><span style="color: #008000;">我会唱歌 </span>
zxy.sing();  <span style="color: #008000;">//</span><span style="color: #008000;">我会唱歌</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;　　3.4 对象原型</p>
<p>　　　　实例化对象都会有一个__proto__属性指向构造函数的原型对象，而我们的实例化对象可以使用对象原型的属性和方法就是因为有__proto__属性的存在</p>
<p>　　　　<span style="background-color: #ff9900;">实例化对象.__proto__ ===&nbsp; 构造函数.prototype</span></p>
<p><span style="background-color: #ff9900;"><span style="background-color: #ffffff;">　　　　它们的三角关系如下图：</span></span></p>
<p><span style="background-color: #ff9900;"><span style="background-color: #ffffff;">　　　　　　<img src="./images/JavaScript高级0.png" alt="" /></span></span></p>
<p><span style="background-color: #ff9900;"><span style="background-color: #ffffff;">　　　　</span></span>__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它<span style="background-color: #ff9900;">是一个非标准属性</span>，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype</p>
<p>&nbsp;　　3.5 constructor构造函数</p>
<p>&nbsp;<span style="background-color: #ffffff;">　　　　</span>对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性constructor 属性</p>
<p>　　　　 constructor 我们称为构造函数，因为它指回构造函数本身。</p>
<p>　　　　 constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p>
<p>　　　　</p>
<div>　　　　如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</div>
<div class="cnblogs_code">
<div>function Star(uname, age) {</div>
<div>　　this.uname = uname;</div>
<div>　　this.age = age;</div>
<div>}</div>
<div>// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数</div>
<div>Star.prototype = {</div>
<div>// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</div>
<div>　　constructor: Star, // 手动设置指回原来的构造函数</div>
<div>　　sing: function() {</div>
<div>　　　　console.log('我会唱歌');</div>
<div>　　},</div>
<div>　　movie: function() {</div>
<div>　　　　console.log('我会演电影');</div>
<div>　　}</div>
<div>}</div>
<div>var zxy = new Star('张学友', 19);</div>
<div>console.log(zxy)</div>
</div>
<p>&nbsp;　　3.6 原型链和查找机制</p>
<p>　　　　每一个实例对象又有一个proto属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有proto属性，这样一层一层往上找就形成了原型链。</p>
<p>　　　　<img src="./images/JavaScript高级1.png" alt="" /></p>
<p>　　</p>
<p>&nbsp;　　　　查找机制：</p>
<p>　　　　　　当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性，如果自身有，就有自身的属性和方法。</p>
<p>　　　　　　如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。</p>
<p>　　　　　　如果还没有就查找原型对象的原型（Object的原型对象）。依此类推一直找到 Object 为止（null）。</p>
<p>　　　　　　如果找到尽头（null)都没找到，是属性则返回undefined，是方法则报错</p>
<p>&nbsp;　　</p>
<p>　　3.7 原型对象中this的指向</p>
<p>　　　　构造函数中的this和原型对象的this,都指向我们new出来的实例对象</p>
<p>&nbsp;　　3.8 通过原型对象为数组扩展内置方法</p>
<p>　　　　</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">var arr = [3，6，9，8，5]
arr.prototype.sum = function() { 
        var sum = 0; 
        for (var i = 0; i &lt; this.length; i++) {
                  sum += this[i]; 
        }
        return sum; 
};              //此时数组对象中已经存在sum()方法了 可以用于数组.sum()进行数据的求和
</pre>
</div>
<p>　　</p>
<h2>4.继承</h2>
<p>　　4.1 call()</p>
<p>　　　　call()可以调用函数 &nbsp; 可以修改this的指向，使用call()的时候，()里的第一个参数是修改的this指向，参数2 参数3 使用逗号隔开</p>
<p>　　　　</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(x, y) {
     console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">); 
     console.log(x </span>+<span style="color: #000000;"> y); 
} 
</span><span style="color: #0000ff;">var</span> o =<span style="color: #000000;"> { 
    name: </span>'andy'<span style="color: #000000;"> 
};
fn.call(o, </span>1, 2); <span style="color: #008000;">//</span><span style="color: #008000;">调用了函数此时的this指向了对象o, </span></pre>
</div>
<p>&nbsp;&nbsp;　　4.2 构造函数继承属性 　　</p>
<div>　　　　1. 先定义一个父构造函数</div>
<div>　　　　2. 再定义一个子构造函数</div>
<div>　　　　3. 子构造函数继承父构造函数的属性(使用call方法)</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 1. 父构造函数 </span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Father(uname, age) { 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> this 指向父构造函数的对象实例</span>
      <span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> uname; 
      </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age; 
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 2 .子构造函数 </span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Son(uname, age, score) {
     </span><span style="color: #008000;">//</span><span style="color: #008000;"> this 指向子构造函数的对象实例 </span><span style="color: #008000;">
//</span><span style="color: #008000;">3.使用call方式实现子继承父的属性 </span>
      Father.call(<span style="color: #0000ff;">this</span><span style="color: #000000;">, uname, age);
      </span><span style="color: #0000ff;">this</span>.score =<span style="color: #000000;"> score; 
}
</span><span style="color: #0000ff;">var</span> son = <span style="color: #0000ff;">new</span> Son('刘德华', 18, 100<span style="color: #000000;">); 
console.log(son);</span></pre>
</div>
<p>&nbsp;　　</p>
<p>&nbsp;　　4.3 借用原型对象继承方法</p>
<div>　　　　(1). 先定义一个父构造函数</div>
<div>　　　　(2). 再定义一个子构造函数</div>
<div>　　　　(3). 子构造函数继承父构造函数的属性(使用call方法)</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 1. 父构造函数 </span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Father(uname, age) { 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> this 指向父构造函数的对象实例 </span>
　　<span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> uname; 
　　</span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age; 
}
Father.prototype.money </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">() { 
　　console.log(</span>100000<span style="color: #000000;">); 
};</span></pre>
<div>　//子构造函数</div>
<div>　　function Son(uname, age , score){　</div>
<div>　　　　<span data-mce-="">//<span data-mce-=""> this 指向子构造函数的对象实例</span></span></div>
<div>
<div>　　　　Father.call(this, uname, age);</div>
<div>　　　　this.score = score;</div>
</div>
<div>&nbsp; };</div>
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对 象,父原型对象也会跟着一起变化 </span>
Son.prototype = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Father(); 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 </span>
Son.prototype.constructor =<span style="color: #000000;"> Son; 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 这个是子构造函数专门的方法 </span>
Son.prototype.exam = <span style="color: #0000ff;">function</span><span style="color: #000000;">() { 
　　console.log(</span>'孩子要考试'<span style="color: #000000;">); 
}
</span><span style="color: #0000ff;">var</span> son = <span style="color: #0000ff;">new</span> Son('刘德华', 18, 100<span style="color: #000000;">); 
console.log(son);</span></pre>
</div>
<p>　　</p>
<h2>&nbsp;5.ES5新增方法</h2>
<p>　　5.1 forEach()遍历数组&nbsp; 没有返回值</p>
<p>　　　　array.forEach(function(value , index , array){....})</p>
<p>　　　　value是每个数组元素</p>
<p>　　　　index是每个元素索引值</p>
<p>　　　　array是当前数组</p>
<p>　　5.2 filter()筛选数组&nbsp; 其实也会遍历数组</p>
<p>　　　　array.filter(function(value , index , array){</p>
<p>　　　　　　return&nbsp; 条件表达式</p>
<p>　　　　})</p>
<p>　　　　返回的是一个新数组&nbsp; 括号跟的参数都是一样的</p>
<p>　　5.3 some() &nbsp; 查找数组中是否有满足条件的元素 &nbsp;其实也会遍历数组</p>
<p>　　　　array.some(function(value , index , array){</p>
<p>　　　　　　return&nbsp; 条件表达式</p>
<p>　　　　})</p>
<p>&nbsp;　　　　返回值是布尔值，只要查找到第一个满足条件的元素就会终止循环 效率高　　</p>
<p>&nbsp;</p>
<p>&nbsp;　　5.4 trim方法去除字符串两端的空格</p>
<p>　　　　字符串的特性 不可变性</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> str = ' hello '<span style="color: #000000;"> ；
console.log(str.trim()）  </span><span style="color: #008000;">//</span><span style="color: #008000;">hello 去除两端空格 </span>
<span style="color: #0000ff;">var</span> str1 = ' he l l o '<span style="color: #000000;"> ;
console.log(str1.trim()）  </span><span style="color: #008000;">//</span><span style="color: #008000;">he l l o 去除两端空格</span></pre>
</div>
<p>　　5.5 获取对象的属性名&nbsp;</p>
<p>　　　　Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> { 
    id: </span>1<span style="color: #000000;">, 
    pname: </span>'小米'<span style="color: #000000;">, 
    price: </span>1999<span style="color: #000000;">,
    num: </span>2000<span style="color: #000000;"> 
};
</span><span style="color: #0000ff;">var</span> result =<span style="color: #000000;"> Object.keys(obj);
console.log(result)   </span><span style="color: #008000;">//</span><span style="color: #008000;">返回的新数组[id，pname,price,num]</span></pre>
</div>
<p>　　5.6 Object.defineProperty设置或修改对象中的属性</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">Object.defineProperty(对象，修改或新增的属性名，{ 
　　value:修改或新增的属性的值, 
　　writable:</span><span style="color: #0000ff;">true</span>/false,  //如果值为false 不允许修改这个属性值 
　　enumerable: <span style="color: #0000ff;">false</span>,    <span style="color: #008000;">//</span><span style="color: #008000;">enumerable 如果值为false 则不允许遍历 </span>
　　configurable: <span style="color: #0000ff;">false</span>   <span style="color: #008000;">//</span><span style="color: #008000;">configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性 </span>
})</pre>
</div>
<p>&nbsp;</p>
<h2>&nbsp;6.函数的定义和调用</h2>
<p>　　6.1 函数的定义方式</p>
<p>　　　　(1) function关键字（命名函数）</p>
<p>　　　　　　function fn(){......}</p>
<p>　　　　(2) 函数表达式(匿名函数)</p>
<p>&nbsp;　　　　　　var fn = function(){......}</p>
<p>　　　　(3) 利用new function('参数1','参数2','函数体')</p>
<p>　　　　　　var f = new Function('a','b','console.log(a +b)'); &nbsp; //参数都必须是字符串格式</p>
<p>　　　　　　f( 3, 2); &nbsp; //输出结果是5　</p>
<h4>　　所有函数都是Function的实例，函数也属于对象</h4>
<p>　　6.2 函数的调用方式</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 1.普通函数</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){
</span><span style="color: #008080;"> 3</span>     console.log('hello world'<span style="color: #000000;">)    
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">fn();
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 2.对象的方法</span>
<span style="color: #008080;"> 8</span> <span style="color: #0000ff;">var</span> o =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 9</span>     sayHi : <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;">10</span>         console.log('hello world'<span style="color: #000000;">)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">     }
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}
</span><span style="color: #008080;">13</span> <span style="color: #000000;">o.sayHi();
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 3.构造函数</span>
<span style="color: #008080;">16</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> Star(){};
</span><span style="color: #008080;">17</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Star();
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span> 
<span style="color: #008080;">20</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 4.绑定函数事件</span>
<span style="color: #008080;">21</span> btn.onclick = <span style="color: #0000ff;">function</span>(){}  <span style="color: #008000;">//</span><span style="color: #008000;"> 点击了按钮就可以调用这个函数</span>
<span style="color: #008080;">22</span> 
<span style="color: #008080;">23</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 5.定时器函数</span>
<span style="color: #008080;">24</span> setInterval(<span style="color: #0000ff;">function</span>(){},1000);  <span style="color: #008000;">//</span><span style="color: #008000;"> 这个函数定时器自动一秒钟调用一次</span>
<span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span> <span style="color: #008000;">//</span><span style="color: #008000;">6.立即执行函数（自调用函数）</span>
<span style="color: #008080;">27</span> (<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;">28</span>      console.log('hello world'<span style="color: #000000;">)
</span><span style="color: #008080;">29</span> })();</pre>
</div>
<p>&nbsp;</p>
<h2>7.this</h2>
<p>　　7.1 函数内部的this指向</p>
<p>　　　　一般情况下，this指向函数的调用者</p>
<p>　　　　<img src="./images/JavaScript高级2.png" alt="" /></p>
<p>　　7.2 改变函数内部this的指向</p>
<p>　　　　1.call()方法</p>
<p>　　　　　　可以直接调用函数，也可以改变this的指向　　　　　</p>
<div>　　　　　　var o = {</div>
<div>　　　　　　　　name: 'andy'</div>
<div>　　　　　　}</div>
<div>　　　　　　function fn(a, b) {</div>
<div>　　　　　　　　console.log(this);</div>
<div>　　　　　　　　console.log(a+b)</div>
<div>　　　　　　};</div>
<div>　　　　　　fn(1,2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // 此时的this指向的是window 运行结果为3</div>
<div>　　　　　　fn.call(o,1,2)&nbsp; //此时的this指向的是对象o,参数使用逗号隔开,运行结果为3</div>
<p>&nbsp;　　　　　&nbsp; 应用：经常做继承</p>
<p>　　　　2.apply()方法</p>
<p>　　　　　　可以直接调用函数，也可以改变this的指向　　</p>
<div>　　　　　　var o = {</div>
<div>　　　　　　　　name: 'andy'</div>
<div>　　　　　　}</div>
<div>　　　　　　function fn(a, b) {</div>
<div>　　　　　　　　console.log(this);</div>
<div>　　　　　　　　console.log(a+b)</div>
<div>　　　　　　};</div>
<div>　　　　　　fn() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // 此时的this指向的是window 运行结果为3</div>
<div>　　　　　　fn.apply(o,[1,2])&nbsp; //此时的this指向的是对象o,参数使用数组传递 运行结果为3</div>
<p>&nbsp;　　　　　　应用：跟数组有关</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">// 利用apply借助数学内置对象求最大值等<br /></span><span style="color: #0000ff;">var</span> arr = [1,56,55,4,33<span style="color: #000000;">];</span>
<span style="color: #0000ff;">var</span> max =<span style="color: #000000;"> Math.max.apply(Math,arr);</span>
console.log(max)   <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果应该是56</span></pre>
</div>
<p>　　　　3.&nbsp; bind()方法</p>
<p>&nbsp;　　　　　　不会调用函数，但是可以改边this的指向，返回的是一个新函数　　　　</p>
<div>　　　　　　var o = {</div>
<div>　　　　　　　　name: 'andy';</div>
<div>　　　　　　};</div>
<div>　　　　　　function fn(a, b) {</div>
<div>　　　　　　　　console.log(this);</div>
<div>　　　　　　　　console.log(a + b);</div>
<div>　　　　　　};</div>
<div>　　　　　　var f = fn.bind(o, 1, 2); &nbsp;&nbsp; //此处的f是bind返回的新函数</div>
<div>　　　　　　f(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //调用新函数 this指向的是对象o 参数使用逗号隔开</div>
<p>　　　　　　应用：不调用函数，但是还想改变this指向</p>
<p>&nbsp;　　　　4. call、apply、bind三者区别</p>
<p>　　　　　　call和apply都是直接调用函数，可以改变this的指向</p>
<p>　　　　　　　　　call后面跟的参数是列表形式，apply跟的是数组形式</p>
<p>　　　　　　bind不会直接调用函数，也可以改变ths的指向</p>
<h2>8. 严格模式(strict mode)</h2>
<p>　　　　ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。</p>
<p>　　　　8.1 为脚本开启严格模式</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">
    (</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (){
 </span><span style="color: #008000;">//</span><span style="color: #008000;">在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式 </span>
         "use strict"<span style="color: #000000;">; 
          </span><span style="color: #0000ff;">var</span> num = 10<span style="color: #000000;">; 
          </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn() {
          } 
     })(); 
</span><span style="color: #008000;">//</span><span style="color: #008000;">或者 </span>
&lt;script&gt; 
    "use strict"<span style="color: #000000;">;
      </span><span style="color: #008000;">//</span><span style="color: #008000;">当前script标签开启了严格模式 </span>
&lt;/script&gt;
&lt;script&gt; 
     <span style="color: #008000;">//</span><span style="color: #008000;">当前script标签未开启严格模式</span>
 &lt;/script&gt;   </pre>
</div>
<p>　　　　8.2 为函数开启严格模式</p>
<p>　　　　　　要给某个函数开启严格模式，需要把&ldquo;use strict&rdquo;; (或 'use strict'; ) 声明放在函数体所有语句之前。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){
     </span>"use strict"<span style="color: #000000;">;
      </span><span style="color: #0000ff;">return</span> "123"<span style="color: #000000;">; 
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">当前fn函数开启了严格模式</span></pre>
</div>
<p>　　　　8.3 严格模式中的变化</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">'use strict';
 num = 10 ;
console.log(num)//严格模式后使用未声明的变量 
‐‐‐ ‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
var num2 = 1;
delete num2;//严格模式不允许删除变量 
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐ 
function fn() { 
    console.log(this); // 严格模式下全局作用域中函数中的 this 是 undefined 
}
fn();
 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐
 function Star() {
 this.sex = '男'; 
}
// Star();严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给 他赋值则 会报错. 
var ldh = new Star(); 
console.log(ldh.sex); 
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐ 
setTimeout(function() { 
console.log(this); //严格模式下，定时器 this 还是指向 window
 }, 2000);
</pre>
</div>
<p>　</p>
<h2>9.高阶函数</h2>
<p>　　高阶函数是对其他函数进行操作的函数，可以接收函数作为参数或者将函数作为返回值输出。</p>
<p>　　函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。同理函数也可以作为返回值传递回来</p>
<h2>10.闭包(clsure)</h2>
<p>　　闭包是指有权访问另一个函数作用域中变量的函数。简单理解就是一个作用域可以访问另外一个函数内部的局部变量。</p>
<p>　　作用： 延伸变量的作用范围，增长了变量的生命周期。</p>
<p>　　弊端： 造成内存泄漏。(内存泄漏，就是本该销毁的数据没有销毁，造成内存浪费)</p>
<p>　　闭包里的经典面试题：</p>
<p>　　　　1. 遍历注册li的点击事件，利用闭包的实行，点击每一个li输出对应的索引</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0; i &lt; lis.length; i++<span style="color: #000000;">) { 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 利用for循环创建了4个立即执行函数 </span><span style="color: #008000;">
//</span><span style="color: #008000;"> 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这个变量        <br />　　(function(i) {</span>
 　　　　lis[i].onclick = <span style="color: #0000ff;">function</span><span style="color: #000000;">() { 
　　 　　　　console.log(i); 
　　 　　} 
　　})(i); <br />}</span></pre>
</div>
<p>　　　　2.&nbsp;遍历 1 ~ 5 5个数值，利用闭包，在setTimeout里面输入 1 ~ 5</p>
<p>　　</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">for (var i = 0; i &lt; 5; i++) {
     (function(i) { 
         setTimeout(function() { <br />　　　　　　　　console.log(lis[i].innerHTML); <br />　　　　　}, 3000) <br />　　　})(i); <br />}    
</pre>
</div>
<p>　　</p>
<h2>11.递归</h2>
<p>&nbsp;　　如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。</p>
<p>&nbsp;　　简单理解:函数内部自己调用自己, 这个函数就是递归函数</p>
<p>　　递归函数的作用和循环效果一样，很容易发生&lsquo;栈溢出&rsquo;错误(stack overflow)，所以必须要加退出条件return。</p>
<p>　　1. 利用递归求1~n的阶乘</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">function fn(n){
    if (n == 1) {
         return 1;
    }
    return n * fn(n -1)
}
console.log(fn(3))
</pre>
</div>
<p>　　　2.&nbsp; 利用递归求斐波那契数列(斐波那契数列就是前两个数的和等于第三个数字，也叫兔子数)</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">// 利用递归函数求斐波那契数列(兔子序列) 1、1、2、3、5、8、13、21... 
// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值
// 我们只需要知道用户输入的n 的前面两项(n‐1 n‐2)就可以计算出n 对应的序列值

function fb(n){
    if ( n== 2 || n== 1) {
         return 1;
    }
    return fb( n -1) + fb (n-2);
} 
console.log(fb(3))
</pre>
</div>
<p>　　</p>
<h2>12.正则表达式</h2>
<p>　　12.1 什么是正则表达式？</p>
<p>　　　　正则表达式(Regular Expression)是用于匹配字符串中字符组合的模式。在JavaScript中，<span style="background-color: #ffcc00;">正则表达式也是对象</span></p>
<p>　　12.2 作用</p>
<p>　　　　 1.匹配&nbsp; 2. 替换 3.提取</p>
<h2>13.正则表达式在js中的使用</h2>
<p>　　1. 正则表达式的创建&nbsp;</p>
<p>　　　　方式一 ：通过调用RegExp对象的构造函数创建</p>
<p>　　　　　　var reg = new RegExp(/123/);</p>
<p>　　　　　　console.log(reg); &nbsp;&nbsp; // 输出结果 /123/</p>
<p>　　　　方式二 ： 利用字面量创建</p>
<p>　　　　　　var rg = /123/;</p>
<p>　　2. 测试正则表达式</p>
<p>　　　　test()正则对象方法，用于检测字符串是否符合规则，该方法返回值是布尔类型，true或false，括号里的参数是字符串</p>
<p>　　　　var rg = /123/;</p>
<p>　　　　console.log(rg.test(123)); // 返回值是true</p>
<p>　　　　console.log(rg.test('abc')); // 返回值是false</p>
<p>　　3. 正则表达式中的特殊字符</p>
<p>　　　　3.1边界符（正则表达式中的边界符（位置符）用来提示字符所处的位置）</p>
<p>　　　　　　<img src="./images/JavaScript高级3.png" alt="" /></p>
<p>　　　　　　如果 ^和 $ 在一起，表示必须是精确匹配</p>
<p>　　　　3.2 字符类&nbsp;</p>
<p>　　　　　　　　<strong>[ ]</strong>方括号，表示有一系列字符可供选择，只要匹配到其中一个就可以了</p>
<p>　　　　　　　　　<img src="./images/JavaScript高级4.png" alt="" /></p>
<p>　　　　　　　　　<img src="./images/JavaScript高级5.png" alt="" /></p>
<p>　　　　3.3 量词符</p>
<p>　　　　　　量词符用来设定某个模式出现的次数，都是写在某个模式的后面</p>
<p>　　　　　　<img src="./images/JavaScript高级6.png" alt="" /></p>
<p>　　　　　<span style="text-decoration: underline;">　<strong>逗号前后都不能有空格</strong></span></p>
<p>&nbsp;</p>
<p><strong>　　　　</strong>3.4 括号总结</p>
<p>　　　　　　大括号{}&nbsp; 量词符，里面表示重复次数</p>
<p>　　　　　　中括号[]&nbsp; 字符集合，匹配中括号里面的任意字符</p>
<p>　　　　　　小括号() 表示优先级</p>
<p>　　　　3.5 预定义类</p>
<p>　　　　　　指的是某些常见模式的简写方式</p>
<p>　　　　　　<img src="./images/JavaScript高级7.png" alt="" /></p>
<p>　　　　3.6 正则替换和正则提取</p>
<p>　　　　　　replace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串，也可以是一个正则表达式</p>
<p>　　　　　　注意：replace()是字符串的方法，并不是正则对象的方法</p>
<p>　　　　　　语法： obj.replace(参数1，参数2)</p>
<p>　　　　　　　obj是要选择的目标字符串，参数1是要被替换的字符串，可以是字符串也可以是正则表达式，参数2是替换之后的字符串</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> str = "abcd"<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 把字符串里的a替换成 哈哈</span>
<span style="color: #0000ff;">var</span> str1 = str.replace("a","哈哈"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> str2 = str.replace(/a/,"哈哈"<span style="color: #000000;">);
console.log(str1);   </span><span style="color: #008000;">//</span><span style="color: #008000;">输出 哈哈bcd  </span>
console.log(str2);   <span style="color: #008000;">//</span><span style="color: #008000;">输出 哈哈bcd<br /><br /></span></pre>
</div>
<p>　　　　　　match()可以进行提取，返回值是一个数组</p>
<p>　　　　　　语法 ： 字符串.match(正则表达式)</p>
<p>　　　　　　str.match(/\w+@\w+\.\w+/g)&nbsp; 可以提取字符串里的所有邮箱</p>
<p>&nbsp;</p>
<p>　　　　　3.7 正则表达式参数</p>
<p>　　　　　　　　后面可以跟三种形式的参数</p>
<p>　　　　　　　　/表达式/g &nbsp; &nbsp; 表示全局匹配，就是可以将所有的某个字符都进行转换</p>
<p>　　　　　　　　/表达式i/　 &nbsp; 忽略大小写</p>
<p>　　　　　　　　/表达式/gi　 全局匹配+忽略大小写</p>
<p>　　　　　　　　<img src="./images/JavaScript高级8.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code" style="text-align: justify;" onclick="cnblogs_code_show('69d9f6e7-9e4a-4ee9-973e-4a964f68e531')">&nbsp;</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</div>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>