<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修TS学习' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>TS学习</center></div><div class='banquan'>原文出处:本文由博客园博主waitklove提供。<br/>
原文连接:https://www.cnblogs.com/czkolve/p/11638334.html</div><br>
    <p><span style="font-size: 16px;">随着vue3.0的即将到来，是时候学习一下TS了</span></p>
<p>　　简介：TypeScript是一种由微软开发的自由和<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339" target="_blank" data-lemmaid="246339">开源</a>的编程语言。它是<a href="https://baike.baidu.com/item/JavaScript" target="_blank">JavaScript</a>的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/254878" target="_blank" data-lemmaid="254878">面向对象编程</a>。</p>
<p>　　ts并不是js语言，所以它是不能直接被浏览器识别的，所有从ts到js是有一个转换的过程，我们可以称之为编译。</p>
<p>　　ts转化到js和es6到es5是类似的，所以我们借助webpack 构建工具，将要使用的转化插件是ts-loader,和css-loader,style-loader都是差不多的</p>
<p>　　<a href="https://www.webpackjs.com/guides/typescript/">https://www.webpackjs.com/guides/typescript/</a>&nbsp;webpack 使用指南</p>
<p>　　webpack 4 　安装webpack-cli&nbsp; 创建webpack.config.js 文件&nbsp;</p>
<p>　　执行&nbsp;<code>npm <span class="token function">install --save-dev typescript ts-loader 安装转化插件，创建tsconfig.json 配置文件</span></code></p>
<p><span class="token function">　　整体的项目结构如图</span></p>
<p><span class="token function">　　<img src="./images/TS学习0.png" alt="" width="484" height="221" /></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;　　测试一下，我们创建一个ts文件tsdome.js,经过编译后申请bundle.js</p>
<p>　　tsdome.ts</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> getname():string {
  let name: string </span>= "123"
  <span style="color: #0000ff;">return</span><span style="color: #000000;"> name
}
console.log(getname())</span></pre>
</div>
<p>　　最终生成的bundle.js(可以不用关心)</p>
<div class="cnblogs_code">
<pre><code>!<span style="color: #0000ff;">function</span>(e){<span style="color: #0000ff;">var</span> t={};<span style="color: #0000ff;">function</span> n(r){<span style="color: #0000ff;">if</span>(t[r])<span style="color: #0000ff;">return</span> t[r].exports;<span style="color: #0000ff;">var</span> o=t[r]={i:r,l:!1,exports:{}};<span style="color: #0000ff;">return</span> e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=<span style="color: #0000ff;">function</span>(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=<span style="color: #0000ff;">function</span>(e){"undefined"!=<span style="color: #0000ff;">typeof</span> Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=<span style="color: #0000ff;">function</span>(e,t){<span style="color: #0000ff;">if</span>(1&amp;t&amp;&amp;(e=n(e)),8&amp;t)<span style="color: #0000ff;">return</span> e;<span style="color: #0000ff;">if</span>(4&amp;t&amp;&amp;"object"==<span style="color: #0000ff;">typeof</span> e&amp;&amp;e&amp;&amp;e.__esModule)<span style="color: #0000ff;">return</span> e;<span style="color: #0000ff;">var</span> r=Object.create(<span style="color: #0000ff;">null</span>);<span style="color: #0000ff;">if</span>(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&amp;t&amp;&amp;"string"!=<span style="color: #0000ff;">typeof</span> e)<span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> o <span style="color: #0000ff;">in</span> e)n.d(r,o,<span style="color: #0000ff;">function</span>(t){<span style="color: #0000ff;">return</span> e[t]}.bind(<span style="color: #0000ff;">null</span>,o));<span style="color: #0000ff;">return</span> r},n.n=<span style="color: #0000ff;">function</span>(e){<span style="color: #0000ff;">var</span> t=e&amp;&amp;e.__esModule?<span style="color: #0000ff;">function</span>(){<span style="color: #0000ff;">return</span> e.<span style="color: #0000ff;">default</span>}:<span style="color: #0000ff;">function</span>(){<span style="color: #0000ff;">return</span> e};<span style="color: #0000ff;">return</span> n.d(t,"a",t),t},n.o=<span style="color: #0000ff;">function</span>(e,t){<span style="color: #0000ff;">return</span> Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([<span style="color: #0000ff;">function</span>(e,t){console.log("123")}]);</pre>
</div>
<p>　　最终可以再浏览器打印出123　　</p>
<p><img src="./images/TS学习1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;　　经过上面我们初始开发ts的环境已经搭建完毕</p>
<p>　　一、TS基础类型</p>
<p>　　　　布尔值 boolean&nbsp; 数值 number&nbsp; 字符串 string&nbsp; 数组 number[] 或者 Array&lt;number&gt;&nbsp; 元组 Tuple 枚举 enum</p>
<p>　　　　任何类型 Any&nbsp; 空值 void&nbsp; Null和Underfined&nbsp; nerver&nbsp; &nbsp;Object 对象</p>
<p>　　　　下面是所以的类型，以及所以的类型使用</p>
<div class="cnblogs_code">
<pre><code>let isdome: <span style="color: #0000ff;">boolean</span> = <span style="color: #0000ff;">true</span><span style="color: #000000;">
let cname: string </span>= '123132'<span style="color: #000000;">
let age: number </span>= 123<span style="color: #000000;">
let list: number[] </span>= [1,2,3,4<span style="color: #000000;">]
let listname: string[] </span>= ['1','2','3','4'<span style="color: #000000;">]
let listarray: Array</span>&lt;number&gt; = [1,2,3,5<span style="color: #000000;">]
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 元组 对每个元素都进行单独类型定义 ,如果类型对不上就会报错</span>
let yzlist: [number,number,string] = [1,2,'3'<span style="color: #000000;">]
</span><span style="color: #008000;">//</span><span style="color: #008000;">枚举 （好像有点像对象）</span>
<span style="color: #000000;">enum Color {red,green,blue}
let c: Color </span>=<span style="color: #000000;"> Color.red
let notsure: any </span>= 4 <span style="color: #008000;">//</span><span style="color: #008000;">不确认类型，可以用any</span>

<span style="color: #0000ff;">function</span> getbname(): <span style="color: #0000ff;">void</span><span style="color: #000000;"> {
  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 表示没有换回值的函数</span>
  console.log(123<span style="color: #000000;">)
}
getbname()
</span><span style="color: #008000;">//</span><span style="color: #008000;"> undefined  null 意思不是很大</span>
let und: undefined =<span style="color: #000000;"> undefined
let nl: </span><span style="color: #0000ff;">null</span> = <span style="color: #0000ff;">null</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> never 表示永不存在的值类型，如一些总是抛出错误，或者根本不会有返回值的函数表达式，或者是箭头函数</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> error(message: string):never {
  </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Error(message)
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">object 对象类型</span>
let obj: object =<span style="color: #000000;"> {
  a:</span>132<span style="color: #000000;">
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 类型断言</span>
let anykey: any = '七月的风，八月的雨，你的过去，无法参与'<span style="color: #000000;">
let alength: number </span>= (&lt;string&gt;<span style="color: #000000;">anykey).length
console.log(alength)

let aslength: number </span>=<span style="color: #000000;"> (anykey as string).length
console.log(aslength)</span></pre>
</div>
<p>　　二、变量申明 let const var</p>
<p>　　没什么可说的，es6 es5 ,let表示局部变量，没有申请提升，只能先申明后使用，否则报错，var 略，const，表示常量，赋值后就不能再次改变了。如果值是一个对象，表示地址不能变。</p>
<p>　　三、接口&nbsp;&nbsp;</p>
<p>　　</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个父类接口parent 里面有一个name属性</span>
<span style="color: #000000;">interface parent {
  name: string
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> getname(anyamin:parent) {
  console.log(anyamin.name)
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">继承于parent的子类必须实现 name属性，要不会报错</span>
getname({name: '123123'<span style="color: #000000;">})

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 当然接口的属性是可以定义成可选的</span>
<span style="color: #000000;">interface anany {
  name: string,
  age</span>?<span style="color: #000000;">: number,
  sex</span>?<span style="color: #000000;">: string
}
let bbb: anany </span>=<span style="color: #000000;"> {
  name: </span>'123132'<span style="color: #000000;">,
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> bbb可以不去实现sex 和 age ,当然也不能给bbb新增属性，那么也会报错</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 只读属性的定义</span>
<span style="color: #000000;">interface point {
  readonly x: number,
  readonly y: number
}
let bp: point </span>=<span style="color: #000000;"> {
  x: </span>123<span style="color: #000000;">,
  y: </span>123<span style="color: #000000;">
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> bp.x = 6  报错，只读属性不能从新赋值</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> 函数类型</span>
<span style="color: #000000;">interface SearchFunc{
  </span><span style="color: #008000;">//</span><span style="color: #008000;">表示一个函数，有两个参数，第一个参数是string类型，第二个参数是number,返回值是void</span>
  <span style="color: #008000;">//</span><span style="color: #008000;"> x y 为形参，不需要一样</span>
  (x: string,y: number): <span style="color: #0000ff;">void</span><span style="color: #000000;"> 
}
let func: SearchFunc </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(z: string,b: number) {
  console.log(z</span>+<span style="color: #000000;">b)
}
func(</span>'1',2<span style="color: #000000;">)
</span><span style="color: #008000;">//</span><span style="color: #008000;">  可索引类型 好像和数组类似，没多大区别</span>
<span style="color: #000000;">interface stringarrray{
  [index: number]: string
}
let arrayname: stringarrray </span>= ['bob','333'<span style="color: #000000;">]
console.log(arrayname[</span>0<span style="color: #000000;">])

</span><span style="color: #008000;">//</span><span style="color: #008000;">类 类型 。。。。。。</span></pre>
</div>
<p>&nbsp;　　类类型</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 类继承接口</span><span style="color: #008000;">
//</span><span style="color: #008000;">类 类型</span>
<span style="color: #000000;">interface ClockInterface {
  currentTime: string
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个接口，里面有一个currentTime</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 如果使用类去继承他，则必须再构造函数中初始化它</span>
<span style="color: #000000;">class Clock implements ClockInterface {
  currentTime: string
  constructor(h: number,m: number){
    </span><span style="color: #0000ff;">this</span>.currentTime = '123'<span style="color: #000000;">
  } 
}

interface parent {
  tick(): </span><span style="color: #0000ff;">void</span>, <span style="color: #008000;">//</span><span style="color: #008000;">tick方法，返回值是空</span>
  name: string <span style="color: #008000;">//</span><span style="color: #008000;"> 属性那么,为string 类型</span>
<span style="color: #000000;">}

class child implements parent {
  name: string
  constructor(x: string) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> x
  }
  tick(): </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> {
    console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.name)
  }
}
let c1 </span>= <span style="color: #0000ff;">new</span> child('cz'<span style="color: #000000;">)
c1.tick()</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 接口继承接口</span>
<span style="color: #000000;">interface p1 {
  name: string
}
interface p2 extends p1 {
  age: number
}
class c1 implements p2 {
  name: string
  age: number
  constructor() {
    </span><span style="color: #0000ff;">this</span>.name = '123'
    <span style="color: #0000ff;">this</span>.age = 12<span style="color: #000000;">
  }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 接口继承接口</span>
<span style="color: #000000;">interface Counter {
  (start: number): string </span><span style="color: #008000;">//</span><span style="color: #008000;">代一个string参数，返回值未string的函数</span>
<span style="color: #000000;">  interval: number
  reset (): </span><span style="color: #0000ff;">void</span><span style="color: #000000;">
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> getCounter(): Counter {
  let counter </span>= &lt;Counter&gt;<span style="color: #0000ff;">function</span><span style="color: #000000;">(x: number){}
  counter.interval </span>= 123<span style="color: #000000;">
  counter.reset</span>= <span style="color: #0000ff;">function</span>():<span style="color: #0000ff;">void</span><span style="color: #000000;"> {
  }
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> counter
}
let cc </span>=<span style="color: #000000;"> getCounter()
console.log(cc.interval)

</span><span style="color: #008000;">//</span><span style="color: #008000;">接口继承类</span>
<span style="color: #000000;">class pc {
  private state: any
}
interface sel extends pc {
  select (): </span><span style="color: #0000ff;">void</span><span style="color: #000000;">
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 接口不能继承代有私有类型类</span>
<span style="color: #000000;">class pd implements sel {
  constructor () {
  }
  select ():</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> {

  }
}</span></pre>
</div>
<p>　　对于接口而言，不能出现私有的属性或者方法，因为接口的属性在其继承者上，必须实现。二私有的属性和对象是不能够继承的。</p>
<p>　</p>
<p><span class="token function">&nbsp;</span></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>