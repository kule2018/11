<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修TypeScript 基础知识点整理' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>TypeScript 基础知识点整理</center></div><div class='banquan'>原文出处:本文由博客园博主RopeHuo提供。<br/>
原文连接:https://www.cnblogs.com/rope/p/10631209.html</div><br>
    <h2 id="一typescript的特点">一、TypeScript的特点</h2>
<h3 id="支持es6规范">1.支持ES6规范</h3>
<h3 id="强大的ide支持集成开发环境">2.强大的IDE支持（集成开发环境）</h3>
<ol>
<li><p>允许为变量指定类型，减少你在开发阶段犯错误的几率。</p></li>
<li><p>语法提示，在IDE编写代码时，它会根据你所处的上下文把你能用的类，变量，方法，关键字给你提示出来。</p></li>
<li><p>重构，方便的修改变量，方法，文件的名字，当你修改的时候IDE会帮你把你用到过这些变量，方法的地方给修改掉。</p></li>
</ol>
<h3 id="angular2的开发语言">3.Angular2的开发语言。</h3>
<h2 id="二搭建typescipt的开发环境">二、搭建TypeScipt的开发环境</h2>
<h3 id="我们需要compiler编译器">1. 我们需要compiler（编译器）。</h3>
<p>我们需要把 .ts 结尾的TypeScript文件给编译成 .js 结尾的JavsScript文件，因为现在有些浏览器是不支持ES6语法的，没办法直接让程序跑起来，所以我们需要编译成支持ES5的JavaScript语法。</p>
<h3 id="使用在线compiler开发-typescript">2. 使用在线compiler开发 <a href="http://www.typescriptlang.org/play/index.html">TypeScript</a></h3>
<h3 id="搭建本地开发环境">3. 搭建本地开发环境</h3>
<ol>
<li><p><code>npm insatll typescript -g</code>全局安装</p></li>
<li><p><code>tsc --version</code>查看版本</p></li>
<li><p>./demo/hello.ts</p>
<p><img src="./images/TypeScript 基础知识点整理0.png" alt="ts_demo" /></p></li>
<li><p><code>tsc ./demo/hello.ts</code>会在它的同级目录生成一个hello.js文件</p>
<p><img src="./images/TypeScript 基础知识点整理1.png" alt="js_demo" /></p></li>
<li><p>每次都这样的操作有点麻烦，我们开始使用IDE，它可以帮我做这些事情</p>
<p>创建项目目录打开CMD<code>tsc --init</code>会生成tsconfig.json配置文件</p>
<pre><code><code>{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,//翻译出来的语法
    &quot;module&quot;: &quot;commonjs&quot;,//使用commonjs模块
    &quot;outDir&quot;: &quot;./js/&quot;,//翻译出来的文件存放在./js文件夹中
    &quot;rootDir&quot;: &quot;./tscript/&quot;,//需要翻译的文件放在./tscript文件夹中
    &quot;esModuleInterop&quot;: true
    // esModuleInterop取决于设置的内容module。
    // 如果有&quot;module&quot;: &quot;commonjs&quot;，则只需启用&quot;esModuleInterop&quot;: true。
    // 如果您有&quot;module&quot;: &quot;es2015&quot;或者&quot;module&quot;: &quot;esnext&quot;，
    //您还必须启用&quot;allowSyntheticDefaultImports&quot;: true以便导入CommonJS模块（如React）作为默认值。
  }
}</code></pre>
<p>我们采用以上配置；</p>
<p>我们今天用Visual Studio Code来做示范打开创建好的项目文件夹，webstorm上的话会有提示插件更加方便。</p>
<p>新建tscript、js文件夹，分别用作存放typescript、javascript文件，在tscript目录中新建test.ts文件。</p>
<p>打开&gt;菜单&gt;终端&gt;运行任务&gt;<img src="./images/TypeScript 基础知识点整理2.png" alt="vscode" /></p>
<p>点击运行后，只要我们修改ts文件的代码且保存后会自动翻译</p>
<p><img src="./images/TypeScript 基础知识点整理3.png" alt="fanyi" /></p>
<p><strong>这就配置好了，接下来就可以正常开发了。</strong></p></li>
</ol>
<h2 id="三学习字符串">三、学习字符串</h2>
<h3 id="多行字符串">1、多行字符串</h3>
<p>JS中我们声明变量是不可以换行的</p>
<pre class="javascript"><code>var str = &#39;aaa
bbb
ccc&#39;
/*上面这样的写法是会报错的，我们通常用下面的写法*/
var str = &#39;aaa&#39;+
&#39;bbb&#39;+
&#39;ccc&#39;;</code></pre>
<p>TS中有多行字符串的写法用<code>``</code>来包裹</p>
<pre class="typescript"><code>var str = `aaa
bbb
ccc`
//在这个里面你是可以任意换行的
//翻译成JS是这样的
var str = &#39;aaa\nbbb\nccc&#39;</code></pre>
<h3 id="字符串模板">2、字符串模板</h3>
<pre class="typescript"><code>var myName = &#39;huoqingchi&#39;
var getName = function () {
    return &#39;huoqingchi&#39;;
}
console.log(`hello ${myName}`);//可以直接写表达式
console.log(`hello ${getName()}`);//也可以直接调用方法
//切记能这样做的原因是因为它们写在了``当中。</code></pre>
<p>接下来我们见识下字符串模板的威力，用字符串拼接一段HTML</p>
<pre class="typescript"><code>var myName = &#39;huoqingchi&#39;;
console.log(`&lt;div&gt;
    &lt;h1&gt;你们好我是${myName}&lt;/h1&gt;
    &lt;h1&gt;${getName()}&lt;/h1&gt;
&lt;/div&gt;`);//可读性和书写实在是太好了。</code></pre>
<h3 id="自动拆分字符串">3、自动拆分字符串</h3>
<p>当你在用一个字符串模板去调用一个方法的时候这个字符串模板里面表达式的值会自动赋给被调用方法中的参数。</p>
<pre class="typescript"><code>function test(template,name,age) {
    console.log(template)
    console.log(name)
    console.log(age)
};
var myName = &#39;huoqingchi&#39;;
var getAge = function(){
    return 18;
}
//如果你想使用字符串拆分的特性就不能直接圆括号调用test方法，需要用``。
//第一个参数是你的字符串模板。
//第二个参数就是你出现的第一个表达式的值。
//第三个参数就是你出现的第二个表达式的值。
test`hello ${myName},${getAge()}`
</code></pre>
<p>输出结果:<br />
<img src="./images/TypeScript 基础知识点整理4.png" alt="muban" /></p>
<hr />
<h2 id="四参数的新特性">四、参数的新特性</h2>
<h3 id="参数类型">1、参数类型</h3>
<p>在参数的名称后面我们可以使用冒号来指定参数的类型</p>
<p><img src="./images/TypeScript 基础知识点整理5.png" alt="leixing" /></p>
<p>因为我已经给str这个变量指定了string类型，所以我再给它赋值一个数值类型时会报错，这种情况只会出现在我们编写.ts文件时，当它给我们翻译成.js文件的时候还是会被赋值数值型的。</p>
<p><img src="./images/TypeScript 基础知识点整理6.png" alt="jizhi" /></p>
<p>可是上面代码我明明没有给它指定类型了，为什么还是报错呢？</p>
<p>这是因为TypeScript有一个类型推断机制，如果你一次给这个变量存储的是字符串值，它会规定你这个变量只能存储字符串值。</p>
<p><strong>如果想让一个变量又是字符串又是数值型；</strong></p>
<p>我们可以给这个变量赋值一个any类型，它代表这个变量可以存储任何类型的值；</p>
<p><img src="./images/TypeScript 基础知识点整理7.png" alt="any" /></p>
<p>除了string和any类型我们还有<br />
​ 1、number //数值<br />
​ 2、boolean //true||false<br />
​ 3、void //用来声明方法的返回值的void代表这个函数不需要返回值，你也可以给这个方法设置返回规定的类性。除了给方法设置类性外，我们也可以给方法的参数设置类型，规定必须传入的参数。</p>
<p><img src="./images/TypeScript 基础知识点整理8.png" alt="leixing" /></p>
<p>​ 4、自定义类型：</p>
<pre class="typescript"><code>class Person {
    name:string;
    age:number;
}
var zhangsan :Person = new Person();
zhangsan.name = &#39;zhangsan&#39;
zhangsan.age = 18;
//当你声明好Person类型后去调用会有语法提示你它当前有那些属性且他们的类性是什么。</code></pre>
<p><img src="./images/TypeScript 基础知识点整理9.png" alt="zdy" /></p>
<p><strong>如果你声明了一个变量，再声明一个同名函数会报错，</strong></p>
<p><img src="./images/TypeScript 基础知识点整理10.png" alt="tongming" /></p>
<hr />
<h3 id="默认参数">2、默认参数</h3>
<p><img src="./images/TypeScript 基础知识点整理11.png" alt="moren" /></p>
<p>这个时候我们可以给第三个形参设置一个默认值：<br />
<img src="./images/TypeScript 基础知识点整理12.png" alt="moren2" /></p>
<p><strong>切记，需要设置默认参数的形参从后面依次排列，因为传入的参数是从第一个开始匹配的</strong></p>
<p><img src="./images/TypeScript 基础知识点整理13.png" alt="moren3" /></p>
<hr />
<h3 id="可选参数">3、可选参数</h3>
<p>在方法的参数声明后面用<code>?</code>来标明此参数为可选参数</p>
<p><img src="./images/TypeScript 基础知识点整理14.png" alt="kexuan" /></p>
<p>这个时候运行会输出：<br />
<img src="./images/TypeScript 基础知识点整理15.png" alt="kxjg" /></p>
<p>使用可选参数要注意的有两点：<br />
​ 1.可选参数没传的时候怎么处理，b参数没有传入，但是如果我在函数体里面直接去调它的话会报错；<br />
​ 例子：<code>console.log(b.lenght)</code>//这种错误非常常见<strong>undefined不能打点</strong></p>
<p>​ 2.可选参数是不可以声明在必选参数的前面；<br />
<img src="./images/TypeScript 基础知识点整理16.png" alt="kxbc" /></p>
<hr />
<h2 id="五函数新特性">五、函数新特性</h2>
<h3 id="rest-and-spread-操作符">1、Rest and Spread 操作符</h3>
<h4 id="声明可以传入任意参数的方法主要">1.1声明可以传入任意参数的方法（主要）</h4>
<pre class="typescript"><code>function func1(...args) {//这个...就是Rest and Spread 操作符
    //用...声明的args参数可以传入任意数量的参数
    args.forEach(function (arg) {
        console.log(arg)
    })//args就是一个数组，它内部用的是arguments，可以去观察翻译后的.js文件。
};
func1(1,2,3);
func1(4,5,6,7,8);</code></pre>
<p>输出结果：<br />
<img src="./images/TypeScript 基础知识点整理17.png" alt="rsjg" /></p>
<h4 id="把任意长度的数组一个固定数量的方法的调用">1.2 把任意长度的数组一个固定数量的方法的调用</h4>
<pre class="typescript"><code>function func1(a,b,c) {
    console.log(a);//第一次传过来的是1,2没有第三个参数所以c是undefined
    console.log(b);//第二次传过来的是5,4,2,34,2但是我们只有a,b,c三个形参接受,所以只会拿取前三个。
    console.log(c);
};
var args = [1,2];
func1(...args);//这样的操作会把args数组里面的每一项给出来，当做实参传过去。
var args2 = [5,4,2,34,2];
func1(...args2);//因为TypeScript还不支持这种语法所以会报错,但是编译好的js文件可正常运行。</code></pre>
<p>运行编译后的js文件输出结果：<br />
<img src="./images/TypeScript 基础知识点整理18.png" alt="jieguo" /></p>
<hr />
<h3 id="generator函数">2、generator函数</h3>
<p>它可以控制函数的执行过程，手工暂停和恢复代码执行。</p>
<pre class="typescript"><code>function* get() {//在function和函数名中间加*就是generator函数
    console.log(&quot;start&quot;);
    yield;//yield会将函数打断停留不继续往下执行
    console.log(&quot;finish&quot;)
}
var func1 = get();//如果你直接去调用get函数是没用的，需要将它赋给一个变量。
func1.next();//通过调用.next()可以让函数执行。//输出start；
func1.next();//输出finish，//每次调用next会让函数执行且停留在下一个yield。</code></pre>
<p>因为这个语法TypeScript暂时还不支持，它是es6规范的一部分，所以我们用到了<a href="https://www.babeljs.cn/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=latest%2Creact%2Cstage-2&amp;experimental=false&amp;loose=false&amp;spec=false&amp;code=%5B1%2C2%2C3%5D.map(n%20%3D%3E%20n%20%2B%201)%3B&amp;playground=true">babel翻译</a>。</p>
<pre class="typescript"><code>function *get() {
    while (true) {//这个循环没有一直执行,只有下面price&gt;limit为true的时候才会执行
        yield Math.random()*100;
    }
}
var priceG = get();//拿到get的执行权
var limit = 15;//最低15
var price = 100;//起始100
while (price&gt;limit) {//如果低于15就停。
    price = priceG.next().value;//通过.value得到get函数中yield返回的随机数且赋值给price
    console.log(`${price}`)//输出yield返回的值
}
console.log(`${price}`);//如果拿到了小于15的数就会最后弹出</code></pre>
<p>输出结果：<br />
<img src="./images/TypeScript 基础知识点整理19.png" alt="babel" /></p>
<hr />
<h3 id="析构表达式">3、析构表达式</h3>
<p>通过表达式将对象或数组拆解成任意数量的变量。</p>
<h4 id="object">3.1 Object</h4>
<pre class="typescript"><code>function get() {
    return {
        xing:&#39;huo&#39;,
        age:18
    }
}
var {xing,age} = get();
//{}中的变量名要跟你函数返回对象中的属性名相同
//如果想改名字:{xingshi:xing,age}
//console.log(xingshi);//&#39;huo&#39;
console.log(xing);//&#39;huo&#39;
console.log(age);//18</code></pre>
<pre class="typescript"><code>function get() {
    return {
        xing:&#39;huo&#39;,
        yifu:{//如果你返回的又是一个对象
            kuzi:400,
            shangyi:200
        }
    }
}
          //那么我们可以再把里面的属性给析构
var {xing,yifu:{kuzi}} = get();
console.log(xing);//&#39;huo&#39;
console.log(kuzi);//400</code></pre>
<h4 id="array">3.2 Array</h4>
<pre class="typescript"><code>var arr1 = [1,2,3,4];
var [number1,number2] = arr1;
console.log(number1)//1
console.log(number2)//2
//如果要拿3和4
var [, , number1, number2] = arr1;
//站位,但是我不拿出来。
console.log(number1)//3
console.log(number2)//4
//如果要拿1和4
var [number1, , number2] = arr1;
console.log(number1)//1
console.log(number2)//4</code></pre>
<h4 id="析构表达式和rest操作符共用">3.2 析构表达式和Rest操作符共用</h4>
<pre class="typescript"><code>var arr1 = [1,2,3,4];
var [number1,number2,...shengyu] = arr1;
console.log(number1)//1
console.log(number2)//2
console.log(shengyu)//[3,4]</code></pre>
<pre class="typescript"><code>var arr1 = [1,2,3,4];
function test([number1, number2, ...shengyu]) {
    console.log(number1)//1
    console.log(number2)//2
    console.log(shengyu)//[3,4]
}
test(arr1);//类型“number[]”的参数不能赋给类型“[any, any, ...any[]]”的参数，但不影响我们使用。</code></pre>
<hr />
<h2 id="六表达式与循环">六、表达式与循环</h2>
<h3 id="箭头表达式">1、箭头表达式</h3>
<p>用来声明匿名函数，消除传统匿名函数的this指向问题。</p>
<p><code>var sum = (arg1,arg2) =&gt; arg1+arg2;</code>这就是最简单的一行箭头表达式。如果返回值只有一行的话可以省略{}也不需要写return方法。如果是多行的话是需要写{}的。</p>
<p><code>var sum = () =&gt; {}</code>如果没有参数的话是这样的写法。</p>
<p><code>var sum = arg =&gt; {return arg}</code>如果只有一个参数的话圆括号都可以省略。</p>
<p>例子：</p>
<pre class="typescript"><code>var myArray = [1,2,3,4,5,6];
console.log(myArray.filter(value =&gt; value%2 == 0))
//filter()是过虑的意思,()里面放的是表达式，如果取余2==0的话就返回，会得到[2,4,6]。</code></pre>
<p>箭头表达式最大的好处this指向：</p>
<pre class="typescript"><code>function get(name:string) {
    this.name = name;
    // setInterval(function () {
    //     console.log(&quot;name is&quot;+this.name);
    //     //什么都得不到因为this指向的是window
    // }, 1000);
    setInterval(() =&gt; {
        console.log(&quot;name is &quot; + this.name);
        //跟想得到的是一样的，因为this是它所处的上下文
    }, 1000);
}
var stock = new get(&quot;huo&quot;);</code></pre>
<hr />
<h3 id="循环">2、循环</h3>
<h4 id="foreach">1、forEach</h4>
<p><img src="./images/TypeScript 基础知识点整理20.png" alt="foreach" /></p>
<h4 id="for...in...">2、for...in...</h4>
<p><img src="./images/TypeScript 基础知识点整理21.png" alt="forin" /></p>
<p><img src="./images/TypeScript 基础知识点整理22.png" alt="forin2" /></p>
<h4 id="for...of...">3、for...of...</h4>
<p><img src="./images/TypeScript 基础知识点整理23.png" alt="forof" /></p>
<hr />
<h2 id="七面向对象特性">七、面向对象特性</h2>
<h3 id="类class">1、类(class)</h3>
<p>类是TypeScript的核心，使用TypeScript开发时，大部分代码都是写在类里面的。</p>
<p>这里会介绍类的定义，构造函数，以及类的继承。</p>
<pre class="typescript"><code>class People {//TypeScript声明类的方法
     name;//属性
     getName(){//方法
        console.log(&quot;huoqingchi&quot;);
    }
    //类拥有属性和方法
}
var p1 = new People();//我们通过new实例化了这个类，且赋值给了p1
p1.name = &quot;rope&quot;;
p1.getName();
//同样一个类我们可以new出多个实例，且这些实例都拥有相同的属性和方法，但是状态不同。
var p2 = new People();//我们可以在实例化一个类，且赋值给了p2
p2.name = &quot;scarf&quot;;
p2.getName();</code></pre>
<h4 id="访问控制符">访问控制符</h4>
<p>管理类的属性和方法可以在哪里调用，一共有三个，且带声明效果。</p>
<h5 id="public">1、public</h5>
<pre class="typescript"><code>class People {
     public name;
     public getName(){
        console.log(&quot;huoqingchi&quot;);
    }
    //public的属性和方法都是可以在类的内部||类的外部访问的,它也是默认的，不写也可以。
}</code></pre>
<h5 id="private">2、private</h5>
<p><img src="./images/TypeScript 基础知识点整理24.png" alt="fwkzf" /></p>
<h5 id="protected">3、protected</h5>
<p><img src="./images/TypeScript 基础知识点整理25.png" alt="protected" /></p>
<hr />
<h4 id="类的构造函数">类的构造函数</h4>
<pre class="typescript"><code>class People {
    constructor(){//类的构造函数就是它，一个特殊的方法。
        //这个方法会在这个类实例化的时候被执行。
        console.log(&quot;hhh&quot;)
    } 
}
var p1 = new People();//hhh</code></pre>
<p>用处：实例化一个人的时候必须为他指定一个名字等等。。</p>
<pre class="typescript"><code>//第一种写法
class People {
    name;//声明了一个name属性
    constructor(name:string){//这里接受实例化传来的值且设置参数类型
        this.name = name;//这里会访问上面声明的name属性且给他传入我们接收到的值
    };
    getName(){
        console.log(this.name);
    } 
}
var p1 = new People(&quot;rope&quot;);//在这里实例化的时候给constructor传入一个值
p1.getName();//rope</code></pre>
<pre class="typescript"><code>//第二种写法
class People {
    constructor(public name:string){//这里接受实例化传来的值且设置参数类型
        //这个写法会被People类创建一个name属性且把传入的值赋给它。
        //构造函数上需要明确的声明访问控制符
    };
    getName(){
        //如果构造函数中name没有声明访问控制符，People类里面也没有name属性。
        console.log(this.name);//所以这里是得不到的。
    } 
}
var p1 = new People(&quot;rope&quot;);//在这里实例化的时候给constructor传入一个值
p1.getName();//rope</code></pre>
<hr />
<h4 id="类的继承">类的继承</h4>
<h5 id="extends">1、extends</h5>
<p>通过extends关键字可以实现继承<br />
<img src="./images/TypeScript 基础知识点整理26.png" alt="extends" /></p>
<p>这个时候Student实例化的p1身上也拥有了People的属性和方法。</p>
<p>在Student类中的属性和方法People的实例是没有的。<br />
<img src="./images/TypeScript 基础知识点整理27.png" alt="extends" /></p>
<hr />
<h5 id="super">2、super</h5>
<p>第一个用法：调用父类的构造函数</p>
<pre class="typescript"><code>class People {
    constructor(public name:string){
        //这里是被下面的super调用了。
        //这个写法会被People类创建一个name属性且把传入的值赋给它。
        console.log(&quot;People&quot;)
    };
    getName(){
        console.log(this.name);
    } 
}
class Student extends People {
    constructor(name: string, public code:string){//实例化一个学生必须有名字和学号
         //这个写法会被Student类创建一个code属性且把传入的值赋给它。
        super(name);//通过super可以调用父类(People)的构造函数把name传过去了。
        console.log(&quot;Student&quot;)
    }
    getCode(){
        console.log(this.code);
        console.log(this.name)
    }
}
var p1 = new Student(&quot;huo&quot;,&quot;18&quot;)
p1.getCode()</code></pre>
<p>输出结果，注意顺序：<br />
<img src="./images/TypeScript 基础知识点整理28.png" alt="super" /></p>
<p>super调用People的构造函数→Student再执行→p1.getCode()再按顺序输出code和name。</p>
<hr />
<p>第二个用法：可以调用父类的其他方法</p>
<pre class="typescript"><code>class People {
    mifan(){
        console.log(&quot;吃米饭&quot;);
    } 
}
class Student extends People {
    chifan(){
        super.mifan();//直接通过super打点就可以调用父类的其他方法。
        this.xuexi();
    }
    private xuexi() {
        //这个方法本身是可以这在Student外部调用的，我想让他必须先吃饭再学习。
        //也就是只让他在Student内部被调用,所以给他设置了访问控制符。
        console.log(&quot;吃完米饭学习&quot;);
    }
}
var p1 = new Student();
p1.chifan();</code></pre>
<p>输出结果：<br />
<img src="./images/TypeScript 基础知识点整理29.png" alt="super2" /></p>
<hr />
<h3 id="泛型">2、泛型</h3>
<p>参数化的类型，一般来限制集合的内容。</p>
<pre class="typescript"><code>class People {
    constructor(public name:string){
    };
}
class Student extends People {
    constructor(name: string, public code:string){
        super(name);
    }
}
class Teacher extends People {
    constructor(name: string, public code: string) {
        super(name);
    }
}
var arr: Array&lt;People&gt; = [];//&lt;&gt;中就是规定我这个arr数组只能存放跟People类型一样的数据
arr[0] = new Student(&quot;huo&quot;, &quot;18&quot;);
arr[1] = new Teacher(&quot;huoqingchi&quot;, &quot;23&quot;);
console.log(arr)</code></pre>
<p>输出结果：<br />
<img src="./images/TypeScript 基础知识点整理30.png" alt="fanxing" /></p>
<p>如果你存放其他类型的数据会有警告：<br />
<img src="./images/TypeScript 基础知识点整理31.png" alt="fanxing2" /></p>
<hr />
<h3 id="接口">3、接口</h3>
<p>用来建立某种代码约定，使得其它开发者在调用某个方法或创建新的类时必须遵循接口所定义的代码约定。</p>
<p>第一中用法：作为一个方法的参数类型的声明</p>
<pre class="typescript"><code>//使用interface 来声明一个接口
interface jiekou {//接口的名字就交jiekou
    name:string;
    age:number;
}
class People{
    constructor(public consig: jiekou){//让接口作为一个方法的参数类型的声明

    }
}
var p1 = new People({
    //当你去调用这个方法的时候TypeScript会去检查你传过去的参数是否符合接口所约定的格式。
    name:&quot;huoqingchi&quot;,
    age:18
    //参数不能多也不能少，如果没有值可以填null。
})</code></pre>
<hr />
<p>第二种用法：用接口来声明方法。</p>
<pre class="typescript"><code>interface People {
    chi();//People接口有个吃饭的方法。
}
class Student implements People {
    //implements的意思是Student类实现People这个接口
    //也就是它必须实现这个接口里面的方法。
    chi(){
        console.log(&quot;我吃素的&quot;);
    }
}
class Teacter implements People {
    chi(){
        console.log(&quot;我吃肉的&quot;);
    }
}</code></pre>
<hr />
<h3 id="模块">4、模块</h3>
<p>模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的那些资源（类，方法，变量）暴露出去供外部使用，那些资源只能在模块内使用，<strong>一个文件就是一个模块</strong>。</p>
<p><code>./demo/ide/tscript/test.ts</code></p>
<pre class="typescript"><code>export var a = 10;//export是暴露出去的意思。
var b = 20;//没有暴露出去的就只能在这个模块中使用。
export function fn1() {
    console.log(&quot;我是fn1&quot;)
}
function fn2() {
    console.log(&quot;我是fn2&quot;)
}
export class CLazz1 {
    constructor() {
        console.log(&quot;我是CLazz1类&quot;)
    }
}
class CLazz2 {
    constructor() {
        console.log(&quot;我是CLazz2类&quot;)
    }
}</code></pre>
<p><code>./demo/ide/tscript/test2.ts</code></p>
<pre class="typescript"><code>import { a, fn1, CLazz1} from &#39;./test&#39;;
//import是导入的意思，from是从哪里导入，{}中是导入那些东西。
console.log(a);
console.log(fn1);
console.log(CLazz1);
//一个模块中既可以import导入也可以export
export function fn3() {
    console.log(&quot;我是fn3&quot;)
}</code></pre>
<p>输出结果：<br />
<img src="./images/TypeScript 基础知识点整理32.png" alt="import/export" /></p>
<hr />
<h3 id="注解">5、注解</h3>
<p>注解为程序的元素（类，方法，变量）加上更直观明了的说明，这些说明信息与程序的业务逻辑无关，而是供指定的工具或框架使用的。</p>
<pre class="typescript"><code>import {Component} from &#39;@angular/core&#39;;//这里是用的angular，后续会增加vue,react。
@Component({//这里就是注解
    selector:&#39;app-root&#39;,
    templaterUrl: &#39;./app.component.html&#39;,//加载到app.component.html页面中
    styleUrls:[&#39;./app.component.css&#39;]//加载app.component.css样式文件
})
export class AppComponent {//当你用angular加载这个类的时候它会执行上面的注解
    title = &quot;app works!&quot;;
}</code></pre>
<p><code>app.component.html</code></p>
<pre class="html"><code>&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;!--页面会显示app works!--&gt;</code></pre>
<hr />
<h3 id="类型定义文件.d.ts">6、类型定义文件（*.d.ts）</h3>
<p>类型定义文件用来帮助开发者在TypeScript中使用已有的JavaScript的工具包如:JQuery；</p>
<p>我们使用了<a href="https://github.com/typings/typings">typings</a>，<code>npm install -g typings</code>。</p>
<p><code>./demo/ide</code>在项目文件夹下。</p>
<p>打开CMD窗口运行<code>typings install dt~jquery --global</code>//这里是jquery举例，如果需要其它的记得更换。</p>
<p>其中”dt~”为使用DefinitelyTyped类型定义的意思，vscode可以识别这种定义。</p>
<p>没有安装之前：<br />
<img src="./images/TypeScript 基础知识点整理33.png" alt="jquery" /></p>
<p>安装之后：会自动生成typings文件夹<br />
<img src="./images/TypeScript 基础知识点整理34.png" alt="jquery2" /></p>
<hr />
<h2 id="结束语">结束语</h2>
<p>TypeScript的基础知识点我们就讲完了，后续根据反馈再整理更新。<br />
TypeScript的文档：http://www.typescriptlang.org/docs/home.html<br />
本人的博客：https://www.cnblogs.com/rope/<br />
本人的github：https://github.com/mufengsm<br />
本人的邮箱：scarf666@163.com</p>
<p>作者：Rope</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>