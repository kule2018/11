<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Wenaox  一款轻量性能好的微信小程序状态管理库' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Wenaox  一款轻量性能好的微信小程序状态管理库</center></div><div class='banquan'>原文出处:本文由博客园博主大树0211号提供。<br/>
原文连接:https://www.cnblogs.com/cnyball/p/11231007.html</div><br>
    <p>感慨一下！！！<br />
从开始开发 wenaox 从开始到现在，，时不时更新一下，改一改 bug，却发现已经快 1 年了 orz</p>
<p>虽然很少人用 hhh，但偶尔也会有人提一些问题，我就知道还有人用的~</p>
<p>感兴趣的朋友直接去 github 看<a href="https://github.com/phonycode/wenaox#wenaox">文档</a>吧（捂脸</p>
<p><a href="https://github.com/phonycode/wenaox#wenaox">点击我查看 wenaox 文档</a></p>
<p>不介意给个 star，鼓励下我(厚脸皮 ing)</p>
<p><strong>以下内容来自 wenaox 文档</strong></p>
<h1 id="wenaox">Wenaox</h1>
<p><a href="https://npmjs.org/package/wenaox"><img src="./images/Wenaox  一款轻量性能好的微信小程序状态管理库0.png" alt="NPM version" /></a></p>
<p><a href="https://npmjs.org/package/wenaox"><img src="./images/Wenaox  一款轻量性能好的微信小程序状态管理库1.png" alt="npm download" /></a></p>
<p>一个轻量性能好的微信小程序的状态管理库（已有多个线上项目）</p>
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#特点">特点</a></li>
<li><a href="#性能">性能</a></li>
<li><a href="#开始">开始</a>
<ul>
<li><a href="#安装">安装</a></li>
<li><a href="#实例化-store">实例化 store</a></li>
<li><a href="#在中大型小程序中的实践">在中大型小程序中的实践</a></li>
<li><a href="#在-app.js-中初始化">在 app.js 中初始化</a></li>
<li><a href="#创建页面">创建页面</a></li>
<li><a href="#在自定义组件中使用">在自定义组件中使用</a></li>
<li><a href="#跨页面同步数据">跨页面同步数据</a></li>
<li><a href="#支持中间件">支持中间件</a></li>
<li><a href="#支持小程序自定义的-tabbar-的数据更新">支持小程序自定义的 tabbar 的数据更新</a></li>
</ul></li>
<li><a href="#例子">例子</a></li>
<li><a href="#联系我">联系我</a></li>
<li><a href="#change-log">Change Log</a></li>
<li><a href="#开源协议">开源协议</a></li>
</ul>
<h2 id="前言">前言</h2>
<p>工作中在开发小程序的时候，发现组件间通讯或跨页通讯会把程序搞得混乱不堪，变得极难维护和扩展，setData 的性能不是很好，浪费很多的资源，所以封装了一个 wenaox 作为使用，后决定开源出来给大家使用<br />
如果觉得有什么问题或者建议，欢迎提 issue 和 pr，觉得不错，可以给个 star，鼓励一下 2333</p>
<h2 id="特点">特点</h2>
<ul>
<li>支持中间件</li>
<li>中大型项目可多个 contro 区分模块</li>
<li>asyncs 自带 loading</li>
<li>轻量、性能好</li>
</ul>
<h2 id="性能">性能</h2>
<ul>
<li>每次更新数据确保后台态页面停止刷新数据而在重新进入前台的时候开始</li>
<li>采取 diff 新旧数据，保证一次只更新最少量的数据</li>
</ul>
<h2 id="开始">开始</h2>
<h4 id="安装">安装</h4>
<p>虽然可以直接引入，但是建议使用 npm 安装开发，将会很方便</p>
<pre><code><code>npm i -S wenaox
or
yarn add wenaox</code></pre>
<blockquote>
<p>关于小程序如何<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html?search-key=npm">构建 npm</a></p>
</blockquote>
<h4 id="实例化-store">实例化 store</h4>
<p>新建一个 store.js</p>
<pre class="js"><code>import { Store, regeneratorRuntime } from &#39;wenaox&#39;;
//数据
const state = {
  count: 0,
};
//方法
const methods = {
  //修改state的方法(只允许通过syncs的方法进行修改)
  syncs: {
    addCount(state, payload) {
      state.count = state.count + 1;
    },
  },
  //包含副作用的方法
  asyncs: {
    asyncAddCount(payload, rootState) {
      setTimeout(() =&gt; {
        this.addCount(c);
      });
    },
  },
};
//注册store
const store = new Store({ state, methods });</code></pre>
<p>store 中的 state 和 methods 打印如下:</p>
<pre class="js"><code>{
  &quot;state&quot;: { &quot;count&quot;: 0 },
  &quot;methods&quot;: { &quot;addCount&quot;: fn, &quot;asyncAddCount&quot;: fn }
  //略
}</code></pre>
<h4 id="在中大型小程序中的实践">在中大型小程序中的实践</h4>
<p>在中大型小程序中的实践中，共享的状态和方法将会很多，如果全部都定义在一起会很混乱，所以提供一个多 contro 的机制，可以根据页面或者功能来进行划分</p>
<pre class="js"><code>// 下面是多 contro 的注册写法

 const store = new Store({ controA: { state, methods } });
</code></pre>
<p>将会 Store 对 store 的 state 和 methods 通过 contro 的变量名进行一个细化区分:</p>
<pre class="js"><code>{
  &quot;state&quot;: { &quot;controA&quot;: { &quot;count&quot;: 0 } },
  &quot;methods&quot;: { &quot;controA&quot;: { &quot;addCount&quot;: fn, &quot;asyncAddCount&quot;: fn } }
  //略
}</code></pre>
<h4 id="在-app.js-中初始化">在 app.js 中初始化</h4>
<pre class="js"><code>//app.js
import { Provider } from &#39;wenaox&#39;;
import store from &#39;xxx路径/store&#39;;

const appConfig = {
  //some config
};
App(Provider(store)(appConfig));</code></pre>
<h4 id="创建页面">创建页面</h4>
<p>-在 page.js 中连接 state 和 methods</p>
<pre class="js"><code>import { orm } from &#39;wenaox&#39;;

// 返回需要的state和methods
const mapState = state =&gt; ({
  count: state.count,
});
const mapMethods = methods =&gt; ({
  addCount: methods.addCount,
  asyncAddCount: methods.asyncAddCount,
});
const pageConfig = {
  //some config
};
// 使用orm连接
Page(orm(mapState, mapMethods)(pageConfig));
</code></pre>
<ul>
<li>在 page.wxml 中使用</li>
</ul>
<pre class="html"><code>&lt;view class=&quot;count&quot;&gt;count&lt;/view&gt;
&lt;button bindtap=&quot;addCount&quot;&gt;count + 1&lt;/button&gt;
&lt;button bindtap=&quot;asyncAddCount&quot;&gt;async count + 1&lt;/button&gt;</code></pre>
<p>点击按钮就会发生变化！一个简单的计数器！</p>
<h4 id="在自定义组件中使用">在自定义组件中使用</h4>
<p>由于小程序中的属性没有分辨组件还是 page 页面所以我另外写了一个对 自定义组件 的方法就是 ormComp</p>
<p>所以在自定义组件中使用的话仅仅只需要 js 中的 orm 替换成 ormComp 就可以了</p>
<pre class="js"><code>Component(ormComp(mapState, mapMethods)(compConfig));</code></pre>
<h4 id="跨页面同步数据">跨页面同步数据</h4>
<p>使用 wenaox 你不用关心跨页数据同步，任何地方的修改，都会同步到使用到的地方［仅限于正在显示的页面/组建］</p>
<p>这是因为 wenaox 在页面栈中 hide 的页面不执行更新，而是等待 onshow 事件才重新进行更新，这是为了更好的<strong>性能</strong>！</p>
<h4 id="支持-asyncawait-以及-laoding">支持 async/await 以及 laoding</h4>
<pre class="js"><code>const methods = {
  // ...略
  asyncs: {
    async asyncAddCount(payload, rootState) {
      await new Promise(resolve =&gt; {
        setTimeout(resolve, 2000);
      });
      this.addCount(1);
    },
  },
};</code></pre>
<p>而在使用 async/await 之后自动会生成一个 loading 变量</p>
<pre class="js"><code>{
  &quot;loading&quot;: state.loading.asyncAddCount
}</code></pre>
<p>可以在 mapState 中引入,<strong>再也不用手动写 loading 了!!</strong><br />
当然你不用的话,你不引入 对应的 loading 变量的话,wenaox 也不会再对 对应的 loading 进行更新,<strong>避免性能损失</strong></p>
<h4 id="支持中间件">支持中间件</h4>
<p>wenaox 为了方便,提供了中间件的一个开发和使用,下面是一个 wenaox 的一个 log 的中间件</p>
<p>保证流动完所有的中间件才进行更新数据</p>
<pre class="js"><code>const log = store =&gt; next =&gt; (fn, payload) =&gt; {
  console.group(&#39;改变前：&#39;, store.state);
  next(fn, payload);
  console.log(&#39;改变后：&#39;, store.state);
  console.groupEnd();
};</code></pre>
<h4 id="支持小程序自定义的-tabbar-的数据更新">支持小程序自定义的 tabbar 的数据更新</h4>
<p>小程序是可以自定义 tabbar 的,通过 wenaox 可以随时更改底部的 tab 的数量以及跳转的方法</p>
<p>所有的具体在下面的例子中也有展示</p>
<h2 id="例子">例子</h2>
<p><a href="https://github.com/phonycode/wenaox/tree/master/example/count">计数器</a></p>
<h2 id="联系我">联系我</h2>
<p><img width="200" src="./images/Wenaox  一款轻量性能好的微信小程序状态管理库2.png"></p>
<h2 id="change-log">Change Log</h2>
<ul>
<li>v1.1.0
<ul>
<li>[重构] data 直接绑定，增快速度</li>
<li>[不兼容] page 页中初始化 mapState 将不再提供 options 参数</li>
</ul></li>
<li>v1.0.0
<ul>
<li>[兼容] 自定义 tabbar 的 custom-tab-bar 组件的数据绑定</li>
<li>[修复] 由于 newState 导致的生命周期的重复</li>
</ul></li>
</ul>
<h2 id="开源协议">开源协议</h2>
<p><a href="https://github.com/phonycode/wenaox/blob/master/LICENSE">MIT</a></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>