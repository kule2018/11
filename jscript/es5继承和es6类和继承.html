<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修es5继承和es6类和继承' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>es5继承和es6类和继承</center></div><div class='banquan'>原文出处:本文由博客园博主waitklove提供。<br/>
原文连接:https://www.cnblogs.com/czkolve/p/10849226.html</div><br>
    <p>　　es6新增关键字class，代表类，其实相当于代替了es5的构造函数</p>
<p>　　　　通过构造函数可以创建一个对象实例，那么通过class也可以创建一个对象实列</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> es5 创建一个person 构造函数 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> person (name,age) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;"> 定义原型链上的方法sayholle </span><span style="color: #008000;">*/</span>
<span style="color: #008000;">/*</span><span style="color: #008000;"> 为什么要将方法定义在原型上，定义在原型上的方法，所有的实例对象都共享 
 不会出现没实列一个对象都重新创建一个这个方法 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
person.prototype.sayholle </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span><span style="color: #0000ff;">this</span>.name+' holle'+ <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
}

let person1 </span>= <span style="color: #0000ff;">new</span> person('czcz','23'<span style="color: #000000;">)
person1.sayholle()  </span><span style="color: #008000;">//</span><span style="color: #008000;">  czcz holle23</span>

<span style="color: #008000;">/*</span><span style="color: #008000;"> es6 使用class创建一个对象 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
class personclass {
    </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 实列对象时默认调用的方法 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    constructor (name,age) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
    }
    </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 定义一个方法，相对构造上述原型链上的方法 </span><span style="color: #008000;">*/</span><span style="color: #000000;">

    sayholle () {
        console.log(</span><span style="color: #0000ff;">this</span>.name+' holle'+ <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
    }
}
let person2 </span>= <span style="color: #0000ff;">new</span> personclass('czcz','26'<span style="color: #000000;">)
person2.sayholle()  </span><span style="color: #008000;">//</span><span style="color: #008000;">  czcz holle23</span></pre>
</div>
<p>　　es5中继承的方式</p>
<p>　　　　1原型链继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> es5原型链继承 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> person (name,age) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
}
person.prototype.sayholle </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span><span style="color: #0000ff;">this</span>.name+' holle'+ <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> child (sex) {
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
}
child.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> person();
child.prototype.hh </span>= 'ddd'<span style="color: #000000;">
let p </span>= <span style="color: #0000ff;">new</span> child('man'<span style="color: #000000;">)
console.log(p) </span><span style="color: #008000;">//</span> 
console.log(<span style="color: #0000ff;">new</span><span style="color: #000000;"> person());
let p2 </span>= <span style="color: #0000ff;">new</span> child('man'<span style="color: #000000;">)
p2.__proto__.age </span>= '36'
<span style="color: #008000;">/*</span><span style="color: #008000;"> 给p2原型上的age赋值，则导致p上的age也改变，父类构造函数上的属性被所有子类共享 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
console.log(p) </span><span style="color: #008000;">//</span><span style="color: #008000;"> 36</span><span style="color: #008000;">
/*</span><span style="color: #008000;"> 缺点，child 新增的属性只能在new person 以后，创建实列时无法向
    父类的构造函数传送参数，因为直接是指定了原型，所有也不能实现多继承
    父类构造函数上的属性被所有子类共享
</span><span style="color: #008000;">*/</span></pre>
</div>
<p>　　　　2.构造函数继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> es5构造函数继承 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> person (name,age) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
}
person.prototype.sayholle </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span><span style="color: #0000ff;">this</span>.name+' holle'+ <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> child (sex,name,age) {
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex
    person.call(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">,name,age)
}

let p </span>= <span style="color: #0000ff;">new</span> child('man','czklove','13'<span style="color: #000000;">)
console.log(p);
</span><span style="color: #008000;">/*</span><span style="color: #008000;"> 
    可以是先多继承，只要执行多个call
    创建实列时能像父类构造函数船体参数
    不会出现父类属性，所有子类构造函数共享
    缺点，
    不能继承父类原型链上的方法，如上面不能掉用sayholle方法
    子类构造函数的实列，原型链上并不存在父类构造函数，
    因为不能继承父类原型链上的函数，所有要继承函数只能定义在父类构造函数上，
    不能达到函数复用
 </span><span style="color: #008000;">*/</span></pre>
</div>
<p>　　　　3.组合继承，融合了上面两种方式</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> es5组合继承 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> person (name,age) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
}
person.prototype.sayholle </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span><span style="color: #0000ff;">this</span>.name+' holle'+ <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> child (sex,name,age) {
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex
    person.call(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">,name,age)
}
child.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> person();
</span><span style="color: #008000;">/*</span><span style="color: #008000;"> 重新设置一下constructor 不设置也没有影响，严谨的角度上来说还是设置一下</span><span style="color: #008000;">*/</span>
<span style="color: #008000;">/*</span><span style="color: #008000;"> 不设置的话，__proto__ 上时没有 constructor </span><span style="color: #008000;">*/</span>
<span style="color: #008000;">/*</span><span style="color: #008000;"> 正常来讲constructor是指向自身的 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
child.prototype.constructor </span>=<span style="color: #000000;"> child;
let p </span>= <span style="color: #0000ff;">new</span> child('man','czklove','13'<span style="color: #000000;">)
let p1 </span>= <span style="color: #0000ff;">new</span> child('man','czklove1','16'<span style="color: #000000;">)
p.sayholle(); </span><span style="color: #008000;">//</span><span style="color: #008000;"> czklove holle13</span>
<span style="color: #000000;">console.log(p);<br /></span></pre>
<ol class="tree-outline hide-selection-when-blurred source-code object-properties-section">
<li class="parent object-properties-section-root-element expanded"><span class="console-object console-object-preview"><span class="object-description">child&nbsp;<span class="object-properties-preview">{<span class="name">sex: <span class="object-value-string">"man", <span class="name">name: <span class="object-value-string">"czklove", <span class="name">age: <span class="object-value-string">"13"}</span></span></span></span></span></span></span></span></span></li>
<ol class="children expanded">
<li><span class="name-and-value"><span class="name">age:&nbsp;<span class="object-value-string value"><span class="object-value-string-quote">"13<span class="object-value-string-quote">"</span></span></span></span></span></li>
<li><span class="name-and-value"><span class="name">name:&nbsp;<span class="object-value-string value"><span class="object-value-string-quote">"czklove<span class="object-value-string-quote">"</span></span></span></span></span></li>
<li><span class="name-and-value"><span class="name">sex:&nbsp;<span class="object-value-string value"><span class="object-value-string-quote">"man<span class="object-value-string-quote">"</span></span></span></span></span></li>
<li class="parent expanded"><span class="name-and-value"><span class="name object-properties-section-dimmed">__proto__:&nbsp;<span class="value object-value-object">person</span></span></span></li>
<ol class="children expanded">
<li><span class="name-and-value"><span class="name">age:&nbsp;<span class="object-value-undefined value">undefined</span></span></span></li>
<li class="parent"><span class="name-and-value"><span class="name">constructor:&nbsp;<span class="object-value-function value"><span class="object-value-function-prefix">&fnof;&nbsp;child(sex,name,age)</span></span></span></span></li>
<li><span class="name-and-value"><span class="name">name:&nbsp;<span class="object-value-undefined value">undefined</span></span></span></li>
<li class="parent selected"><span class="name-and-value"><span class="name object-properties-section-dimmed">__proto__:&nbsp;<span class="object-value-object value">Object</span></span></span></li>
</ol></ol></ol>
<pre><code></pre>
<div>
<div>　　　　/*</div>
<div>　　　　组合继承，既能达到对父类属性的继承，也能继承父类原型上的方法</div>
<div>　　　　父类属性继承也不会在所有子类的实列上共享</div>
<div>　　　　唯一缺点，子类原型上有父类构造函数的属性，也就是多了一份属性</div>
<div>　　　　*/</div>
</div>
<pre><code><span style="color: #000000;">
console.log(p.__proto__ </span>=== child.prototype) <span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p>　　　　4.优化版的组合继承（寄生组合继承）</p>
<div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> es5寄生组合继承 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> person (name,age) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
}
person.prototype.sayholle </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span><span style="color: #0000ff;">this</span>.name+' holle'+ <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> child (sex,name,age) {
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex
    person.call(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">,name,age)
}
child.prototype </span>=<span style="color: #000000;"> Object.create(person.prototype);
child.prototype.constructor </span>=<span style="color: #000000;"> child
let p </span>= <span style="color: #0000ff;">new</span> child('man','czklove','13'<span style="color: #000000;">)
p.sayholle(); </span><span style="color: #008000;">//</span><span style="color: #008000;"> czklove holle13</span>
<span style="color: #000000;">console.log(p);
</span><span style="color: #008000;">/*</span><span style="color: #008000;">  child {sex: "man", name: "czklove", age: "13"}
    age: "13"
    name: "czklove"
    sex: "man"
    __proto__: person
    constructor: &fnof; child(sex,name,age)
    __proto__:
    sayholle: &fnof; ()
    constructor: &fnof; person(name,age)
    __proto__: Object </span><span style="color: #008000;">*/</span></pre>
</div>
<p>　　es6 class</p>
<p>　　　　1.1class 内部都是严格模式</p>
<p>　　　　1.2class 不存在变量提升</p>
<p>　　　　1.3 class 的 name属性</p>
<p>　　　　1.4 实现symbol.iterator 接口，可以使用for of 遍历属性</p>
<p>　　　　1.5this 指向实例内部</p>
<p>　　关于class的基本介绍，去阮一峰老师的es6入门看就行&nbsp;http://es6.ruanyifeng.com/#docs/class</p>
<p>&nbsp;</p>
<p>　　es6 class的继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> esl class </span><span style="color: #008000;">*/</span><span style="color: #000000;">
class person {
    constructor (name,age) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
    }
    syaholle () {
        console.log(</span><span style="color: #0000ff;">this</span>.name+ ' holle '+<span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
    }
}

class child extends person {
    constructor (name,age,sex) {
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">  执行父类的构造函数 
            子类必须在构造函数中掉用super
            </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        super(name,age)
        </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 使用this一定要在super 之后 </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex
    }
}

let p </span>= <span style="color: #0000ff;">new</span> child('czklove','23','man'<span style="color: #000000;">)
console.log(p)
</span><span style="color: #008000;">/*</span><span style="color: #008000;">  child {name: "czklove", age: "23", sex: "man"}
    age: "23"
    name: "czklove"
    sex: "man"
    __proto__: person
    constructor: class child
    __proto__:
    constructor: class person
    syaholle: &fnof; syaholle()
    __proto__: Object </span><span style="color: #008000;">*/</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> esl class </span><span style="color: #008000;">*/</span><span style="color: #000000;">
class person {
    constructor (name,age) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age
    }
    syaholle () {
        console.log(</span><span style="color: #0000ff;">this</span>.name+ ' holle '+<span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
    }
}

class child extends person {
    constructor (name,age,sex) {
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">  执行父类的构造函数 
            子类必须在构造函数中掉用super
            </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        super(name,age)
        </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 使用this一定要在super 之后 </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex
    }
}

let p </span>= <span style="color: #0000ff;">new</span> child('czklove','23','man'<span style="color: #000000;">)
console.log(p)
</span><span style="color: #008000;">/*</span><span style="color: #008000;">  child {name: "czklove", age: "23", sex: "man"}
    age: "23"
    name: "czklove"
    sex: "man"
    __proto__: person
    constructor: class child
    __proto__:
    constructor: class person
    syaholle: &fnof; syaholle()
    __proto__: Object </span><span style="color: #008000;">*/</span></pre>
</div>
<p>　　es6 class 还涉及到很多东西，</p>
<p>　　　　　　1.静态方法</p>
<p>　　　　　　2.this指向</p>
<p>　　　　　　3.super 关键字的具体使用</p>
<p>　　　　　　4.类的prototype属性，构造函数的__proto__</p>
<p>　　　　　　5.原生构造函数的继承，如Array的继承，Boolean,Number,String Date...</p>
<p>　　基础简单的这里就不说了</p>
<p>　　我们再看以下原生构造函数的继承</p>
<p>　　　　es5中是不允许原生构造函数的继承的</p>
<p>　　</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">  es5为什么不能对原生构造函数的继承
    通过es5继承我们知道，继承父类构造属性是通过person.call(this,argument)
    (es6)
    是因为子类无法获得原生构造函数的内部属性，
    通过Array.apply()或者分配给原型对象都不行。
    原生构造函数会忽略apply方法传入的this，也就是说，
    原生构造函数的this无法绑定，导致拿不到内部属性
</span><span style="color: #008000;">*/</span>
<span style="color: #008000;">/*</span><span style="color: #008000;"> es6 使用class继承原生 </span><span style="color: #008000;">*/</span><span style="color: #000000;">

class myarray extends Array {
    constructor(...argus) {
        super(...argus)
    }
}

let arrays </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> myarray();
arrays[</span>0] = 'czklove'<span style="color: #000000;">;
console.log(arrays);
arrays.length </span>= 0<span style="color: #000000;">
console.log(arrays);

</span><span style="color: #008000;">/*</span><span style="color: #008000;">  输出
    myarray&nbsp;["czklove"]
    myarray&nbsp;[] </span><span style="color: #008000;">*/</span></pre>
</div>
<p>　　注，es6对object构造函数的继承，不能传参，传参数无效</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">class newobjext extends Object {
    constructor() {
        super(...arguments)
    }
}
let o </span>= <span style="color: #0000ff;">new</span> newobjext({name: 'czklove'<span style="color: #000000;">})
console.log(o.name); </span><span style="color: #008000;">//</span><span style="color: #008000;"> undefined</span></pre>
</div>
<p>　　总结，</p>
<p>　　　　es5的继承</p>
<p>　　　　1.1原型链继承</p>
<p>　　　　1.2 构造函数继承</p>
<p>　　　　1.3组合继承</p>
<p>　　　　1.4寄生组合继承</p>
<p>　　　　es6 的 extends&nbsp; 继承</p>
<p>　　　　super 关键字的使用，新增的静态字段使用，支持对原生构造函数的继承，对object继承的差异</p>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>