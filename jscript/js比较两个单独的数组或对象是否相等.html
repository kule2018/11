<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修js比较两个单独的数组或对象是否相等' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>js比较两个单独的数组或对象是否相等</center></div><div class='banquan'>原文出处:本文由博客园博主消逝的风i提供。<br/>
原文连接:https://www.cnblogs.com/abc-x/p/10780464.html</div><br>
    <p><span style="font-size: 14px; color: #000000;">所谓js的中的传值,其实也就是说<span>5种基本数据类型(<span>null,undefind,boolean,number,<span>string) </span></span></span></span></p>
<p><span style="font-size: 14px; color: #000000;"><span><span><span>传引用也就是说的那个引用数据类型,(<span>array和object) </span></span></span></span></span></p>
<p><span style="font-size: 14px; color: #000000;"><span><span><span><span>基本数据类型的值不可变,而引用数据类型的值是可变的 </span></span></span></span></span></p>
<p><span style="font-size: 14px; color: #000000;"><span><span><span><span>所以当你比较数组和对象时,都是<span>false;除非你是克隆的原份数据 </span></span></span></span></span></span></p>
<p><span style="font-size: 14px; color: #000000;"><span><span><span><span><span>即: <span>var a <span>= { name: <span>"李四" }; <span>var b <span>= a; </span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 14px; color: #000000;"><span><span><span><span><span><span><span><span><span><span>大家通常称对象为引用类型,以此来和基本类型进行区分; 而对象值都是引用,所以的对象的比较也叫引用的比较,当且当他们都指向同一个引用时,即都引用的同一个基对象时,它们才相等<span>.</span></span></span></span></span></span></span></span></span></span></span></span></p>
<h3>1.比较两个单独的数组是否相等</h3>
<div class="cnblogs_code">
<pre><code>JSON.stringify(a1) == JSON.stringify(a2)</pre>
</div>
<p>或</p>
<div class="cnblogs_code">
<pre><code>a1.toString() == a2.toString()</pre>
</div>
<p>要判断2个数组是否相同，把数组转换成字符串进行比较。</p>
<p>如果要比较两个数组的元素是否相等，则：</p>
<div class="cnblogs_code">
<pre><code>JSON.stringify([1,2,3].sort()) === JSON.stringify([3,2,1].sort());</pre>
</div>
<p>或</p>
<div class="cnblogs_code">
<pre><code>[1,2,3].sort().toString() === [3,2,1].sort().toString();</pre>
</div>
<p>判断2个数组是否相同，首先要把数组进行排序，然后转换成字符串进行比较。</p>
<h3>2.比较两个单独的对象是否相等</h3>
<div class="cnblogs_code">
<pre><code>let cmp = ( x, y ) =&gt;<span style="color: #000000;"> {
</span><span style="color: #008000;">//</span><span style="color: #008000;"> If both x and y are null or undefined and exactly the same</span>
    <span style="color: #0000ff;">if</span> ( x ===<span style="color: #000000;"> y ) {
      </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
</span><span style="color: #008000;">//</span><span style="color: #008000;"> If they are not strictly equal, they both need to be Objects</span>
    <span style="color: #0000ff;">if</span> ( ! ( x <span style="color: #0000ff;">instanceof</span> Object ) || ! ( y <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Object ) ) {
      </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
</span><span style="color: #008000;">//</span><span style="color: #008000;">They must have the exact same prototype chain,the closest we can do is</span><span style="color: #008000;">
//</span><span style="color: #008000;">test the constructor.</span>
    <span style="color: #0000ff;">if</span> ( x.constructor !==<span style="color: #000000;"> y.constructor ) {
      </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">for</span> ( <span style="color: #0000ff;">var</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> x ) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">Inherited properties were tested using x.constructor === y.constructor</span>
      <span style="color: #0000ff;">if</span><span style="color: #000000;"> ( x.hasOwnProperty( p ) ) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Allows comparing x[ p ] and y[ p ] when set to undefined</span>
        <span style="color: #0000ff;">if</span> ( !<span style="color: #000000;"> y.hasOwnProperty( p ) ) {
          </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> If they have the same strict value or identity then they are equal</span>
        <span style="color: #0000ff;">if</span> ( x[ p ] ===<span style="color: #000000;"> y[ p ] ) {
          </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Numbers, Strings, Functions, Booleans must be strictly equal</span>
        <span style="color: #0000ff;">if</span> ( <span style="color: #0000ff;">typeof</span>( x[ p ] ) !== "object"<span style="color: #000000;"> ) {
          </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Objects and Arrays must be tested recursively</span>
        <span style="color: #0000ff;">if</span> ( !<span style="color: #000000;"> Object.equals( x[ p ], y[ p ] ) ) {
          </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
      }
    }
    </span><span style="color: #0000ff;">for</span> ( p <span style="color: #0000ff;">in</span><span style="color: #000000;"> y ) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> allows x[ p ] to be set to undefined</span>
      <span style="color: #0000ff;">if</span> ( y.hasOwnProperty( p ) &amp;&amp; !<span style="color: #000000;"> x.hasOwnProperty( p ) ) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
      }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
};</span></pre>
</div>
<p>下面是StackOverflow大神封装的方法，可以学习一下：</p>
<p>1.比较数组</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Warn if overriding existing method</span>
<span style="color: #0000ff;">if</span><span style="color: #000000;">(Array.prototype.equals)
    console.warn(</span>"Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code."<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> attach the .equals method to Array's prototype to call it on any array</span>
Array.prototype.equals = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (array) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> if the other array is a falsy value, return</span>
    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">array)
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> compare lengths - can save a lot of time </span>
    <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.length !=<span style="color: #000000;"> array.length)
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0, l = <span style="color: #0000ff;">this</span>.length; i &lt; l; i++<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Check if we have nested arrays</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>[i] <span style="color: #0000ff;">instanceof</span> Array &amp;&amp; array[i] <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Array) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> recurse into the nested arrays</span>
            <span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">[i].equals(array[i]))
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;       
        }           
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>[i] !=<span style="color: #000000;"> array[i]) { 
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Warning - two different object instances will never be equal: {x:20} != {x:20}</span>
            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;   
        }           
    }       
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> Hide method from for-in loops</span>
Object.defineProperty(Array.prototype, "equals", {enumerable: <span style="color: #0000ff;">false</span>});</pre>
</div>
<p>2.比较对象</p>
<div class="cnblogs_code">
<pre><code>Object.prototype.equals = <span style="color: #0000ff;">function</span><span style="color: #000000;">(object2) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">For the first loop, we only check for types</span>
    <span style="color: #0000ff;">for</span> (propName <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Check for inherited methods and properties - like .equals itself</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">Return false if the return value is different</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.hasOwnProperty(propName) !=<span style="color: #000000;"> object2.hasOwnProperty(propName)) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Check instance type</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> <span style="color: #0000ff;">this</span>[propName] != <span style="color: #0000ff;">typeof</span><span style="color: #000000;"> object2[propName]) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Different types =&gt; not equal</span>
            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Now a deeper check using other objects property names</span>
    <span style="color: #0000ff;">for</span>(propName <span style="color: #0000ff;">in</span><span style="color: #000000;"> object2) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">We must check instances anyway, there may be a property that only exists in object2</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">I wonder, if remembering the checked values from the first loop would be faster or not </span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.hasOwnProperty(propName) !=<span style="color: #000000;"> object2.hasOwnProperty(propName)) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> <span style="color: #0000ff;">this</span>[propName] != <span style="color: #0000ff;">typeof</span><span style="color: #000000;"> object2[propName]) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">If the property is inherited, do not check any more (it must be equa if both objects inherit it)</span>
        <span style="color: #0000ff;">if</span>(!<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasOwnProperty(propName))
          </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">Now the detail check and recursion</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">This returns the script back to the array comparing</span>
        <span style="color: #008000;">/*</span><span style="color: #008000;">*REQUIRES Array.equals*</span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>[propName] <span style="color: #0000ff;">instanceof</span> Array &amp;&amp; object2[propName] <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Array) {
                   </span><span style="color: #008000;">//</span><span style="color: #008000;"> recurse into the nested arrays</span>
           <span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">[propName].equals(object2[propName]))
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>[propName] <span style="color: #0000ff;">instanceof</span> Object &amp;&amp; object2[propName] <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Object) {
                   </span><span style="color: #008000;">//</span><span style="color: #008000;"> recurse into another objects</span>
                   <span style="color: #008000;">//</span><span style="color: #008000;">console.log("Recursing to compare ", this[propName],"with",object2[propName], " both named \""+propName+"\"");</span>
           <span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">[propName].equals(object2[propName]))
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Normal value comparison for strings and numbers</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>[propName] !=<span style="color: #000000;"> object2[propName]) {
           </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">If everything passed, let's say YES</span>
    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>