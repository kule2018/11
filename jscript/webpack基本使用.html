<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修webpack基本使用' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>webpack基本使用</center></div><div class='banquan'>原文出处:本文由博客园博主跌倒的小黄瓜提供。<br/>
原文连接:https://www.cnblogs.com/ygjzs/p/11854032.html</div><br>
    <h2 id="webpack安装时的坑">webpack安装时的坑</h2>
<p><strong>高版本的webpack除了全局安装webpack外，还需安装webpack-cli，在本地使用时也一样需要这样，不然会出错</strong></p>
<h2 id="webpack使用是的坑">webpack使用是的坑</h2>
<p><strong>在原始启动webpack编译时不要忘了加-o，在原始文件和要编译成为的文件目录中间</strong><br />
<strong>要正常使用（方便使用）就要在package.json中配置<code>&quot;dev2&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot;,</code></strong></p>
<h2 id="devdependencies和dependencies的区别">devDependencies和dependencies的区别</h2>
<p>-D对应devDependencies，代表打包时使用，实际上线不会使用</p>
<h2 id="webpack使用">webpack使用</h2>
<p>webpack使得index.html中不用引入文件</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;!-- 注意： 不推荐直接在这里引用任何包和任何CSS文件 --&gt;

  &lt;!-- 因为 main 中的代码，涉及到了ES6的新语法，但是浏览器不识别 --&gt;
  &lt;!-- &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;!-- 通过 webpack 这么一个前端构建工具， 把 main.js 做了一下处理，生成了一个 bundle.js 的文件 --&gt;
  &lt;!-- &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; --&gt;

  &lt;!-- 当使用 html-webpack-plugin 之后，我们不再需要手动处理 bundle.js 的引用路径了，因为 这个插件，已经帮我们自动 创建了一个 合适的 script , 并且，引用了 正确的路径 --&gt;
  &lt;!-- &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt; --&gt;

  &lt;!-- css 或发起二次请求，不推荐这么搞 --&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt; --&gt;

&lt;/head&gt;

&lt;body&gt;
  &lt;ul&gt;
    &lt;li&gt;这是第1个li&lt;/li&gt;
    &lt;li&gt;这是第2个li&lt;/li&gt;
    &lt;li&gt;这是第3个li&lt;/li&gt;
    &lt;li&gt;这是第4个li&lt;/li&gt;
    &lt;li&gt;这是第5个li&lt;/li&gt;
    &lt;li&gt;这是第6个li&lt;/li&gt;
    &lt;li&gt;这是第7个li&lt;/li&gt;
    &lt;li&gt;这是第8个li&lt;/li&gt;
    &lt;li&gt;这是第9个li&lt;/li&gt;
    &lt;li&gt;这是第10个li&lt;/li&gt;
  &lt;/ul&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<pre class="json"><code>{
  &quot;name&quot;: &quot;webpack-study&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;dev2&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;jquery&quot;: &quot;^3.2.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;css-loader&quot;: &quot;^0.28.7&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;less&quot;: &quot;^2.7.3&quot;,
    &quot;less-loader&quot;: &quot;^4.0.5&quot;,
    &quot;node-sass&quot;: &quot;^4.5.3&quot;,
    &quot;sass-loader&quot;: &quot;^6.0.6&quot;,
    &quot;style-loader&quot;: &quot;^0.19.0&quot;,
    &quot;webpack&quot;: &quot;^3.8.1&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.9.3&quot;
  }
}
</code></pre>
<p>webpack.config.js(名字不要变)</p>
<pre class="javascript"><code>const path = require(&#39;path&#39;)
// 启用热更新的 第2步
const webpack = require(&#39;webpack&#39;)
// 导入在内存中生成 HTML 页面的 插件
// 只要是插件，都一定要 放到 plugins 节点中去
// 这个插件的两个作用：
//  1. 自动在内存中根据指定页面生成一个内存的页面
//  2. 自动，把打包好的 bundle.js 追加到页面中去
const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

// 这个配置文件，起始就是一个 JS 文件，通过 Node 中的模块操作，向外暴露了一个 配置对象
module.exports = {
  // 大家已经学会了举一反4， 大家觉得，在配置文件中，需要手动指定 入口 和 出口
  entry: path.join(__dirname, &#39;./src/main.js&#39;),// 入口，表示，要使用 webpack 打包哪个文件
  output: { // 输出文件相关的配置
    path: path.join(__dirname, &#39;./dist&#39;), // 指定 打包好的文件，输出到哪个目录中去
    filename: &#39;bundle.js&#39; // 这是指定 输出的文件的名称
  },
  devServer: { // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些
    //  --open --port 3000 --contentBase src --hot
    open: true, // 自动打开浏览器
    port: 3000, // 设置启动时候的运行端口
    contentBase: &#39;src&#39;, // 指定托管的根目录
    hot: true // 启用热更新 的 第1步
  },
  plugins: [ // 配置插件的节点
    new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步
    new htmlWebpackPlugin({ // 创建一个 在内存中 生成 HTML  页面的插件
      template: path.join(__dirname, &#39;./src/index.html&#39;), // 指定 模板页面，将来会根据指定的页面路径，去生成内存中的 页面
      filename: &#39;index.html&#39; // 指定生成的页面的名称
    })
  ],
  module: { // 这个节点，用于配置 所有 第三方模块 加载器 
    rules: [ // 所有第三方模块的 匹配规则
      { test: /\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] }, //  配置处理 .css 文件的第三方loader 规则
      { test: /\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] }, //配置处理 .less 文件的第三方 loader 规则
      { test: /\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] }, // 配置处理 .scss 文件的 第三方 loader 规则
    ]
  }
}

// 当我们在 控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步：
//  1. 首先，webpack 发现，我们并没有通过命令的形式，给它指定入口和出口
//  2. webpack 就会去 项目的 根目录中，查找一个叫做 `webpack.config.js` 的配置文件
//  3. 当找到配置文件后，webpack 会去解析执行这个 配置文件，当解析执行完配置文件后，就得到了 配置文件中，导出的配置对象
//  4. 当 webpack 拿到 配置对象后，就拿到了 配置对象中，指定的 入口  和 出口，然后进行打包构建；</code></pre>
<pre class="javascript"><code>// 这是 main.js 是我们项目的JS入口文件

// 1. 导入 Jquery
// import *** from *** 是ES6中导入模块的方式
// 由于 ES6的代码，太高级了，浏览器解析不了，所以，这一行执行会报错
import $ from &#39;jquery&#39;
// const $ = require(&#39;jquery&#39;)

// 使用 import 语法，导入 CSS样式表
import &#39;./css/index.css&#39;
import &#39;./css/index.less&#39;
import &#39;./css/index.scss&#39;
// 注意： webpack, 默认只能打包处理 JS 类型的文件，无法处理 其它的非 JS 类型的文件；
// 如果要处理 非JS类型的文件，我们需要手动安装一些 合适 第三方 loader 加载器；
// 1. 如果想要打包处理 css 文件，需要安装 cnpm i style-loader css-loader -D
// 2. 打开 webpack.config.js 这个配置文件，在 里面，新增一个 配置节点，叫做 module, 它是一个对象；在 这个 module 对象身上，有个 rules 属性，这个 rules 属性是个 数组；这个数组中，存放了，所有第三方文件的 匹配和 处理规则；


// 注意： webpack 处理第三方文件类型的过程：
// 1. 发现这个 要处理的文件不是JS文件，然后就去 配置文件中，查找有没有对应的第三方 loader 规则
// 2. 如果能找到对应的规则， 就会调用 对应的 loader 处理 这种文件类型；
// 3. 在调用loader 的时候，是从后往前调用的；
// 4. 当最后的一个 loader 调用完毕，会把 处理的结果，直接交给 webpack 进行 打包合并，最终输出到  bundle.js 中去




$(function () {
  $(&#39;li:odd&#39;).css(&#39;backgroundColor&#39;, &#39;yellow&#39;)
  $(&#39;li:even&#39;).css(&#39;backgroundColor&#39;, function () {
    return &#39;#&#39; + &#39;D97634&#39;
  })
})


// 经过刚才的演示，Webpack 可以做什么事情？？？
// 1. webpack 能够处理 JS 文件的互相依赖关系；
// 2. webpack 能够处理JS的兼容问题，把 高级的、浏览器不是别的语法，转为 低级的，浏览器能正常识别的语法

// 刚才运行的命令格式：    webpack  要打包的文件的路径  打包好的输出文件的路径



// 使用 webpack-dev-server 这个工具，来实现自动打包编译的功能
// 1. 运行 npm i webpack-dev-server -D 把这个工具安装到项目的本地开发依赖
// 2. 安装完毕后，这个 工具的用法， 和 webpack 命令的用法，完全一样
// 3. 由于，我们是在项目中，本地安装的 webpack-dev-server ， 所以，无法把它当作 脚本命令，在powershell 终端中直接运行；（只有那些 安装到 全局 -g 的工具，才能在 终端中正常执行）
// 4. 注意： webpack-dev-server 这个工具，如果想要正常运行，要求，在本地项目中，必须安装 webpack
// 5. webpack-dev-server 帮我们打包生成的 bundle.js 文件，并没有存放到 实际的 物理磁盘上；而是，直接托管到了 电脑的内存中，所以，我们在 项目根目录中，根本找不到 这个打包好的 bundle.js;
// 6. 我们可以认为， webpack-dev-server 把打包好的 文件，以一种虚拟的形式，托管到了 咱们项目的 根目录中，虽然我们看不到它，但是，可以认为， 和 dist  src   node_modules  平级，有一个看不见的文件，叫做 bundle.js</code></pre>
<p><strong>实际使用中less，scss等除上述编译器使用一个即可</strong><br />
<strong>完成以上操作使用npm run dev实现自动刷新，自动跳转到浏览器</strong></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>