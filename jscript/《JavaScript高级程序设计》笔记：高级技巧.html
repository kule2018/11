<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修《JavaScript高级程序设计》笔记：高级技巧' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>《JavaScript高级程序设计》笔记：高级技巧</center></div><div class='banquan'>原文出处:本文由博客园博主风雨后见彩虹提供。<br/>
原文连接:https://www.cnblogs.com/moqiutao/p/10244231.html</div><br>
    <h2>高级函数</h2>
<h3>安全的类型检测</h3>
<p>在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个[[Class]]属性，这个属性就指定了上述字符串中的构造函数名。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> arr =<span style="color: #000000;"> [];
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){
    
}
</span><span style="color: #0000ff;">var</span> reg = /^\d/<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> json =<span style="color: #000000;"> {
    </span>"name":"Jack"<span style="color: #000000;">,
    </span>"age":20<span style="color: #000000;">
,}
console.log(Object.prototype.toString.call(arr) </span>== "[object Array]");  <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(Object.prototype.toString.call(fn) == "[object Function]"); <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(Object.prototype.toString.call(reg) == "[object RegExp]");  <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(window.JSON &amp;&amp; Object.prototype.toString.call(json) == "[object Object]"); <span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<h3>作用域安全的构造函数</h3>
<p>作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是，会创建新的实例并返回，如下例子：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age,job){
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span> <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Person){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
        </span><span style="color: #0000ff;">this</span>.job =<span style="color: #000000;"> job;
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person(name,age,job);
    }
}
</span><span style="color: #0000ff;">var</span> person1 = Person("jack",29,"IT"<span style="color: #000000;">);
console.log(window.name); </span><span style="color: #008000;">//</span><span style="color: #008000;">""</span>
console.log(person1.name);<span style="color: #008000;">//</span><span style="color: #008000;">jack</span>

<span style="color: #0000ff;">var</span> person2 = Person("Tom",20,"teacher"<span style="color: #000000;">);
console.log(person2.name);</span><span style="color: #008000;">//</span><span style="color: #008000;">Tom</span></pre>
</div>
<p>如下例子，Rectangle实例中没有添加sides属性：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Polygon(sides){
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span> <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Polygon){
        </span><span style="color: #0000ff;">this</span>.sides =<span style="color: #000000;"> sides;
        </span><span style="color: #0000ff;">this</span>.getArea = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        }
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Polygon(sides);
    }
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Rectangle(width,height){
    Polygon.call(</span><span style="color: #0000ff;">this</span>,2<span style="color: #000000;">);
    </span><span style="color: #0000ff;">this</span>.width =<span style="color: #000000;"> width;
    </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> height;
    </span><span style="color: #0000ff;">this</span>.getArea = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.width * <span style="color: #0000ff;">this</span><span style="color: #000000;">.height;
    }
}

</span><span style="color: #0000ff;">var</span> rect = <span style="color: #0000ff;">new</span> Rectangle(5,10<span style="color: #000000;">);
console.log(rect.sides); </span><span style="color: #008000;">//</span><span style="color: #008000;">undefined</span></pre>
</div>
<p>修改后，Rectangle实例中添加了sides属性：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Polygon(sides){
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span> <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Polygon){
        </span><span style="color: #0000ff;">this</span>.sides =<span style="color: #000000;"> sides;
        </span><span style="color: #0000ff;">this</span>.getArea = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        }
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Polygon(sides);
    }
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Rectangle(width,height){
    Polygon.call(</span><span style="color: #0000ff;">this</span>,2<span style="color: #000000;">);
    </span><span style="color: #0000ff;">this</span>.width =<span style="color: #000000;"> width;
    </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> height;
    </span><span style="color: #0000ff;">this</span>.getArea = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.width * <span style="color: #0000ff;">this</span><span style="color: #000000;">.height;
    }
}
Rectangle.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Polygon();
</span><span style="color: #0000ff;">var</span> rect = <span style="color: #0000ff;">new</span> Rectangle(5,10<span style="color: #000000;">);
console.log(rect.sides); </span><span style="color: #008000;">//</span><span style="color: #008000;">2</span></pre>
</div>
<h3>惰性载入函数</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> createXHR(){
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> XMLHttpRequest != "undefined"<span style="color: #000000;">){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> XMLHttpRequest();
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> ActiveXObject != "undefined"<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> arguments.callee.activeXString != 'string'<span style="color: #000000;">){
            </span><span style="color: #0000ff;">var</span> verisions = ["MSXML2.XMLHttp.6.0","MSXML2.XMLHttp.3.0","MSXML2.XMLHttp"<span style="color: #000000;">],
            i,
            len;
            </span><span style="color: #0000ff;">for</span>(i = 0, len = versions.length; i &lt; len; i++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
                    </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ActiveXObject(versions[i]);
                    arguments.callee.activeXString </span>=<span style="color: #000000;"> version[i];
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(ex){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">跳过</span>
<span style="color: #000000;">                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ActiveXObject(arguments.callee.activeXString);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">throw</span>  <span style="color: #0000ff;">new</span> Error("NO XHR object available."<span style="color: #000000;">);
    }
}</span></pre>
</div>
<p>每次调用createXHR()时，他都要对浏览器所支持的能力仔细检查。如果if语句不必每次执行，那么代码可以运行的更快一些。解决方案称之为惰性载入的技巧。</p>
<p>惰性载入表示函数执行的分支仅会发生一次。有两种实现惰性载入的方式，第一种就是函数在被调用时再处理函数。在第一次调用的过程中，该函数会覆盖为另外一个按合适方式执行的函数，这样对原函数的调用都不用在经过执行的分支了。例如上面例子重写为：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> createXHR(){
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> XMLHttpRequest != "undefined"<span style="color: #000000;">){
        createXHR </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> XMLHttpRequest();
        }
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> ActiveXObject != "undefined"<span style="color: #000000;">){
        createXHR </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> arguments.callee.activeXString != 'string'<span style="color: #000000;">){
                </span><span style="color: #0000ff;">var</span> verisions = ["MSXML2.XMLHttp.6.0","MSXML2.XMLHttp.3.0","MSXML2.XMLHttp"<span style="color: #000000;">],
                i,
                len;
                </span><span style="color: #0000ff;">for</span>(i = 0, len = versions.length; i &lt; len; i++<span style="color: #000000;">){
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
                        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ActiveXObject(versions[i]);
                        arguments.callee.activeXString </span>=<span style="color: #000000;"> version[i];
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(ex){
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">跳过</span>
<span style="color: #000000;">                    }
                }
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ActiveXObject(arguments.callee.activeXString);
        }    
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        createXHR </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">throw</span>  <span style="color: #0000ff;">new</span> Error("NO XHR object available."<span style="color: #000000;">);
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> createXHR();
}</span></pre>
</div>
<p>第二种实现惰性载入的方式是在声明函数时就指定适当的函数，如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> createXHR = (<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> XMLHttpRequest != "undefined"<span style="color: #000000;">){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> XMLHttpRequest();
        }
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> ActiveXObject != "undefined"<span style="color: #000000;">){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> arguments.callee.activeXString != 'string'<span style="color: #000000;">){
                </span><span style="color: #0000ff;">var</span> verisions = ["MSXML2.XMLHttp.6.0","MSXML2.XMLHttp.3.0","MSXML2.XMLHttp"<span style="color: #000000;">],
                i,
                len;
                </span><span style="color: #0000ff;">for</span>(i = 0, len = versions.length; i &lt; len; i++<span style="color: #000000;">){
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
                        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ActiveXObject(versions[i]);
                        arguments.callee.activeXString </span>=<span style="color: #000000;"> version[i];
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(ex){
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">跳过</span>
<span style="color: #000000;">                    }
                }
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ActiveXObject(arguments.callee.activeXString);
        }    
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            </span><span style="color: #0000ff;">throw</span>  <span style="color: #0000ff;">new</span> Error("NO XHR object available."<span style="color: #000000;">);
        }
    }
})();</span></pre>
</div>
<h3>&nbsp;函数绑定</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> {
    message:</span>"Event handler"<span style="color: #000000;">,
    handleClick:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(event){</span>
        console.log(<span style="color: #0000ff;">this</span>.meesage); <span style="color: #008000;">//</span><span style="color: #008000;">undefined</span>
<span style="color: #000000;">    }
}
</span><span style="color: #0000ff;">var</span> btn = document.getElementsByClassName("my-btn")[0<span style="color: #000000;">];
btn.addEventListener(</span>"click",handler.handleClick,<span style="color: #0000ff;">false</span>);</pre>
</div>
<p>上面的结果貌似会显示&ldquo;Event handler&rdquo;的结果，但是结果是undefined，是因为没有保存handler.handleClick()的环境。所以this对象最后是指向了DOM按钮，而非handler对象（在IE8中，this指向window）。可以使用一个闭包来修正这个问题，如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> {
    message:</span>"Event handler"<span style="color: #000000;">,
    handleClick:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
        console.log(</span><span style="color: #0000ff;">this</span>.message); <span style="color: #008000;">//</span><span style="color: #008000;">Event handler</span>
<span style="color: #000000;">    }
}
</span><span style="color: #0000ff;">var</span> btn = document.getElementsByClassName("my-btn")[0<span style="color: #000000;">];
btn.addEventListener(</span>"click",<span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
    handler.handleClick(event);
},</span><span style="color: #0000ff;">false</span>);</pre>
</div>
<p>很多javascript库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫做bind()。</p>
<p>一个简单的bind()函数接收一个函数和一个环境。并返回一个在给定函数中调用给定函数的函数，并且将所有参数原封不动的传递过去。语法如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> bind(fn,context){
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> fn.apply(context,arguments);
    }
}</span></pre>
</div>
<p>那么我们就可以用上面的bind()方法来实现绑定，如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> {
    message:</span>"Event handler"<span style="color: #000000;">,
    handleClick:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
        console.log(</span><span style="color: #0000ff;">this</span>.message); <span style="color: #008000;">//</span><span style="color: #008000;">Event handler</span>
<span style="color: #000000;">    }
}
</span><span style="color: #0000ff;">var</span> btn = document.getElementsByClassName("my-btn")[0<span style="color: #000000;">];
btn.addEventListener(</span>"click",bind(handler.handleClick,handler),<span style="color: #0000ff;">false</span>);</pre>
</div>
<p>ECMAScript5为所有函数定义了一个原生的bind()方法，那么上面代码可以如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> {
    message:</span>"Event handler"<span style="color: #000000;">,
    handleClick:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
        console.log(</span><span style="color: #0000ff;">this</span>.message); <span style="color: #008000;">//</span><span style="color: #008000;">Event handler</span>
<span style="color: #000000;">    }
}
</span><span style="color: #0000ff;">var</span> btn = document.getElementsByClassName("my-btn")[0<span style="color: #000000;">];
btn.addEventListener(</span>"click",handler.handleClick.bind(handler),<span style="color: #0000ff;">false</span>);</pre>
</div>
<p>原生的bind()方法和上面自定义的bind()方法很相似，都要传入作为this值的对象。支持原生bind()方法的浏览器有IE9+、Firefox4+和Chrome。</p>
<h3>&nbsp;函数柯里化</h3>
<p>与函数绑定紧密相关的是主题是函数柯里化（function curring），它用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数，如下例子：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> add(num1,num2){
    </span><span style="color: #0000ff;">return</span> num1 +<span style="color: #000000;"> num2;
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> curriedAdd(num2){
    </span><span style="color: #0000ff;">return</span> add(5<span style="color: #000000;">,num2);
}
console.log(add(</span>2,3)); <span style="color: #008000;">//</span><span style="color: #008000;">5</span>
console.log(curriedAdd(3)); <span style="color: #008000;">//</span><span style="color: #008000;">8</span></pre>
</div>
<p>&nbsp;尽管从技术上来说curriedAdd()并非柯里化的函数，但它很好的展示了其概念。</p>
<p>柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。下面是创建柯里化函数的通用方式：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> curry(fn){
    </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments,1<span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">var</span> innerArgs =<span style="color: #000000;"> Array.prototype.slice.call(arguments);
        </span><span style="color: #0000ff;">var</span> finalArgs =<span style="color: #000000;"> args.concat(innerArgs);
        </span><span style="color: #0000ff;">return</span> fn.apply(<span style="color: #0000ff;">null</span><span style="color: #000000;">,finalArgs);
    }
}</span></pre>
</div>
<p>调用方式：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> add(num1,num2){
    </span><span style="color: #0000ff;">return</span> num1 +<span style="color: #000000;"> num2;
}
</span><span style="color: #0000ff;">var</span> curriedAdd = curry(add,5<span style="color: #000000;">);
curriedAdd(</span>3); <span style="color: #008000;">//</span><span style="color: #008000;">8</span></pre>
</div>
<p>也可像下面方式调用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> add(num1,num2){
    </span><span style="color: #0000ff;">return</span> num1 +<span style="color: #000000;"> num2;
}
</span><span style="color: #0000ff;">var</span> curriedAdd = curry(add,5,3<span style="color: #000000;">);
curriedAdd(); </span><span style="color: #008000;">//</span><span style="color: #008000;">8</span></pre>
</div>
<p>函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数，如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> bind(fn,context){
    </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments,2<span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">var</span> innerArgs =<span style="color: #000000;"> Array.prototype.slice.call(arguments);
        </span><span style="color: #0000ff;">var</span> finalArgs =<span style="color: #000000;"> args.concat(innerArgs);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> fn.apply(context,finalArgs);
    }
}</span></pre>
</div>
<p>实例：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> {
    message:</span>"Event handled"<span style="color: #000000;">,
    handleclick:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(name,event){
        console.log(</span><span style="color: #0000ff;">this</span>.message + ":" + name + ":" +<span style="color: #000000;"> event.type);
    }
}
</span><span style="color: #0000ff;">var</span> btn = document.getElementById('my-btn'<span style="color: #000000;">);
btn.addEventListener(</span>'click',bind(handler.handleclick,handler,"my-btn"),<span style="color: #0000ff;">false</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">Event handled:my-btn:click</span></pre>
</div>
<p>ECMAScript5的bind()方法也实现了函数的柯里化，如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> {
    message:</span>"Event handled"<span style="color: #000000;">,
    handleclick:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(name,event){
        console.log(</span><span style="color: #0000ff;">this</span>.message + ":" + name + ":" +<span style="color: #000000;"> event.type);
    }
}
</span><span style="color: #0000ff;">var</span> btn = document.getElementById('my-btn'<span style="color: #000000;">);
btn.addEventListener(</span>'click',handler.handleclick.bind(handler,"my_btn"),<span style="color: #0000ff;">false</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">Event handled:my-btn:click</span></pre>
</div>
<h2>&nbsp;防篡改对象</h2>
<p>注意：一旦把对象定义为防篡改，就无法撤销。</p>
<h3>不可扩展对象Object.preventExtensions()</h3>
<p>使用Object.preventExtensions()就不能给原对象添加新的属性和方法了，如下例子：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> person =<span style="color: #000000;"> {
    name:</span>"jack"<span style="color: #000000;">
};
Object.preventExtensions(person);
person.age </span>= 20<span style="color: #000000;">;
console.log(person.age); </span><span style="color: #008000;">//</span><span style="color: #008000;">undefined  严格模式下抛出异常</span></pre>
</div>
<p>使用Object.isExtensible()确定对象是否可以扩展，如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> person =<span style="color: #000000;"> {
    name:</span>"jack"<span style="color: #000000;">
};
console.log(Object.isExtensible(person)); </span><span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #000000;">
Object.preventExtensions(person);
console.log(Object.isExtensible(person)); </span><span style="color: #008000;">//</span><span style="color: #008000;">false</span></pre>
</div>
<h3>密封的对象Object.seal()</h3>
<p>密封对象不可扩展，而且已有成员的[[configurable]]特性将被设置为false。这就意味着不能删除属性和方法，因为不能使用Object.defineProperty()把数据属性修改为访问器属性，或者相反。属性值是可以修改的。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> person =<span style="color: #000000;"> {
    name:</span>"jack"<span style="color: #000000;">
};
Object.seal(person);
person.age </span>= 20<span style="color: #000000;">;
console.log(person.age); </span><span style="color: #008000;">//</span><span style="color: #008000;">非严格模式下：undefined  严格模式下：抛出异常</span>

<span style="color: #0000ff;">delete</span><span style="color: #000000;"> person.name;
console.log(person.name); </span><span style="color: #008000;">//</span><span style="color: #008000;">非严格模式下：jack   严格模式下：抛出异常</span></pre>
</div>
<p>使用Object.isSealed()方法可以确定对象是否被密封了。因为被密封的对象不可扩展，所以调用Object.isExtensible()检测密封的对象也会返回false。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> person =<span style="color: #000000;"> {
    name:</span>"jack"<span style="color: #000000;">
};
console.log(Object.isExtensible(person)); </span><span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(Object.isSealed(person)); <span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #000000;">
Object.seal(person);
console.log(Object.isExtensible(person));</span><span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(Object.isSealed(person));<span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<h3>冻结的对象Object.freeze()</h3>
<p>最严格的防篡改级别是冻结对象。冻结的对象既不可扩展，又是密封的，而且对象数据属性[[writable]]特性会被设置为false。如果定义[[Set]]函数，访问器属性仍然是可写的。</p>
<p>ECMAScript5定义的Object.freeze()方法可以用来冻结对象，如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> person =<span style="color: #000000;"> {
    name:</span>"jack"<span style="color: #000000;">
};
Object.freeze(person);

person.age </span>= 20<span style="color: #000000;">;
console.log(person.age); </span><span style="color: #008000;">//</span><span style="color: #008000;">非严格模式:undefined  严格模式下:抛出异常</span>

<span style="color: #0000ff;">delete</span><span style="color: #000000;"> person.name;
console.log(person.name);</span><span style="color: #008000;">//</span><span style="color: #008000;">非严格模式:jack  严格模式下:抛出异常</span>
<span style="color: #000000;">
person.name </span>= "Tom"<span style="color: #000000;">;
console.log(person.name);</span><span style="color: #008000;">//</span><span style="color: #008000;">非严格模式:jack  严格模式下:抛出异常</span></pre>
</div>
<p>使用Object.isFrozen()方法检测冻结对象。因为冻结对象既是密封的又是不可扩展的，所以调用Object.isExtensible()和Object.isSealed()方法分别返回false和true。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> person =<span style="color: #000000;"> {
    name:</span>"jack"<span style="color: #000000;">
};

console.log(Object.isExtensible(person)); </span><span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(Object.isSealed(person)); <span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(Object.isFrozen(person)) <span style="color: #008000;">//</span><span style="color: #008000;">false</span>
<span style="color: #000000;">
Object.freeze(person);
console.log(Object.isExtensible(person));</span><span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(Object.isSealed(person));<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(Object.isFrozen(person)) <span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<h2>&nbsp;高级定时器</h2>
<h3>函数节流</h3>
<p>DOM操作比起非DOM交互需要更多的内存和CPU。连续尝试进行过多的DOM相关操作可能会导致浏览器挂起，有时候甚至会崩溃。比如在IE浏览器中使用onresize事件处理程序的时候容易发生，当调整浏览器窗口的时候，该事件会连续发生。在onresize事件处理程序内部如果尝试进行DOM操作，其高频率的更改可能会让浏览器崩溃。为了解决这个问题，可以使用定时器对该函数进行节流。</p>
<p>基本形式代码结构如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> processor =<span style="color: #000000;"> {
    timeoutId:</span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">实际进行处理的方法</span>
    performProcessing:<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
         </span><span style="color: #008000;">//</span><span style="color: #008000;">实际执行的代码</span>
<span style="color: #000000;">    },
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">初始处理调用的方法</span>
    process:<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        clearTimeout(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.timeoutId);
        </span><span style="color: #0000ff;">var</span> that = <span style="color: #0000ff;">this</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.timeoutId = setTimeout(<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            that.performProcessing();
        },</span>100<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">尝试开始 执行</span>
processor.process();</pre>
</div>
<p>时间间隔设置为了100ms，这表示最后一次调用process()之后，至少100ms后才会调用performProcessing()。所以如果100ms之内调用了20次process()，也只会调用performProcessing()一次。</p>
<p>这个模式可以使用throttle函数来简化，这个函数可以自动进行定时器的设置和清除，如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> throttle(method,context){
    clearTimeout(method.tId);
    method.tId </span>= setTimeout(<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        method.call(context);
    },</span>100<span style="color: #000000;">);
}</span></pre>
</div>
<p>throttle()函数接受两个参数：要执行的函数以及在哪个作用域中执行。</p>
<p>来看个例子，假如有一个div元素需要保持它的高度始终等于宽度。那么实现这个JS代码如下：</p>
<div class="cnblogs_code">
<pre><code>window.onresize = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">var</span> div = document.getElementById("myDiv"<span style="color: #000000;">);
    div.style.height </span>= div.offsetWidth + "px"<span style="color: #000000;">;
}</span></pre>
</div>
<p>上面代码有两个问题可能造成浏览器运行缓慢，一个是计算offsetWidth属性，如果该元素或者页面上的其它元素有非常复杂的css样式，那么这个过程将会很复杂。 另一个设置某个元素的高度需要对页面进行回流来令改动生效。如果页面有很多元素同时应用了相当数量的CSS的话，这有需要很多计算。这就可以用到throttle()函数，如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> resizeDiv(){
    </span><span style="color: #0000ff;">var</span> div = document.getElementById("myDiv"<span style="color: #000000;">);
    div.style.height </span>= div.offsetWidth + "px"<span style="color: #000000;">;
}

window.onresize </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    throttle(resizeDiv);
}</span></pre>
</div>
<p>只要代码是周期性执行的，都应该使用节流。</p>
<h2>自定义事件</h2>
<p>事件是一种叫做观察者的设计模式，这是一种创建松散耦合代码的技术。对象可以发布事件，用来表示在该对象生命周期中某个有趣的时刻到了。然后其它对象可以观察该对象，等等这些有趣的时刻到来并通过运行代码来响应。</p>
<p>观察者模式由两类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。该模式的一个关键概念是主体并不知道观察者的任何事情，也就是说它可以独自存在并正常运作即便观察者不存在。从另一个方面来说，观察者知道主体并能注册事件的回调函数（事件处理程序）。涉及DOM上时，DOM元素便是主体，你的事件处理代码便是观察者。</p>
<p>事件是与DOM交互的最常见的方式，但它们也可以用于非DOM代码中--通过实现自定义事件。</p>
<p>自定义事件背后的概念是创建一个管理事件的对象，让其他对象监听那些事件。实现此功能的基本模式可以如下定义：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> EventTarget(){
    </span><span style="color: #0000ff;">this</span>.handlers =<span style="color: #000000;"> {};
}
EventTarget.prototype </span>=<span style="color: #000000;"> {
    constructor:EventTarget,
    addHandler:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(type,handler){
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> <span style="color: #0000ff;">this</span>.handlers[type] == "undefined"<span style="color: #000000;">){
            </span><span style="color: #0000ff;">this</span>.handlers[type] =<span style="color: #000000;"> [];
        }
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.handlers[type].push(handler);
    },
    fire:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">event.target){
            event.target </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.handlers[event.type] <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Array){
            </span><span style="color: #0000ff;">var</span> handlers = <span style="color: #0000ff;">this</span><span style="color: #000000;">.handlers[event.type];
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i = 0, len = handlers.length; i &lt; len; i++<span style="color: #000000;">){
                handlers[i](event);
            }
        }
    },
    removeHandler:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(type,handler){
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.handlers[type] <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Array){
            </span><span style="color: #0000ff;">var</span> handlers = <span style="color: #0000ff;">this</span><span style="color: #000000;">.handlers[type];
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i = 0, len = handlers.length; i &lt; len; i++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(handlers[i] ===<span style="color: #000000;"> handler){
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            handlers.splice(i,</span>1<span style="color: #000000;">);
        }
    }
};</span></pre>
</div>
<p>EventTarget类型有一个单独的属性handlers，用于存储事件处理程序。<br />定义的三个方法如下：</p>
<ul>
<li>1.addHandler：用于注册给定类型事件的事件处理程序；该方法接受两个参数，事件类型和用于处理该事件的函数。</li>
<li>2.fire：触发一个事件；该方法接受一个单独的参数，是一个至少包含type属性的对象。fire()方法先给event对象设置一个target属性，如果它尚未被指定的话。然后它就查找对应该事件类型的一组处理程序，调用各个函数，并给出event对象。因为这些都是自定义事件，所以event对象上还需要的额外信息由你自己决定。</li>
<li>3.removeHandler：注销某个事件类型的事件处理程序；它接受的参数跟addHandler是一样的。</li>








</ul>
<p>使用EventTarget类型的自定义事件可以如下使用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;">  handlerMessage(event){
    console.log(</span>"Message received:" +<span style="color: #000000;"> event.message);
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个新对象</span>
<span style="color: #0000ff;">var</span> target = <span style="color: #0000ff;">new</span><span style="color: #000000;"> EventTarget();

</span><span style="color: #008000;">//</span><span style="color: #008000;">添加一个事件处理程序</span>
target.addHandler("message"<span style="color: #000000;">,handlerMessage);

</span><span style="color: #008000;">//</span><span style="color: #008000;">触发事件</span>
target.fire({type:"message",message:"Hello world!"<span style="color: #000000;">});

</span><span style="color: #008000;">//</span><span style="color: #008000;">移除事件处理程序</span>
target.removeHandler("message"<span style="color: #000000;">,handlerMessage);

</span><span style="color: #008000;">//</span><span style="color: #008000;">再次，应没有处理程序</span>
target.fire({type:"message",message:"Hello world!"});</pre>
</div>
<p>&nbsp;如下实例：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> object(o){
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> F(){};
    F.prototype </span>=<span style="color: #000000;"> o;
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> F();
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> inheritPrototype(subType,superType){
    </span><span style="color: #0000ff;">var</span> prototype =<span style="color: #000000;"> object(superType.prototype);
    prototype.constructor </span>=<span style="color: #000000;"> subType;
    subType.prototype </span>=<span style="color: #000000;"> prototype;
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age){
    EventTarget.call(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
}

inheritPrototype(Person,EventTarget);

Person.prototype.say </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(message){
    </span><span style="color: #0000ff;">this</span>.fire({type:"message"<span style="color: #000000;">,message:message});
}</span></pre>
</div>
<p>Person类型使用了寄生组合继承方法来继承EventTarget。怎样使用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;">  handlerMessage(event){
    console.log(event.target.name </span>+ " says:" +<span style="color: #000000;"> event.message);
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">创建新Person</span>
<span style="color: #0000ff;">var</span> person = <span style="color: #0000ff;">new</span> Person("Jack",29<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;">添加一个事件处理程序</span>
person.addHandler("message"<span style="color: #000000;">,handlerMessage);

</span><span style="color: #008000;">//</span><span style="color: #008000;">在该对象上调用一个方法，它触发消息事件</span>
person.say('Hi there');</pre>
</div>
<h2>&nbsp;拖放</h2>
<h3>拖放功能</h3>
<p>下例代码自己添加了一部分控制在屏幕区域的代码，如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> DragDrop = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">var</span> dragging = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            differX </span>= 0<span style="color: #000000;">,
            differY </span>= 0<span style="color: #000000;">,
            targetWidth </span>= 0<span style="color: #000000;">,
            targetHeight </span>= 0<span style="color: #000000;">,
            windowWidth </span>= 0<span style="color: #000000;">,
            windowHeight </span>= 0<span style="color: #000000;">,
            _isMove </span>= <span style="color: #0000ff;">false</span>; <span style="color: #008000;">//</span><span style="color: #008000;">是否移动</span>
    
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> handleEvent(event){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取事件和目标</span>
        event = event ||<span style="color: #000000;"> window.event;
        </span><span style="color: #0000ff;">var</span> target = event.target ||<span style="color: #000000;"> event.srcElement;
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">确认事件类型</span>
        <span style="color: #0000ff;">switch</span><span style="color: #000000;">(event.type){
            </span><span style="color: #0000ff;">case</span> "mousedown"<span style="color: #000000;">:
                </span><span style="color: #0000ff;">if</span>(target.className.indexOf("drggable") != -1<span style="color: #000000;">){
                    dragging </span>=<span style="color: #000000;"> target;
                    _isMove </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    differX </span>= event.clientX -<span style="color: #000000;"> target.offsetLeft;
                    differY </span>= event.clientY -<span style="color: #000000;"> target.offsetTop;
                    targetWidth </span>=<span style="color: #000000;"> target.offsetWidth;
                    targetHeight </span>=<span style="color: #000000;"> target.offsetHeight;
                    windowWidth </span>=<span style="color: #000000;"> document.documentElement.clientWidth;
                    windowHeight </span>=<span style="color: #000000;"> document.documentElement.clientHeight;
                }
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span> "mousemove"<span style="color: #000000;">:
                </span><span style="color: #0000ff;">if</span>(dragging !== <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> _isMove){
                    </span><span style="color: #0000ff;">var</span> left = event.clientX -<span style="color: #000000;"> differX,
                            top </span>= event.clientY -<span style="color: #000000;"> differY;
                    </span><span style="color: #0000ff;">if</span>(left &lt; 0<span style="color: #000000;">){
                        left </span>= 0<span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(left &gt; windowWidth -<span style="color: #000000;"> targetWidth){
                        left </span>= windowWidth -<span style="color: #000000;"> targetWidth;
                    }
                    
                    </span><span style="color: #0000ff;">if</span>(top &lt; 0<span style="color: #000000;">){
                        top </span>= 0<span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(top &gt; windowHeight -<span style="color: #000000;"> targetHeight){
                        top </span>= windowHeight -<span style="color: #000000;"> targetHeight;
                    }
                    
                    dragging.style.left </span>= left  + "px"<span style="color: #000000;">;
                    dragging.style.top </span>= top + "px"<span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span> "mouseup"<span style="color: #000000;">:
                dragging </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                _isMove </span>=<span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">公共接口</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> {
        enable:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            document.addEventListener(</span>"mousedown",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.addEventListener(</span>"mousemove",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.addEventListener(</span>"mouseup",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
        },
        disable:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            document.removeEventListener(</span>"mousedown",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.removeEventListener(</span>"mousemove",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.removeEventListener(</span>"mouseup",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
        }
    }
    
}();
DragDrop.enable();</span></pre>
</div>
<h3>添加自定义事件</h3>
<p>&nbsp;上面写的拖放功能还不能真正应用起来，除非能知道什么时候拖动开始了。从这点来看，前面的代码没有提供任何方法表示拖动开始、正在拖动或者拖动结束。这时，可以使用自定义事件来指示这几个事件的发生，让应用的其它部分和拖动功能进行交互。如下代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> EventTarget(){
    </span><span style="color: #0000ff;">this</span>.handlers =<span style="color: #000000;"> {};
}
EventTarget.prototype </span>=<span style="color: #000000;"> {
    constructor:EventTarget,
    addHandler:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(type,handler){
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> <span style="color: #0000ff;">this</span>.handlers[type] == "undefined"<span style="color: #000000;">){
            </span><span style="color: #0000ff;">this</span>.handlers[type] =<span style="color: #000000;"> [];
        }
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.handlers[type].push(handler);
    },
    fire:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">event.target){
            event.target </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.handlers[event.type] <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Array){
            </span><span style="color: #0000ff;">var</span> handlers = <span style="color: #0000ff;">this</span><span style="color: #000000;">.handlers[event.type];
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i = 0, len = handlers.length; i &lt; len; i++<span style="color: #000000;">){
                handlers[i](event);
            }
        }
    },
    removeHandler:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(type,handler){
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.handlers[type] <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Array){
            </span><span style="color: #0000ff;">var</span> handlers = <span style="color: #0000ff;">this</span><span style="color: #000000;">.handlers[type];
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i = 0, len = handlers.length; i &lt; len; i++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(handlers[i] ===<span style="color: #000000;"> handler){
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            handlers.splice(i,</span>1<span style="color: #000000;">);
        }
    }
};


</span><span style="color: #0000ff;">var</span> DragDrop = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">var</span> dragdrop = <span style="color: #0000ff;">new</span><span style="color: #000000;"> EventTarget(),
            dragging </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            differX </span>= 0<span style="color: #000000;">,
            differY </span>= 0<span style="color: #000000;">;
    
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> handleEvent(event){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取事件和目标</span>
        event = event ||<span style="color: #000000;"> window.event;
        </span><span style="color: #0000ff;">var</span> target = event.target ||<span style="color: #000000;"> event.srcElement;
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">确认事件类型</span>
        <span style="color: #0000ff;">switch</span><span style="color: #000000;">(event.type){
            </span><span style="color: #0000ff;">case</span> "mousedown"<span style="color: #000000;">:
                </span><span style="color: #0000ff;">if</span>(target.className.indexOf("drggable") != -1<span style="color: #000000;">){
                    dragging </span>=<span style="color: #000000;"> target;
                    _isMove </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    differX </span>= event.clientX -<span style="color: #000000;"> target.offsetLeft;
                    differY </span>= event.clientY -<span style="color: #000000;"> target.offsetTop;
                    dragdrop.fire({type:</span>"dragstart"<span style="color: #000000;">,target:dragging,x:event.clientX,y:event.clientY})
                }
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span> "mousemove"<span style="color: #000000;">:
                </span><span style="color: #0000ff;">if</span>(dragging !== <span style="color: #0000ff;">null</span><span style="color: #000000;">){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">指定位置</span>
                    dragging.style.left = (event.clientX - differX)  + "px"<span style="color: #000000;">;
                    dragging.style.top </span>= (event.clientY - differY) + "px"<span style="color: #000000;">;
                    
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">触发自定义事件</span>
                    dragdrop.fire({type:"drag"<span style="color: #000000;">,target:dragging,x:event.clientX,y:event.clientY})
                }
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span> "mouseup"<span style="color: #000000;">:
                dragdrop.fire({type:</span>"dragend"<span style="color: #000000;">,target:dragging,x:event.clientX,y:event.clientY})
                dragging </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">公共接口</span>
        dragdrop.enable = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            document.addEventListener(</span>"mousedown",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.addEventListener(</span>"mousemove",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.addEventListener(</span>"mouseup",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
        };
        dragdrop.disable </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
            document.removeEventListener(</span>"mousedown",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.removeEventListener(</span>"mousemove",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
            document.removeEventListener(</span>"mouseup",handleEvent,<span style="color: #0000ff;">false</span><span style="color: #000000;">);
        };
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dragdrop;    
}();</span></pre>
</div>
<p>这段代码定义了三个自定义事件：dragstart、drag、dragend，它们都将被拖动的元素设置为了target，并给出了x和y属性来表示当前的位置。调用如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">DragDrop.enable();
DragDrop.addHandler(</span>"dragstart",<span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
    </span><span style="color: #0000ff;">var</span> status = document.getElementById('status'<span style="color: #000000;">);
    status.innerHTML </span>= "Started dragging " +<span style="color: #000000;"> event.target.id;
});
DragDrop.addHandler(</span>"drag",<span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
    </span><span style="color: #0000ff;">var</span> status = document.getElementById('status'<span style="color: #000000;">);
    status.innerHTML </span>+= "&lt;br/&gt; Dragged" + event.target.id + " to（" + event.x + "," + event.y + "）"<span style="color: #000000;">;
});
DragDrop.addHandler(</span>"dragend",<span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
    </span><span style="color: #0000ff;">var</span> status = document.getElementById('status'<span style="color: #000000;">);
    status.innerHTML </span>+= "&lt;br/&gt; Dropped" + event.target.id + " at（" + event.x + "," + event.y + "）"<span style="color: #000000;">;
});</span></pre>
</div>
<p>贴出HTML代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="status"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="myDiv"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="drggable"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>CSS代码：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #800000;">*</span>{<span style="color: #ff0000;">margin</span>:<span style="color: #0000ff;">0</span>;<span style="color: #ff0000;">padding</span>:<span style="color: #0000ff;">0</span>;}<span style="color: #800000;">
#myDiv</span>{<span style="color: #ff0000;">width</span>:<span style="color: #0000ff;">200px</span>;<span style="color: #ff0000;">height</span>:<span style="color: #0000ff;">200px</span>;<span style="color: #ff0000;">background</span>:<span style="color: #0000ff;"> blue</span>;<span style="color: #ff0000;">position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">top</span>:<span style="color: #0000ff;">50px</span>;<span style="color: #ff0000;">left</span>:<span style="color: #0000ff;">400px</span>;}</pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>