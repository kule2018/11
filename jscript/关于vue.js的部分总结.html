<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修关于vue.js的部分总结' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>关于vue.js的部分总结</center></div><div class='banquan'>原文出处:本文由博客园博主黑框眼镜&#183;提供。<br/>
原文连接:https://www.cnblogs.com/52cyd/p/11228019.html</div><br>
    <pre><code>1.MVVM和MVC的区别：<br />    MVVM：是Model-View-ViewModel的简写，即模型-视图-视图模型<br />    模型：后端传递的数据<br />    试图：所看到的页面<br />    视图模型：mvvm模式的核心，它是连接view和model的桥梁。<br />    两个实现方向：<br />        1）模型===》视图：后端传递的数据转化成所看到的页面，实现方式（数据绑定）<br />        2）视图===》模型：即将所看到的页面转化成后端的数据，实现的方式是（DOM 事件监听）<br />    MVC:MVC是Model-View-Controller的简写，即模型-视图-控制器<br />    controller指的是页面业务逻辑，使用MVC的目的就是将M和V代码分离<br /><br />    使用MVVM模式有几大好处：<br />        　  1）. 低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。<br />        　　2）. 可重用性。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。<br />        　　3）. 独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。<br />        　　4）. 可测试性。可以针对ViewModel来对界面(View)进行测试<br /><br />2.vue的生命周期<br />    八个：创建前、创建后、载入前、载入后、更新前、更新后、销毁前、销毁后<br />    生命周期的作用：让我们在控制整个Vue实例的过程时更容易形成好的逻辑<br />    DOM 渲染在 载入后（mounted） 中就已经完成了。<br /><br />3.vue实现双向绑定原理<br />    vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）<br />    来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。<br /><br />4.Vue组件间的参数传递<br />    1）父组件与子组件传值<br />        父===》子：子组件通过props方法接受数据;<br />        子===》父：子组件通过$emit方法传递参数,触发父组件event<br />    2）非父子组件间的数据传递，兄弟组件传值<br />        eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件<br />        VUEX项目较大时<br /><br />5.Vue与React的区别<br /><br /><br /><br />6.vue路由的钩子函数<br />    首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。<br />    一些需要登录才能调整页面的重定向功能。<br />    beforeEach主要有3个参数to、from、next<br />    to：route即将进入的目标路由对象<br />    from：route当前导航正要离开的路由<br />    next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。<br />    全局导航钩子：<br />    router.beforeEach(to, from, next),<br />    router.beforeResolve(to, from, next),<br />    router.afterEach(to, from ,next)<br />    组件内钩子：<br />    beforeRouteEnter,<br />    beforeRouteUpdate,<br />    beforeRouteLeave<br />    单独路由独享组件：<br />    beforeEnter<br /><br /><br />7.vuex是什么？怎么使用？哪种功能场景使用它？<br />    只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。<br />    在main.js引入store，注入。新建了一个目录store，&hellip;.. export 。<br />    场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车<br /><br />    vuex 的mutation和action的特性是什么？有什么区别？<br />        mutation用于修改state的数据，是同步的。<br />        action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态<br />        action 可以包含任意异步操作<br /><br />8.css只在当前组件起作用<br />    在style标签中写入scoped即可：&lt;style scoped&gt;&lt;/style&gt;<br /><br />9.v-if 和 v-show 区别<br />    v-if按照条件是否渲染，v-show是display的block或none<br />    v-show的值无论为true或false，元素都会存在与html代码中，而只有当v-if的值为true，元素才会存在HTML中<br />    v-show指令只是设置了元素css的style值<br /><br />10.$route和$router的区别<br />    $route是&ldquo;路由信息对象&rdquo;，包括path，params，hash，query，fullPath，matched，name等路由信息参数<br />    $router是&ldquo;路由实例&rdquo;对象包括了路由的跳转方法，钩子函数等<br /><br />11.vue.js的两个核心是什么？vue几种常用的指令？<br />    数据驱动、组件系统<br />    指令：v-for、v-if、v-bind、v-on、v-show、v-else<br /><br />12.vue常用的修饰符？<br />    prevent：提交事件不再重载页面<br />    stop：阻止事件冒泡<br />    self：当事件发生在该元素本身而不是子元素的时候会触发<br />    capture:事件侦听，事件发生的时候会调用<br /><br />13.对keep-alive的了解<br />    keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br />    keep-alive加入了两个属性：include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include)<br /><br />        &lt;keep-alive include='include_components' exclude='exclude_components'&gt;<br />            &lt;component&gt;<br />                 &lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt;<br />            &lt;/component&gt;<br />        &lt;/keep-alive&gt;<br />    参数解释：<br />    include - 字符串或正则表达式，只有名称匹配的组件会被缓存<br />    exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存<br />    include 和 exclude 的属性允许组件有条件地缓存。二者都可以用&ldquo;，&rdquo;分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。<br /><br />13.vue.js是什么？<br />    是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。<br />    Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，<br />    Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。<br />    Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件<br /><br />14.vue.js特性<br />    MVVM、组件化、指令系统、支持虚拟DOM<br />    虚拟dom：虚拟DOM是用Object来代表一颗节点，这个Object叫做VNode，然后使用两个VNode进行对比，根据对比后的结果修改真实DOM。<br />             每次渲染都会生成一个新的VNode，然后和上一次渲染时用的VNode进行对比。然后将这一次新生成的VNode缓存，用来进行下一次对比。<br />    虚拟dom的缺点：<br />    1. 代码更多，体积更大<br />    2. 内存占用增大<br />    3. 小量的单一的dom修改使用虚拟dom成本反而更高，不如直接修改真实dom快<br /><br />15.vue.js的特点<br />    简洁：页面由HTML模板+Json数据+Vue实例组成<br />    数据驱动：自动计算属性和追踪依赖的模板表达式<br />    组件化：用可复用、解耦的组件来构造页面<br />    轻量：代码量小，不依赖其他库<br />    快速：精确有效批量DOM更新<br />    模板友好：可通过npm，bower等多种方式安装，很容易融入<br /><br />16.Vue 项目时为什么要在组件中写 key，其作用是什么?<br />    在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。<br />    在 Diff 算法中 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，<br />    从而减少不必要的元素重渲染。<br /><br />17.computed 和 watched 的区别：<br />   computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。<br />   watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。<br /><br /><br />18.axios是什么？怎么使用？描述使用它实现登录功能的流程？<br />   请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。<br />   后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，<br />   失败则是在.catch函数中</pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>