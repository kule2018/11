<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修前端开发HTML5——函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>前端开发HTML5——函数</center></div><div class='banquan'>原文出处:本文由博客园博主呱唧_T_呱唧提供。<br/>
原文连接:https://www.cnblogs.com/aitiknowledge/p/11534526.html</div><br>
    <div><strong>20、函数的调用方式</strong>（内容尚未完全，可自行百度这方面的知识）</div>
<div style="margin-left: 30px;">call()、apply()、bind() 这三个方法的作用都是改变执行环境中的this指针的指向</div>
<div>&nbsp;</div>
<div style="margin-left: 30px;">call()与apply()</div>
<div style="margin-left: 30px;">这两个方法的第一个参数都为this指针指向的目标对象，他们的区别是第二个参数开始传参的方式不同</div>
<div style="margin-left: 30px;">call传参：obj, arg2,arg3,.....</div>
<div style="margin-left: 30px;">apply传参：obj, [arg2,arg3,..... ]</div>
<div style="margin-left: 60px;">function func(a, b){</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return this.value + a + b;</div>
<div style="margin-left: 60px;">}</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var obj = {</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 1,</div>
<div style="margin-left: 60px;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func.call(obj, 2, 3); &nbsp; //6</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func.apply(obj, 2, 3);//6</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //call()和apply()如果第一个参数不是对象类型，那么这个参数会被自动转化为对象类型</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function func(){</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(Object.prototype.toString.call(this));</div>
<div style="margin-left: 60px;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
<div style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func.call(2);</div>
<div>&nbsp;</div>
<div style="margin-left: 30px;">bind()</div>
<div style="margin-left: 30px;">第一个参数为this指针指向的目标对象，bind方法执行后返回的是一个新函数</div>
<div style="margin-left: 60px;">function func(){</div>
<div style="margin-left: 60px;">　　console.log(this.name);</div>
<div style="margin-left: 60px;">}</div>
<div style="margin-left: 60px;">var obj = {</div>
<div style="margin-left: 60px;">　　name: '张三',</div>
<div style="margin-left: 60px;">}；</div>
<div style="margin-left: 60px;">var f = func.bind(obj);</div>
<div style="margin-left: 60px;">f(); &nbsp;//张三</div>
<div style="margin-left: 60px;">//在这个新的函数对象中，this被永久的绑定到了bind的第一个参数上面，五六年后期这个函数被如何使用，this都不会改变</div>
<div style="margin-left: 60px;">var obj27 = {</div>
<div style="margin-left: 60px;">　　name: '李四',</div>
<div style="margin-left: 60px;">　　f: f,</div>
<div style="margin-left: 60px;">}；</div>
<div style="margin-left: 60px;">obj2.f(); &nbsp;//张三</div>
<div>&nbsp;</div>
<div style="margin-left: 30px;">call()、apply()、bind()</div>
<div style="margin-left: 30px;">如果这三个方法都没有提供第一个参数或者是参数是this、null、undefined中的一种，那么都将默认第一个参数的为Global对象</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>21、全局变量和局部变量</strong></div>
<div style="margin-left: 30px;">在函数内部声明的变量为局部变量，函数外部不能使用；</div>
<div style="margin-left: 30px;">函数外部声明的变量为当前js文件的全局变量</div>
<div style="margin-left: 30px;">如果没有var修饰的变量也为全局变量，这个变量在哪都可以访问</div>
<div style="margin-left: 60px;">var a = 1;</div>
<div style="margin-left: 60px;">function test(){</div>
<div style="margin-left: 90px;">console.log(a); &nbsp; &nbsp; &nbsp; &nbsp;//1</div>
<div style="margin-left: 90px;">var b = 2;</div>
<div style="margin-left: 90px;">console.log(b); &nbsp; &nbsp; &nbsp; //2</div>
<div style="margin-left: 60px;">}&nbsp;</div>
<div style="margin-left: 60px;">test();</div>
<div style="margin-left: 60px;">console.log(a); &nbsp; &nbsp; &nbsp; //1</div>
<div style="margin-left: 60px;">console.log(b); &nbsp; &nbsp; &nbsp; // b is not defined</div>
<div>&nbsp;</div>
<div style="margin-left: 30px;">当函数内部的变量和全局变量同名，函数内部就不会使用外部的变量</div>
<div style="margin-left: 60px;">var g = 100;</div>
<div style="margin-left: 60px;">function testG(){</div>
<div style="margin-left: 90px;">console.log(g); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//undefined</div>
<div style="margin-left: 90px;">var g = 200;</div>
<div style="margin-left: 90px;">console.log(g); &nbsp; &nbsp; &nbsp; &nbsp; //200</div>
<div style="margin-left: 60px;">}</div>
<div style="margin-left: 60px;">testG();</div>
<div style="margin-left: 60px;">console.log(g); &nbsp; &nbsp; &nbsp; &nbsp; //100</div>
<div>&nbsp;</div>
<div><strong>22、函数的属性和方法</strong></div>
<div style="margin-left: 30px;"><em>1）length:表示函数希望接受的命名参数的个数&nbsp;</em></div>
<div style="margin-left: 60px;">function test(a, b){</div>
<div style="margin-left: 60px;">　　return 'hello';</div>
<div style="margin-left: 60px;">}</div>
<div style="margin-left: 60px;">console.log(test.length); &nbsp; &nbsp; //2 &nbsp; ----&gt;形参的个数</div>
<div style="margin-left: 60px;">test();</div>
<div style="margin-left: 60px;">console.log(test()); &nbsp; &nbsp; &nbsp;//hello</div>
<div>&nbsp;</div>
<div style="margin-left: 30px;"><em>2）函数作为参数&nbsp;</em></div>
<div style="margin-left: 60px;">function handle(fun){</div>
<div style="margin-left: 60px;">　　var msg = "hello";</div>
<div style="margin-left: 60px;">　　fun(msg);</div>
<div style="margin-left: 60px;">}</div>
<div style="margin-left: 60px;">handle(function(m){</div>
<div style="margin-left: 60px;">　　console.log(m); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //hello</div>
<div style="margin-left: 60px;">});</div>
<div>&nbsp;</div>
<div style="margin-left: 30px;"><em>3）函数作为返回值&nbsp;</em></div>
<div style="margin-left: 60px;">function handle2(){</div>
<div style="margin-left: 60px;">　　return function(){</div>
<div style="margin-left: 60px;">　　　　console.log(123);</div>
<div style="margin-left: 60px;">　　}</div>
<div style="margin-left: 60px;">}</div>
<div style="margin-left: 60px;">handle2(); &nbsp; &nbsp;//这返回的只是一个函数名</div>
<div style="margin-left: 60px;">handle2()(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//123</div>
<div>&nbsp;</div>
<div><strong>23、值传递和引用传递</strong></div>
<div style="margin-left: 30px;"><em>1）基本数据类型的传递就是值传递 &nbsp; &nbsp;</em>不会影响上一个变量的值</div>
<div style="margin-left: 60px;">var a = 1;</div>
<div style="margin-left: 60px;">var b = a;</div>
<div style="margin-left: 60px;">console.log(a, b); &nbsp; &nbsp;//1 1</div>
<div style="margin-left: 60px;">b = 3;</div>
<div style="margin-left: 60px;">console.log(a, b); &nbsp; &nbsp; //1 3</div>
<div>&nbsp;</div>
<div style="margin-left: 30px;"><em>2）引用数据类型的传递就是址传递</em>&nbsp; &nbsp; 两个变量的值会变成一模一样</div>
<div style="margin-left: 60px;">var obj = {</div>
<div style="margin-left: 90px;">name: 'zhangsan',</div>
<div style="margin-left: 90px;">age:12,</div>
<div style="margin-left: 60px;">};</div>
<div style="margin-left: 60px;">var obj2 = obj;</div>
<div style="margin-left: 60px;">console.log(obj, obj2); &nbsp; &nbsp; //&nbsp;{name:'zhangsan',age:12,}&nbsp;{name:'zhangsan',age:12,}</div>
<div style="margin-left: 60px;">obj2.gender = 'male';</div>
<div style="margin-left: 60px;">console.log(obj, obj2); &nbsp; &nbsp; //{name:'zhangsan',age:12, gender:'male',}&nbsp;{name:'zhangsan',age:12,gender:'male', }</div>
<div>&nbsp;</div>
<div><strong>24、闭包（函数访问上下文中的变量）</strong></div>
<div style="margin-left: 30px;">var arr = [];</div>
<div style="margin-left: 30px;">for(var i = 0; i &lt; 5; i++){</div>
<div style="margin-left: 30px;">　　arr[i] = function(){</div>
<div style="margin-left: 30px;">　　　　console.log(i);</div>
<div style="margin-left: 30px;">　　}</div>
<div style="margin-left: 30px;">}</div>
<div style="margin-left: 30px;">arr[0](); &nbsp; &nbsp; //5</div>
<div style="margin-left: 30px;">arr[1](); &nbsp; &nbsp; //5</div>
<div style="margin-left: 30px;">arr[2](); &nbsp; &nbsp;&nbsp;//5</div>
<div style="margin-left: 30px;">arr[3](); &nbsp; &nbsp; //5</div>
<div style="margin-left: 30px;">arr[4](); &nbsp; &nbsp; //5</div>
<div style="margin-left: 30px;">上述现象就是闭包现象</div>
<div style="margin-left: 30px;">解决方法将上面的arr[i]改为下面的arr[i]</div>
<div style="margin-left: 30px;">arr[i] = (function(num){</div>
<div style="margin-left: 30px;">　　return function(){</div>
<div style="margin-left: 30px;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(num);</div>
<div style="margin-left: 30px;">　　};</div>
<div style="margin-left: 30px;">})(i);&nbsp;</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>