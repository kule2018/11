<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修可以提升幸福感的js小技巧（下）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>可以提升幸福感的js小技巧（下）</center></div><div class='banquan'>原文出处:本文由博客园博主Altairs提供。<br/>
原文连接:https://www.cnblogs.com/Altairs/p/11639648.html</div><br>
    <h3>4、数字</h3>
<h3><strong>4.1 不同进制表示法</strong></h3>
<p>ES6中新增了不同进制的书写格式，在后台传参的时候要注意这一点。</p>
<div class="cnblogs_code">
<pre><code>29            <span style="color: #008000;">//</span><span style="color: #008000;"> 10进制</span>
035            <span style="color: #008000;">//</span><span style="color: #008000;"> 8进制29      原来的方式</span>
0o35            <span style="color: #008000;">//</span><span style="color: #008000;"> 8进制29      ES6的方式</span>
0x1d            <span style="color: #008000;">//</span><span style="color: #008000;"> 16进制29</span>
0b11101            <span style="color: #008000;">//</span><span style="color: #008000;"> 2进制29</span></pre>
</div>
<h3><strong>4.2 精确到指定位数的小数</strong></h3>
<p>将数字四舍五入到指定的小数位数。使用 <code>Math.round()</code> 和模板字面量将数字四舍五入为指定的小数位数。 省略第二个参数 <code>decimals</code> ，数字将被四舍五入到一个整数。</p>
<div class="cnblogs_code">
<pre><code>const round = (n, decimals = 0) =&gt; Number(`${Math.round(`${n}e${decimals}`)}e-<span style="color: #000000;">${decimals}`)
round(</span>1.345, 2)                 <span style="color: #008000;">//</span><span style="color: #008000;"> 1.35</span>
round(1.345, 1)                 <span style="color: #008000;">//</span><span style="color: #008000;"> 1.3</span></pre>
</div>
<h3><strong>4.3 数字补0操作</strong></h3>
<p>感谢网友 @JserWang @vczhan 提供 这个小技巧</p>
<p>有时候比如显示时间的时候有时候会需要把一位数字显示成两位，这时候就需要补0操作，可以使用 <code>slice</code>和string的 <code>padStart</code>方法</p>
<div class="cnblogs_code">
<pre><code>const addZero1 = (num, len = 2) =&gt; (`0${num}`).slice(-<span style="color: #000000;">len)
const addZero2 </span>= (num, len = 2) =&gt; (`${num}`).padStart( len   , '0'<span style="color: #000000;">)
addZero1(</span>3) <span style="color: #008000;">//</span><span style="color: #008000;"> 03</span>
<span style="color: #000000;">
addZero2(</span>32,4)  <span style="color: #008000;">//</span><span style="color: #008000;"> 0032</span></pre>
</div>
<h3>5、数组</h3>
<h3><strong>5.1 reduce方法同时实现map和filter</strong></h3>
<p>假设现在有一个数列，你希望更新它的每一项（map的功能）然后筛选出一部分（filter的功能）。如果是先使用map然后filter的话，你需要遍历这个数组两次。</p>
<p>在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于50的数。</p>
<div class="cnblogs_code">
<pre><code>const numbers = [10, 20, 30, 40<span style="color: #000000;">];
const doubledOver50 </span>= numbers.reduce((finalList, num) =&gt;<span style="color: #000000;"> {
  num </span>= num * 2<span style="color: #000000;">;
  </span><span style="color: #0000ff;">if</span> (num &gt; 50<span style="color: #000000;">) {
    finalList.push(num);
  }
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> finalList;
}, []);
doubledOver50;            </span><span style="color: #008000;">//</span><span style="color: #008000;"> [60, 80]</span></pre>
</div>
<h3><strong>5.2 统计数组中相同项的个数</strong></h3>
<p>很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。</p>
<p>下面的代码将统计每一种车的数目然后把总数用一个对象表示。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'<span style="color: #000000;">];
</span><span style="color: #0000ff;">var</span> carsObj = cars.reduce(<span style="color: #0000ff;">function</span><span style="color: #000000;"> (obj, name) {
  obj[name] </span>= obj[name] ? ++obj[name] : 1<span style="color: #000000;">;
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> obj;
}, {});
carsObj; </span><span style="color: #008000;">//</span><span style="color: #008000;"> =&gt; { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }</span></pre>
</div>
<h3><strong>5.3 使用解构来交换参数数值</strong></h3>
<p>有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。</p>
<div class="cnblogs_code">
<pre><code>let param1 = 1<span style="color: #000000;">;
let param2 </span>= 2<span style="color: #000000;">;
[param1, param2] </span>=<span style="color: #000000;"> [param2, param1];
console.log(param1) </span><span style="color: #008000;">//</span><span style="color: #008000;"> 2</span>
console.log(param2) <span style="color: #008000;">//</span><span style="color: #008000;"> 1</span></pre>
</div>
<p>当然我们关于交换数值有不少其他办法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> temp = a; a = b; b =<span style="color: #000000;"> temp            
b </span>= [a, a = b][0<span style="color: #000000;">]                     
a </span>= a + b; b = a - b; a = a - b        </pre>
</div>
<h3><strong>5.4 接收函数返回的多个结果</strong></h3>
<p>在下面的代码中，我们从/post中获取一个帖子，然后在/comments中获取相关评论。由于我们使用的是async/await，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。</p>
<div class="cnblogs_code">
<pre><code>async <span style="color: #0000ff;">function</span><span style="color: #000000;"> getFullPost(){
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> await Promise.all([
     fetch(</span>'/post'<span style="color: #000000;">),
     fetch(</span>'/comments'<span style="color: #000000;">)
  ]);
}
const [post, comments] </span>= getFullPost();</pre>
</div>
<h3><strong>5.5 将数组平铺到指定深度</strong></h3>
<p>使用递归，为每个深度级别 <code>depth</code> 递减 1 。 使用 <code>Array.reduce()</code> 和 <code>Array.concat()</code> 来合并元素或数组。 基本情况下， <code>depth</code> 等于 1 停止递归。 省略第二个参数， <code>depth</code> 只能平铺到 1 (单层平铺) 的深度。</p>
<div class="cnblogs_code">
<pre><code>const flatten = (arr, depth = 1) =&gt;<span style="color: #000000;">
  depth </span>!= 1
    ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flatten(v, depth - 1<span style="color: #000000;">) : v), [])
    : arr.reduce((a, v) </span>=&gt;<span style="color: #000000;"> a.concat(v), []);
flatten([</span>1, [2], 3, 4]);                             <span style="color: #008000;">//</span><span style="color: #008000;"> [1, 2, 3, 4]</span>
flatten([1, [2, [3, [4, 5], 6], 7], 8], 2);           <span style="color: #008000;">//</span><span style="color: #008000;"> [1, 2, 3, [4, 5], 6, 7, 8]</span></pre>
</div>
<h3><strong>5.6 数组的对象解构</strong></h3>
<p>数组也可以对象解构，可以方便的获取数组的第n个值</p>
<div class="cnblogs_code">
<pre><code>const csvFileLine = '1997,John Doe,US,john@doe.com,New York'<span style="color: #000000;">;
const { </span>2: country, 4: state } = csvFileLine.split(','<span style="color: #000000;">);

country            </span><span style="color: #008000;">//</span><span style="color: #008000;"> US</span>
state            <span style="color: #008000;">//</span><span style="color: #008000;"> New Yourk</span></pre>
</div>
<h3>6、对象</h3>
<h3><strong>6.1 使用解构删除不必要属性</strong></h3>
<p>有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（just too big）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。</p>
<p>下面的代码里，我们希望删除_internal和tooBig参数。我们可以把它们赋值给internal和tooBig变量，然后在cleanObject中存储剩下的属性以备后用。</p>
<div class="cnblogs_code">
<pre><code>let {_internal, tooBig, ...cleanObject} = {el1: '1', _internal:"secret", tooBig:{}, el2: '2', el3: '3'<span style="color: #000000;">};

console.log(cleanObject);                         </span><span style="color: #008000;">//</span><span style="color: #008000;"> {el1: '1', el2: '2', el3: '3'}</span></pre>
</div>
<h3><strong>6.2 在函数参数中解构嵌套对象</strong></h3>
<p>在下面的代码中，engine是对象car中嵌套的一个对象。如果我们对engine的vin属性感兴趣，使用解构赋值可以很轻松地得到它。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> car =<span style="color: #000000;"> {
  model: </span>'bmw 2018'<span style="color: #000000;">,
  engine: {
    v6: </span><span style="color: #0000ff;">true</span><span style="color: #000000;">,
    turbo: </span><span style="color: #0000ff;">true</span><span style="color: #000000;">,
    vin: </span>12345<span style="color: #000000;">
  }
}
const modelAndVIN </span>= ({model, engine: {vin}}) =&gt;<span style="color: #000000;"> {
  console.log(`model: ${model} vin: ${vin}`);
}
modelAndVIN(car); </span><span style="color: #008000;">//</span><span style="color: #008000;"> =&gt; model: bmw 2018  vin: 12345</span></pre>
</div>
<h3>7、代码复用</h3>
<h3><strong>7.1 Object [key]</strong></h3>
<p>虽然将 <code>foo.bar</code> 写成 <code>foo['bar']</code> 是一种常见的做法，但是这种做法构成了编写可重用代码的基础。许多框架使用了这种方法，比如element的表单验证。</p>
<p>请考虑下面这个验证函数的简化示例：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> validate(values) {
  </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">values.first)
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
  </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">values.last)
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
  </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
console.log(validate({first:</span>'Bruce',last:'Wayne'})); <span style="color: #008000;">//</span><span style="color: #008000;"> true</span></pre>
</div>
<p>上面的函数完美的完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。如果可以构建一个在运行时配置的通用验证函数，会是一个好选择。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> object validation rules</span>
const schema =<span style="color: #000000;"> {
  first: {
    required:</span><span style="color: #0000ff;">true</span><span style="color: #000000;">
  },
  last: {
    required:</span><span style="color: #0000ff;">true</span><span style="color: #000000;">
  }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> universal validation function</span>
const validate = (schema, values) =&gt;<span style="color: #000000;"> {
  </span><span style="color: #0000ff;">for</span>(field <span style="color: #0000ff;">in</span><span style="color: #000000;"> schema) {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(schema[field].required) {
      </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">values[field]) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
      }
    }
  }
  </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
console.log(validate(schema, {first:</span>'Bruce'})); <span style="color: #008000;">//</span><span style="color: #008000;"> false</span>
console.log(validate(schema, {first:'Bruce',last:'Wayne'})); <span style="color: #008000;">//</span><span style="color: #008000;"> true</span></pre>
</div>
<p>现在有了这个验证函数，我们就可以在所有窗体中重用，而无需为每个窗体编写自定义验证函数。</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1570584768&amp;ver=1901&amp;signature=KY3nDdEdEsigZCBqgpxsLeBUQVver-VEbfTJ*DhURfPpYB-p1WVwsMxmzgNa9IajLxs2HryW2xvwsdWYKqM65KbrNCSNA-XwQvdjOgLil0R7Y*7Zh4HXPrRLMGlS4llx&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1570584768&amp;ver=1901&amp;signature=KY3nDdEdEsigZCBqgpxsLeBUQVver-VEbfTJ*DhURfPpYB-p1WVwsMxmzgNa9IajLxs2HryW2xvwsdWYKqM65KbrNCSNA-XwQvdjOgLil0R7Y*7Zh4HXPrRLMGlS4llx&amp;new=1</a></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>