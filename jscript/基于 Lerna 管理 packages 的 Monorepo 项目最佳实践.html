<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修基于 Lerna 管理 packages 的 Monorepo 项目最佳实践' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>基于 Lerna 管理 packages 的 Monorepo 项目最佳实践</center></div><div class='banquan'>原文出处:本文由博客园博主vivo互联网技术提供。<br/>
原文连接:https://www.cnblogs.com/vivotech/p/11316961.html</div><br>
    <blockquote>
<p>本文首发于 vivo互联网技术 微信公众号 <a href="https://mp.weixin.qq.com/s/NlOn7er0ixY1HO40dq5Gag" data-cke-saved-href="https://mp.weixin.qq.com/s/NlOn7er0ixY1HO40dq5Gag">https://mp.weixin.qq.com/s/NlOn7er0ixY1HO40dq5Gag</a><br />作者：孔垂亮</p>



</blockquote>
<p><strong>目录</strong></p>
<p>一、背景<br />二、Monorepo vs Multirepo<br />三、Lerna<br />1、Lerna 是什么<br />2、开始使用<br />（1）安装<br />（2）项目构建<br />四、Lerna的最佳实践<br />1、优雅的提交<br />2、自动生成日志<br />3、编译、压缩、调试<br />五、结语<br />六、参考文献</p>
<p>&nbsp;</p>
<p>对于维护过多个package的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护，本文通过一个示例讲述了如何基于Lerna管理多个package，并和其它工具整合，打造高效、完美的工作流，最终形成一个最佳实践</p>
<p>背景</p>
<p>最近在工作中接触到一个项目，这个项目是维护一套 CLI，发到 npm 上供开发者使用。先看一张图：</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践0.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践0.png" /></p>
<p>项目仓库中的根目录上就三个子模块的文件夹，分别对应三个 package，在熟悉了构建和发布流程后，有点傻了。工作流程如图中所示：</p>
<ol>
<li>
<p>使用webpack、babel和uglifyjs把 pkg-a 的 src 编译到 dist</p>



</li>
<li>
<p>使用webpack、babel和uglifyjs把 pkg-b 的 src 编译到 dist</p>



</li>
<li>
<p>使用webpack、babel和uglifyjs把 pkg-main 的 src 编译到 dist</p>



</li>
<li>
<p>最后使用拷贝文件的方式，把pkg-main、pkg-a、pkg-b中编译后的文件组装到 pkg-npm 中，最终用于发布到 npm 上去。</p>



</li>



</ol>
<p><strong>痛点</strong></p>
<ol>
<li>
<p>**不好调试。**因为最终的包是通过文件拷贝的方式组装到一起的，并且都是压缩过的，无法组建一个自上到下的调试流程（实际工作中只能加log，然后重新把包编译组装一遍看效果）</p>



</li>
<li>
<p>**包的依赖关系不清晰。**pkg-a、pkg-b索性没有版本管理，更像是源码级别的，但逻辑又比较独立。pkg-main中的package.json最终会拷贝到 pkg-npm 中，但又依赖pkg-a、pkg-b中的某些包，所以要把pkg-a、pkg-b中的依赖合并到pkg-main中。pkg-main和pkg-npm的package.json耦合在一起，导致一些本来是工程的开发依赖也会发布到 npm 上去，变成pkg-npm 的依赖包。</p>



</li>
<li>
<p>**依赖的包冗余。**可以看到，pkg-a、pkg-b、pkg-main要分别编译，都依赖了babel、webpack等，要分别 cd 到各个目录安装依赖。</p>



</li>
<li>
<p><strong>发布需要手动修改版本号。</strong>&nbsp;因为最终只发布了一个包，但实际逻辑要求这个包即要全局安装又要本地安装，业务没有拆开，导致要安装两遍。耦合一起，即便使用 npm link 也会导致调试困难，</p>



</li>
<li>
<p><strong>发版没有 <a href="http://CHANGELOG.md" data-cke-saved-href="http://CHANGELOG.md">CHANGELOG.md</a>。</strong>&nbsp;因为pkg-a、pkg-b都没有真正管理版本，所以也没有完善的CHANGELOG来记录自上个版本发布已来的变动。</p>



</li>



</ol>
<p>整个项目像是一个没有被管理起来的 Monorepo。那什么又是 Monorepo 呢？</p>
<h2>Monorepo vs Multirepo</h2>
<p>Monorepo 的全称是 monolithic repository，即单体式仓库，与之对应的是 Multirepo(multiple repository)，这里的&ldquo;单&rdquo;和&ldquo;多&rdquo;是指每个仓库中所管理的模块数量。</p>
<p>Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。例如：Rollup, ...</p>
<p>Monorep 是把所有相关的 package 都放在一个仓库里进行管理，<strong>每个 package 独立发布</strong>。例如：React, Angular, Babel, Jest, Umijs, Vue ...</p>
<p>一图胜千言：</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践1.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践1.png" /></p>
<p>当然到底哪一种管理方式更好，仁者见仁，智者见智。前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。</p>
<p>虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。</p>
<p>结合我们项目的实际场景和业务需要，天然的 MonoRepo ! 因为工程化的最终目的是让业务开发可以 100% 聚焦在业务逻辑上，那么这不仅仅是脚手架、框架需要从自动化、设计上解决的问题，这涉及到仓库管理的设计。</p>
<p>一个理想的开发环境可以抽象成这样：</p>
<p><strong>&ldquo;只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。&rdquo;</strong></p>
<p>在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。</p>
<p>上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna是业界知名度最高的 Monorepo 管理工具，功能完整。</p>
<h2>Lerna</h2>
<h3>一、Lerna 是什么</h3>
<blockquote>
<p>A tool for managing JavaScript projects with multiple packages.</p>



</blockquote>
<blockquote>
<p>Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.</p>



</blockquote>
<p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p>
<p>Lerna 现在已经被很多著名的项目组织使用，如：Babel, React, Vue, Angular, Ember, Meteor, Jest 。</p>
<p>一个基本的 Lerna 管理的仓库结构如下：</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践2.png" alt="" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践2.png" /></p>
<h4><strong>安装</strong></h4>
<blockquote>
<p>推荐全局安装，因为会经常用到 lerna 命令</p>



</blockquote>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="22">
<pre><code><code>npm i -g lerna
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<h4><strong>项目构建</strong></h4>
<p><strong>1.初始化</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="21">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22lerna%20init%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>lerna init
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p>init 命令详情 请参考&nbsp;lerna init</p>
</blockquote>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践7.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践7.png" /></p>
<p>其中 package.json &amp; lerna.json 如下:</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="20">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20package.json%5Cn%7B%5Cn%20%20%5C%22name%5C%22%3A%20%5C%22root%5C%22%2C%5Cn%20%20%5C%22private%5C%22%3A%20true%2C%20%2F%2F%20%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%8C%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%8F%91%E5%B8%83%EF%BC%8C%E6%98%AF%E7%AE%A1%E7%90%86%E6%95%B4%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%B8%8E%E8%A6%81%E5%8F%91%E5%B8%83%E5%88%B0npm%E7%9A%84%E8%A7%A3%E8%80%A6%5Cn%20%20%5C%22devDependencies%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22lerna%5C%22%3A%20%5C%22%5E3.15.0%5C%22%5Cn%20%20%7D%5Cn%7D%5Cn%20%5Cn%2F%2F%20lerna.json%5Cn%7B%5Cn%20%20%5C%22packages%5C%22%3A%20%5B%5Cn%20%20%20%20%5C%22packages%2F*%5C%22%5Cn%20%20%5D%2C%5Cn%20%20%5C%22version%5C%22%3A%20%5C%220.0.0%5C%22%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// package.json
{
  "name": "root",
  "private": true, // 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦
  "devDependencies": {
    "lerna": "^3.15.0"
  }
}
 
// lerna.json
{
  "packages": [
    "packages/*"
  ],
  "version": "0.0.0"
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>2.增加两个 packages</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="19">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22lerna%20create%20%40mo-demo%2Fcli%5Cnlerna%20create%20%40mo-demo%2Fcli-shared-utils%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>lerna create @mo-demo/cli
lerna create @mo-demo/cli-shared-utils
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p>create 命令详情 请参考&nbsp;lerna create</p>
</blockquote>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践12.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践12.png" /></p>
<p><strong>3.分别给相应的 package 增加依赖模块</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="18">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22lerna%20add%20chalk%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E4%B8%BA%E6%89%80%E6%9C%89%20package%20%E5%A2%9E%E5%8A%A0%20chalk%20%E6%A8%A1%E5%9D%97%5Cnlerna%20add%20semver%20--scope%20%40mo-demo%2Fcli-shared-utils%20%20%20%20%20%20%20%20%2F%2F%20%E4%B8%BA%20%40mo-demo%2Fcli-shared-utils%20%E5%A2%9E%E5%8A%A0%20semver%20%E6%A8%A1%E5%9D%97%5Cnlerna%20add%20%40mo-demo%2Fcli-shared-utils%20--scope%20%40mo-demo%2Fcli%20%20%2F%2F%20%E5%A2%9E%E5%8A%A0%E5%86%85%E9%83%A8%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>lerna add chalk                                           // 为所有 package 增加 chalk 模块
lerna add semver --scope @mo-demo/cli-shared-utils        // 为 @mo-demo/cli-shared-utils 增加 semver 模块
lerna add @mo-demo/cli-shared-utils --scope @mo-demo/cli  // 增加内部模块之间的依赖
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p>add 命令详情 请参考&nbsp;lerna add</p>
</blockquote>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践15.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践15.png" /></p>
<p><strong>4.发布</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="17">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22lerna%20publish%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>lerna publish
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p>publish 命令详情 请参考&nbsp;lerna publish</p>
</blockquote>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践18.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践18.png" /></p>
<p>如下是发布的情况，lerna会让你选择要发布的版本号，我发了@0.0.1-alpha.0 的版本。</p>
<blockquote>
<p><strong>发布 npm 包需要登陆 npm 账号</strong></p>
</blockquote>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践19.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践19.png" /></p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践20.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践20.png" /></p>
<p><strong>5.安装依赖包 &amp; 清理依赖包</strong></p>
<p>上述1-4步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。</p>
<p>我们在第4步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 node_modules 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 node_modules ，也不清爽。于是我们使用 --hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="16">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22lerna%20bootstrap%20--hoist%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>lerna bootstrap --hoist
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p>bootstrap 命令详情 请参考&nbsp;lerna bootstrap</p>
</blockquote>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践23.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践23.png" /></p>
<p><strong>为了省去每次都输入 --hoist 参数的麻烦，可以在 lerna.json 配置：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="15">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%7B%5Cn%20%20%5C%22packages%5C%22%3A%20%5B%5Cn%20%20%20%20%5C%22packages%2F*%5C%22%5Cn%20%20%5D%2C%5Cn%20%20%5C%22command%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22bootstrap%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%5C%22hoist%5C%22%3A%20true%5Cn%20%20%20%20%7D%5Cn%20%20%7D%2C%5Cn%20%20%5C%22version%5C%22%3A%20%5C%220.0.1-alpha.0%5C%22%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>{
  "packages": [
    "packages/*"
  ],
  "command": {
    "bootstrap": {
      "hoist": true
    }
  },
  "version": "0.0.1-alpha.0"
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p>配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="14">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22lerna%20clean%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>lerna clean
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p>然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 node_modules 中了。</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践28.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践28.png" /></p>
<h2>Lerna的最佳实践</h2>
<p>lerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。</p>
<h3>一、优雅的提交</h3>
<p><strong>1.commitizen &amp;&amp; cz-lerna-changelog</strong></p>
<p>commitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。</p>
<p>cz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践29.png" alt="" width="500" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践29.png" /></p>
<p>我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。</p>
<p>因为这是整个工程的开发依赖，所以在根目录安装：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="13">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22npm%20i%20-D%20commitizen%5Cnnpm%20i%20-D%20cz-lerna-changelog%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>npm i -D commitizen
npm i -D cz-lerna-changelog
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p>安装完成后，在 package.json 中增加 config 字段，把 cz-lerna-changelog 配置给 commitizen。同时因为commitizen不是全局安全的，所以需要添加 scripts 脚本来执行 git-cz</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="12">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%7B%5Cn%20%20%5C%22name%5C%22%3A%20%5C%22root%5C%22%2C%5Cn%20%20%5C%22private%5C%22%3A%20true%2C%5Cn%20%20%5C%22scripts%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22c%5C%22%3A%20%5C%22git-cz%5C%22%5Cn%20%20%7D%2C%5Cn%20%20%5C%22config%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22commitizen%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%5C%22path%5C%22%3A%20%5C%22.%2Fnode_modules%2Fcz-lerna-changelog%5C%22%5Cn%20%20%20%20%7D%5Cn%20%20%7D%2C%5Cn%20%20%5C%22devDependencies%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22commitizen%5C%22%3A%20%5C%22%5E3.1.1%5C%22%2C%5Cn%20%20%20%20%5C%22cz-lerna-changelog%5C%22%3A%20%5C%22%5E2.0.2%5C%22%2C%5Cn%20%20%20%20%5C%22lerna%5C%22%3A%20%5C%22%5E3.15.0%5C%22%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>{
  "name": "root",
  "private": true,
  "scripts": {
    "c": "git-cz"
  },
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-lerna-changelog"
    }
  },
  "devDependencies": {
    "commitizen": "^3.1.1",
    "cz-lerna-changelog": "^2.0.2",
    "lerna": "^3.15.0"
  }
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p>之后在常规的开发中就可以使用 npm run c 来根据提示一步一步输入，来完成代码的提交。</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践34.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践34.png" /></p>
<p><strong>2.commitlint &amp;&amp; husky</strong></p>
<p>上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用 npm run c 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="11">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%E5%AE%89%E8%A3%85%20commitlint%20%E4%BB%A5%E5%8F%8A%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E8%8C%83%5Cnnpm%20i%20-D%20%40commitlint%2Fcli%20%40commitlint%2Fconfig-conventional%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// 安装 commitlint 以及要遵守的规范
npm i -D @commitlint/cli @commitlint/config-conventional
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="10">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%E5%9C%A8%E5%B7%A5%E7%A8%8B%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%BA%20commitlint%20%E5%A2%9E%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20commitlint.config.js%20%E4%B8%BAcommitlint%20%E6%8C%87%E5%AE%9A%E7%9B%B8%E5%BA%94%E7%9A%84%E8%A7%84%E8%8C%83%5Cnmodule.exports%20%3D%20%7B%20extends%3A%20%5B'%40commitlint%2Fconfig-conventional'%5D%20%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// 在工程根目录为 commitlint 增加配置文件 commitlint.config.js 为commitlint 指定相应的规范
module.exports = { extends: ['@commitlint/config-conventional'] }
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="9">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%E5%AE%89%E8%A3%85%20husky%5Cnnpm%20i%20-D%20husky%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// 安装 husky
npm i -D husky
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="8">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%E5%9C%A8%20package.json%20%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%A6%82%E4%B8%8B%E9%85%8D%E7%BD%AE%5Cn%5C%22husky%5C%22%3A%20%7B%5Cn%20%20%5C%22hooks%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22commit-msg%5C%22%3A%20%5C%22commitlint%20-E%20HUSKY_GIT_PARAMS%5C%22%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// 在 package.json 中增加如下配置
"husky": {
  "hooks": {
    "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
  }
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p>"commit-msg"是git提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 npm run c 来提交。</p>
<p><strong>3.standardjs &amp;&amp; lint-staged</strong></p>
<p>除了规范提交信息，代码本身肯定也少了靠规范来统一风格。</p>
<p>standardjs就是完整的一套 JavaScript 代码规范，自带 linter &amp; 代码自动修正。它无需配置，自动格式化代码并修正，提前发现风格以及程序问题。</p>
<p>lint-staged staged 是 Git 里的概念，表示暂存区，lint-staged 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="7">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%E5%AE%89%E8%A3%85%5Cnnpm%20i%20-D%20standard%20lint-staged%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// 安装
npm i -D standard lint-staged
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="6">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20package.json%5Cn%7B%5Cn%20%20%5C%22name%5C%22%3A%20%5C%22root%5C%22%2C%5Cn%20%20%5C%22private%5C%22%3A%20true%2C%5Cn%20%20%5C%22scripts%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22c%5C%22%3A%20%5C%22git-cz%5C%22%5Cn%20%20%7D%2C%5Cn%20%20%5C%22config%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22commitizen%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%5C%22path%5C%22%3A%20%5C%22.%2Fnode_modules%2Fcz-lerna-changelog%5C%22%5Cn%20%20%20%20%7D%5Cn%20%20%7D%2C%5Cn%20%20%5C%22husky%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22hooks%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%5C%22pre-commit%5C%22%3A%20%5C%22lint-staged%5C%22%2C%5Cn%20%20%20%20%20%20%5C%22commit-msg%5C%22%3A%20%5C%22commitlint%20-E%20HUSKY_GIT_PARAMS%5C%22%5Cn%20%20%20%20%7D%5Cn%20%20%7D%2C%5Cn%20%20%5C%22lint-staged%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22*.js%5C%22%3A%20%5B%5Cn%20%20%20%20%20%20%5C%22standard%20--fix%5C%22%2C%5Cn%20%20%20%20%20%20%5C%22git%20add%5C%22%5Cn%20%20%20%20%5D%5Cn%20%20%7D%2C%5Cn%20%20%5C%22devDependencies%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22%40commitlint%2Fcli%5C%22%3A%20%5C%22%5E8.1.0%5C%22%2C%5Cn%20%20%20%20%5C%22%40commitlint%2Fconfig-conventional%5C%22%3A%20%5C%22%5E8.1.0%5C%22%2C%5Cn%20%20%20%20%5C%22commitizen%5C%22%3A%20%5C%22%5E3.1.1%5C%22%2C%5Cn%20%20%20%20%5C%22cz-lerna-changelog%5C%22%3A%20%5C%22%5E2.0.2%5C%22%2C%5Cn%20%20%20%20%5C%22husky%5C%22%3A%20%5C%22%5E3.0.0%5C%22%2C%5Cn%20%20%20%20%5C%22lerna%5C%22%3A%20%5C%22%5E3.15.0%5C%22%2C%5Cn%20%20%20%20%5C%22lint-staged%5C%22%3A%20%5C%22%5E9.2.0%5C%22%2C%5Cn%20%20%20%20%5C%22standard%5C%22%3A%20%5C%22%5E13.0.2%5C%22%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// package.json
{
  "name": "root",
  "private": true,
  "scripts": {
    "c": "git-cz"
  },
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-lerna-changelog"
    }
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.js": [
      "standard --fix",
      "git add"
    ]
  },
  "devDependencies": {
    "@commitlint/cli": "^8.1.0",
    "@commitlint/config-conventional": "^8.1.0",
    "commitizen": "^3.1.1",
    "cz-lerna-changelog": "^2.0.2",
    "husky": "^3.0.0",
    "lerna": "^3.15.0",
    "lint-staged": "^9.2.0",
    "standard": "^13.0.2"
  }
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p>安装完成后，在 package.json 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 standard --fix 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky的配置中增加'pre-commit'的钩子用来执行 lint-staged 的校验操作，如上所示。</p>
<p>此时提交 js 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。</p>
<h3>二、自动生成日志</h3>
<p>有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：</p>
<p>1.调用&nbsp;lerna version</p>
<ul>
<li>
<p>找出从上一个版本发布以来有过变更的 package</p>
</li>
<li>
<p>提示开发者确定要发布的版本号</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践47.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践47.png" /></p>
</li>
<li>
<p>将所有更新过的的 package 中的package.json的version字段更新</p>
</li>
<li>
<p>将依赖更新过的 package 的 包中的依赖版本号更新</p>
</li>
<li>
<p>更新 lerna.json 中的 version 字段</p>
</li>
<li>
<p>提交上述修改，并打一个 tag</p>
</li>
<li>
<p>推送到 git 仓库</p>
</li>
</ul>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践48.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践48.png" /></p>
<p>2.使用&nbsp;npm publish&nbsp;将新版本推送到 npm</p>
<p>CHANGELOG 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数&nbsp;--conventional-commits。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 lerna.json中，如下：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="5">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%7B%5Cn%20%20%5C%22packages%5C%22%3A%20%5B%5Cn%20%20%20%20%5C%22packages%2F*%5C%22%5Cn%20%20%5D%2C%5Cn%20%20%5C%22command%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22bootstrap%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%5C%22hoist%5C%22%3A%20true%5Cn%20%20%20%20%7D%2C%5Cn%20%20%20%20%5C%22version%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%5C%22conventionalCommits%5C%22%3A%20true%5Cn%20%20%20%20%7D%5Cn%20%20%7D%2C%5Cn%20%20%5C%22ignoreChanges%5C%22%3A%20%5B%5Cn%20%20%20%20%5C%22**%2F*.md%5C%22%5Cn%20%20%5D%2C%5Cn%20%20%5C%22version%5C%22%3A%20%5C%220.0.1-alpha.1%5C%22%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>{
  "packages": [
    "packages/*"
  ],
  "command": {
    "bootstrap": {
      "hoist": true
    },
    "version": {
      "conventionalCommits": true
    }
  },
  "ignoreChanges": [
    "**/*.md"
  ],
  "version": "0.0.1-alpha.1"
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p>lerna version 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 ignoreChanges 配置排除。如上。</p>
</blockquote>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践51.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践51.png" /></p>
<blockquote>
<p>实际 lerna version 很少直接使用，因为它包含在 lerna publish 中了，直接使用 lerna publish就好了。</p>
</blockquote>
<blockquote>
<p>Lerna 在管理 package 的版本号上，提供了两种模式供选择 Fixed or Independent。默认是 Fixed，更多细节，以及 Lerna 的更多玩法，请参考官网文档：</p>
<p><a href="https://github.com/lerna/lerna/blob/master/README.md" data-cke-saved-href="https://github.com/lerna/lerna/blob/master/README.md"><em>https://github.com/lerna/lerna/blob/master/README.md</em></a></p>
</blockquote>
<h3>三、编译、压缩、调试</h3>
<p><strong>采用 Monorepo 结构的项目，各个 package 的结构最好保持统一。</strong></p>
<p>根据目前的项目状况，设计如下：</p>
<ol>
<li>
<p>各 package 入口统一为 index.js</p>
</li>
<li>
<p>各 package 源码入口统一为 src/index.js</p>
</li>
<li>
<p>各 package 编译入口统一为 dist/index.js</p>
</li>
<li>
<p>各 package 统一使用 ES6 语法、使用 Babel 编译、压缩并输出到 dist</p>
</li>
<li>
<p>各 package 发布时只发布 dist 目录，不发布 src 目录</p>
</li>
<li>
<p>各 package 注入 LOCAL_DEBUG 环境变量， 在index.js 中区分是调试还是发布环境，调试环境 ruquire(./src/index.js)&nbsp;保证所有源码可调试。发布环境 ruquire(./dist/index.js)&nbsp;保证所有源码不被发布。</p>
</li>
</ol>
<blockquote>
<p>因为 dist 是 Babel 编译后的目录，我们在搜索时不希望搜索它的内容，所以在工程的设置中把 dist 目录排除在搜索的范围之外。</p>
</blockquote>
<p>接下来，我们按上面的规范，搭建 package 的结构。</p>
<p><strong>首先安装依赖</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="4">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22npm%20i%20-D%20%40babel%2Fcli%20%40babel%2Fcore%20%40babel%2Fpreset-env%20%20%2F%2F%20%E4%BD%BF%E7%94%A8%20Babel%20%E5%BF%85%E5%A4%87%20%E8%AF%A6%E8%A7%81%E5%AE%98%E7%BD%91%E7%94%A8%E6%B3%95%5Cnnpm%20i%20-D%20%40babel%2Fnode%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E7%94%A8%E4%BA%8E%E8%B0%83%E8%AF%95%20%E5%9B%A0%E4%B8%BA%E7%94%A8%E4%BA%86%20import%26export%20%E7%AD%89%20ES6%20%E7%9A%84%E8%AF%AD%E6%B3%95%5Cnnpm%20i%20-D%20babel-preset-minify%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E7%94%A8%E4%BA%8E%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>npm i -D @babel/cli @babel/core @babel/preset-env  // 使用 Babel 必备 详见官网用法
npm i -D @babel/node                               // 用于调试 因为用了 import&amp;export 等 ES6 的语法
npm i -D babel-preset-minify                       // 用于压缩代码
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p>由于各 package 的结构统一，所以类似 Babel 这样的工具，只在根目录安装就好了，不需要在各 package 中安装，简直是清爽的要死了。</p>
</blockquote>
<p><strong>增加 Babel 配置</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="3">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%96%B0%E5%BB%BA%20babel.config.js%5Cnmodule.exports%20%3D%20function%20(api)%20%7B%5Cn%20%20api.cache(true)%5Cn%20%5Cn%20%20const%20presets%20%3D%20%5B%5Cn%20%20%20%20%5B%5Cn%20%20%20%20%20%20'%40babel%2Fenv'%2C%5Cn%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20targets%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20node%3A%20'8.9'%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%5D%5Cn%20%20%5D%5Cn%20%5Cn%20%20%2F%2F%20%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E6%89%8D%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8D%E7%84%B6%E8%B0%83%E8%AF%95%E7%9C%8B%E4%B8%8D%E5%88%B0%E5%AE%9E%E9%99%85%E5%8F%98%E9%87%8F%E5%90%8D%5Cn%20%20if%20(!process.env%5B'LOCAL_DEBUG'%5D)%20%7B%5Cn%20%20%20%20presets.push(%5B%5Cn%20%20%20%20%20%20'minify'%5Cn%20%20%20%20%5D)%5Cn%20%20%7D%5Cn%20%5Cn%20%20const%20plugins%20%3D%20%5B%5D%5Cn%20%5Cn%20%20return%20%7B%5Cn%20%20%20%20presets%2C%5Cn%20%20%20%20plugins%2C%5Cn%20%20%20%20ignore%3A%20%5B'node_modules'%5D%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// 根目录新建 babel.config.js
module.exports = function (api) {
  api.cache(true)
 
  const presets = [
    [
      '@babel/env',
      {
        targets: {
          node: '8.9'
        }
      }
    ]
  ]
 
  // 非本地调试模式才压缩代码，不然调试看不到实际变量名
  if (!process.env['LOCAL_DEBUG']) {
    presets.push([
      'minify'
    ])
  }
 
  const plugins = []
 
  return {
    presets,
    plugins,
    ignore: ['node_modules']
  }
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>修改各 package 的代码</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="2">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%40mo-demo%2Fcli%2Findex.js%5Cnif%20(process.env.LOCAL_DEBUG)%20%7B%5Cn%20%20require('.%2Fsrc%2Findex')%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E6%98%AF%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8A%A0%E8%BD%BDsrc%E4%B8%AD%E7%9A%84%E6%BA%90%E7%A0%81%5Cn%7D%20else%20%7B%5Cn%20%20require('.%2Fdist%2Findex')%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20dist%E4%BC%9A%E5%8F%91%E5%88%B0npm%5Cn%7D%5Cn%20%5Cn%2F%2F%20%40mo-demo%2Fcli%2Fsrc%2Findex.js%5Cnimport%20%7B%20log%20%7D%20from%20'%40mo-demo%2Fcli-shared-utils'%20%20%2F%2F%20%E4%BB%8E%20utils%20%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%B9%B6%E4%BD%BF%E7%94%A8%20log%20%E5%87%BD%E6%95%B0%5Cnlog('cli%2Findex.js%20as%20cli%20entry%20exec!')%5Cn%20%5Cn%2F%2F%20%40mo-demo%2Fcli%2Fpackage.json%5Cn%7B%5Cn%20%20%5C%22main%5C%22%3A%20%5C%22index.js%5C%22%2C%5Cn%20%20%5C%22files%5C%22%3A%20%5B%5Cn%20%20%20%20%5C%22dist%5C%22%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%91%E5%B8%83%20dist%5Cn%20%20%5D%5Cn%7D%5Cn%20%5Cn%20%5Cn%2F%2F%20%40mo-demo%2Fcli-shared-utils%2Findex.js%5Cnif%20(process.env.LOCAL_DEBUG)%20%7B%5Cn%20%20module.exports%20%3D%20require('.%2Fsrc%2Findex')%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E6%98%AF%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8A%A0%E8%BD%BDsrc%E4%B8%AD%E7%9A%84%E6%BA%90%E7%A0%81%5Cn%7D%20else%20%7B%5Cn%20%20module.exports%20%3D%20require('.%2Fdist%2Findex')%20%20%20%20%20%20%20%2F%2F%20dist%E4%BC%9A%E5%8F%91%E5%88%B0npm%5Cn%7D%5Cn%20%5Cn%2F%2F%20%40mo-demo%2Fcli-shared-utils%2Fsrc%2Findex.js%5Cnconst%20log%20%3D%20function%20(str)%20%7B%5Cn%20%20console.log(str)%5Cn%7D%5Cnexport%20%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%AF%BC%E5%87%BA%20log%20%E6%8E%A5%E5%8F%A3%5Cn%20%20log%5Cn%7D%5Cn%20%5Cn%2F%2F%20%40mo-demo%2Fcli-shared-utils%2Fpackage.json%5Cn%7B%5Cn%20%20%5C%22main%5C%22%3A%20%5C%22index.js%5C%22%2C%5Cn%20%20%5C%22files%5C%22%3A%20%5B%5Cn%20%20%20%20%5C%22dist%5C%22%5Cn%20%20%5D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// @mo-demo/cli/index.js
if (process.env.LOCAL_DEBUG) {
  require('./src/index')                        // 如果是调试模式，加载src中的源码
} else {
  require('./dist/index')                       // dist会发到npm
}
 
// @mo-demo/cli/src/index.js
import { log } from '@mo-demo/cli-shared-utils'  // 从 utils 模块引入依赖并使用 log 函数
log('cli/index.js as cli entry exec!')
 
// @mo-demo/cli/package.json
{
  "main": "index.js",
  "files": [
    "dist"                                       // 发布 dist
  ]
}
 
 
// @mo-demo/cli-shared-utils/index.js
if (process.env.LOCAL_DEBUG) {
  module.exports = require('./src/index')        // 如果是调试模式，加载src中的源码
} else {
  module.exports = require('./dist/index')       // dist会发到npm
}
 
// @mo-demo/cli-shared-utils/src/index.js
const log = function (str) {
  console.log(str)
}
export {                                         //导出 log 接口
  log
}
 
// @mo-demo/cli-shared-utils/package.json
{
  "main": "index.js",
  "files": [
    "dist"
  ]
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>修改发布的脚本</strong></p>
<p>npm run b 用来对各 pacakge 执行 babel 的编译，从 src 目录输出出 dist 目录，使用根目录的配置文件 babel.config.js。</p>
<p>npm run p 用来取代 lerna publish，在 publish 前先执行 npm run b来编译。</p>
<p>其它常用的 lerna 命令也添加到 scripts 中来，方便使用。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20%E5%B7%A5%E7%A8%8B%E6%A0%B9%E7%9B%AE%E5%BD%95%20package.json%5Cn%20%5C%22scripts%5C%22%3A%20%7B%5Cn%20%20%20%5C%22c%5C%22%3A%20%5C%22git-cz%5C%22%2C%5Cn%20%20%20%5C%22i%5C%22%3A%20%5C%22lerna%20bootstrap%5C%22%2C%5Cn%20%20%20%5C%22u%5C%22%3A%20%5C%22lerna%20clean%5C%22%2C%5Cn%20%20%20%5C%22p%5C%22%3A%20%5C%22npm%20run%20b%20%26%26%20lerna%20publish%5C%22%2C%5Cn%20%20%20%5C%22b%5C%22%3A%20%5C%22lerna%20exec%20--%20babel%20src%20-d%20dist%20--config-file%20..%2F..%2Fbabel.config.js%5C%22%5Cn%20%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// 工程根目录 package.json
 "scripts": {
   "c": "git-cz",
   "i": "lerna bootstrap",
   "u": "lerna clean",
   "p": "npm run b &amp;&amp; lerna publish",
   "b": "lerna exec -- babel src -d dist --config-file ../../babel.config.js"
 }
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>调试</strong></p>
<p>我们使用vscode自带的调试功能调试，也可以使用 Node + Chrome 调试，看开发者习惯。</p>
<p>我们就 vscode 为例，请参考&nbsp;<a href="https://code.visualstudio.com/docs/editor/debugging" data-cke-saved-href="https://code.visualstudio.com/docs/editor/debugging"><em>https://code.visualstudio.com/docs/editor/debugging</em></a>。</p>
<p>增加如下调试配置文件：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="0">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22%2F%2F%20.vscode%2Flaunch.json%5Cn%7B%5Cn%20%20%20%20%2F%2F%20%E4%BD%BF%E7%94%A8%20IntelliSense%20%E4%BA%86%E8%A7%A3%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E3%80%82%5Cn%20%20%20%20%2F%2F%20%E6%82%AC%E5%81%9C%E4%BB%A5%E6%9F%A5%E7%9C%8B%E7%8E%B0%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84%E6%8F%8F%E8%BF%B0%E3%80%82%5Cn%20%20%20%20%2F%2F%20%E6%AC%B2%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%3A%20https%3A%2F%2Fgo.microsoft.com%2Ffwlink%2F%3Flinkid%3D830387%5Cn%20%20%20%20%5C%22version%5C%22%3A%20%5C%220.2.0%5C%22%2C%5Cn%20%20%20%20%5C%22configurations%5C%22%3A%20%5B%5Cn%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22type%5C%22%3A%20%5C%22node%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22request%5C%22%3A%20%5C%22launch%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22name%5C%22%3A%20%5C%22debug%20cli%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22runtimeExecutable%5C%22%3A%20%5C%22%24%7BworkspaceRoot%7D%2Fnode_modules%2F.bin%2Fbabel-node%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22runtimeArgs%5C%22%3A%20%5B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5C%22%24%7BworkspaceRoot%7D%2Fpackages%2Fcli%2Fsrc%2Findex.js%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22env%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5C%22LOCAL_DEBUG%5C%22%3A%20%5C%22true%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22console%5C%22%3A%20%5C%22integratedTerminal%5C%22%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%5D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code>// .vscode/launch.json
{
    // 使用 IntelliSense 了解相关属性。
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "debug cli",
            "runtimeExecutable": "${workspaceRoot}/node_modules/.bin/babel-node",
            "runtimeArgs": [
                "${workspaceRoot}/packages/cli/src/index.js"
            ],
            "env": {
                "LOCAL_DEBUG": "true"
            },
            "console": "integratedTerminal"
        }
    ]
}
</code></pre>
<img class="cke_reset cke_widget_mask" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span></div>
<p>因为 src 的代码是 ES6 的，所以要使用 babel-node去跑调试，@babel/node 已经在前面安装过了。</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践62.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践62.png" /></p>
<p>**最棒的是，可以直接使用单步调试，调到依赖的模块中去，**如上图，我们要执行&nbsp;@mo-demo/cli-shared-utils 模块中的 log 方法，单步进入，会直接跳到&nbsp;@mo-demo/cli-shared-utils src 源码中去执行。如下图</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践63.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践63.png" /></p>
<h2>结语</h2>
<p>到这里，基本上已经构建了基于 Lerna 管理 packages 的 Monorepo 项目的最佳实践了，该有的功能都有：</p>
<ul>
<li>
<p>完善的工作流</p>
</li>
<li>
<p>流畅的调试体验</p>
</li>
<li>
<p>风格统一的编码</p>
</li>
<li>
<p>一键式的发布机制</p>
</li>
<li>
<p>完美的更新日志</p>
</li>
<li>
<p>&hellip;&hellip;</p>
</li>
</ul>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践64.png" alt="" width="650" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践64.png" /></p>
<p>当然，Lerna 还有更多的功能等待着你去发掘，还有很多可以结合 Lerna 一起使用的工具。构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但<strong>它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。</strong></p>
<h2>&mdash;&mdash;&mdash; 参考文献&nbsp;&nbsp;&mdash;&mdash;&mdash;</h2>
<ol>
<li>
<p>手摸手教你玩转 Lerna&nbsp;<a href="http://www.uedlinker.com/2018/08/17/lerna-trainning/" data-cke-saved-href="http://www.uedlinker.com/2018/08/17/lerna-trainning/"><em>http://www.uedlinker.com/2018/08/17/lerna-trainning/</em></a></p>
</li>
<li>
<p>精读《Monorepo 的优势》<a href="https://mp.weixin.qq.com/s/f2ehHTNK9rx8jNBUyhSwAA" data-cke-saved-href="https://mp.weixin.qq.com/s/f2ehHTNK9rx8jNBUyhSwAA"><em>https://mp.weixin.qq.com/s/f2ehHTNK9rx8jNBUyhSwAA</em></a></p>
</li>
<li>
<p>使用lerna优雅地管理多个package&nbsp;&nbsp;<a href="https://zhuanlan.zhihu.com/p/35237759" data-cke-saved-href="https://zhuanlan.zhihu.com/p/35237759"><em>https://zhuanlan.zhihu.com/p/35237759</em></a></p>
</li>
<li>
<p>用 husky 和 lint-staged 构建超溜的代码检查工作流&nbsp;&nbsp;<a href="https://segmentfault.com/a/1190000009546913" data-cke-saved-href="https://segmentfault.com/a/1190000009546913"><em>https://segmentfault.com/a/1190000009546913</em></a></p>
</li>
</ol>
<p>更多内容敬请关注&nbsp;<strong>vivo 互联网技术</strong>&nbsp;微信公众号</p>
<p><img src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践65.png" alt="" data-cke-saved-src="./images/基于 Lerna 管理 packages 的 Monorepo 项目最佳实践65.png" /></p>
<p>注：转载文章请先与微信号：<strong>labs2020</strong>&nbsp;联系。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>