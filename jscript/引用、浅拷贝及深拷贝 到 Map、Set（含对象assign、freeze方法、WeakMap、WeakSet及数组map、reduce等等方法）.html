<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修引用、浅拷贝及深拷贝 到 Map、Set（含对象assign、freeze方法、WeakMap、WeakSet及数组map、reduce等等方法）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>引用、浅拷贝及深拷贝 到 Map、Set（含对象assign、freeze方法、WeakMap、WeakSet及数组map、reduce等等方法）</center></div><div class='banquan'>原文出处:本文由博客园博主努力的阿洋提供。<br/>
原文连接:https://www.cnblogs.com/yubingyang/p/11576515.html</div><br>
    <h1><br /></h1><div data-v-648672b2="" data-id="5d88e1cd6fb9a06ae43a337e" itemprop="articleBody" style="word-break: break-word; line-height: 1.75; font-size: 15px; overflow-x: hidden; color: #333333; font-family: -apple-system, system-ui, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><blockquote style="margin: 22px 0px; border-left-width: 4px; border-left-color: #cbcbcb; padding: 1px 23px; color: #666666; background-color: #f8f8f8;"><p style="line-height: inherit; margin: 10px 0px;">从引用聊到深浅拷贝，从深拷贝过渡到ES6新数据结构Map及Set，再到另一个map即<code>Array.map()</code>和与其类似的<code>Array.flatMap()</code>，中间会有其他相关话题，例如<code>Object.freeze()</code>与<code>Object.assign()</code>等等。</p></blockquote><h2>前言</h2><blockquote style="margin: 22px 0px; border-left-width: 4px; border-left-color: #cbcbcb; padding: 1px 23px; color: #666666; background-color: #f8f8f8;">一边复习一边学习，分清引用与深浅拷贝的区别，并实现浅拷贝与深拷贝，之后通过对深拷贝的了解，拓展到ES6新数据结构Map及Set的介绍，再引入对另一个数组的map方法的使用与类似数组遍历方法的使用。通过一条隐式链将一长串知识点串联介绍，可能会有点杂，但也会有对各知识点不同之处有明显区分，达到更好的记忆与理解。</blockquote><h2>引用、浅拷贝及深拷贝</h2><ul style="padding: 0px 0px 0px 28px; margin: 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h3>引用</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">通常在介绍深拷贝之前，作为引子我们会看见类似以下例子：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">var</span> testObj = {   name: <span style="color: #dd1144;">'currName'</span> } <span style="font-weight: 700;">var</span> secObj = testObj secObj.name = <span style="color: #dd1144;">'changedName'</span> <span style="color: #0086b3;">console</span>.log(testObj) <span style="color: #999988;">// { name: 'changedName' }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">这其实就是一种引用，对于复杂数据结构，为了节省存储资源，符号 &#8220;=&#8221; 其实并不是将值赋给新建的变量，而是做了一个地址引用，使其指向原来存储在堆中的数据的地址，此时testObj与secObj都指向同一个地址，因此在修改secObj的数据内容时，即是对其指向的原有数据进行修改。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">对于数组有相似的引用情况，代码如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">var</span> testArr = [<span style="color: teal;">0</span>, [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>]] <span style="font-weight: 700;">var</span> secArr = testArr secArr[<span style="color: teal;">0</span>] = <span style="color: #dd1144;">'x'</span> <span style="color: #0086b3;">console</span>.log(testArr) <span style="color: #999988;">// [ 'x', [ 1, 2 ] ]</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>浅拷贝</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">对于浅拷贝，其与引用的区别，我们一边实现浅拷贝，之后进行对比再解释，实现如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">function <span style="color: #990000;">shallowCopy</span> (obj) </span>{   <span style="font-weight: 700;">var</span> retObj = {}   <span style="font-weight: 700;">for</span> (<span style="font-weight: 700;">const</span> key <span style="font-weight: 700;">in</span> obj) {     <span style="font-weight: 700;">if</span> (obj.hasOwnProperty(key)) {       retObj[key] = obj[key];     }   }   <span style="font-weight: 700;">return</span> retObj }  <span style="font-weight: 700;">var</span> testObj = {   <span style="color: #dd1144;">'name'</span>: <span style="color: #dd1144;">'currName'</span>,   <span style="color: #dd1144;">'nums'</span>: [<span style="color: teal;">1</span>, [<span style="color: teal;">2</span>, <span style="color: teal;">3</span>]],   <span style="color: #dd1144;">'objs'</span>: {     <span style="color: #dd1144;">'innerobj'</span>: <span style="color: #dd1144;">'content'</span>   } } <span style="font-weight: 700;">var</span> secObj = shallowCopy(testObj) secObj.name = <span style="color: #dd1144;">'changedName'</span> secObj.nums[<span style="color: teal;">0</span>] = <span style="color: #dd1144;">'一'</span> secObj.nums[<span style="color: teal;">1</span>] = [<span style="color: #dd1144;">'二'</span>, <span style="color: #dd1144;">'三'</span>] <span style="color: #0086b3;">console</span>.log(testObj) <span style="color: #999988;">// { name: 'currName',</span>                      <span style="color: #999988;">//   nums: [ '一', [ '二', '三' ] ],</span>                      <span style="color: #999988;">//   objs: { innerObj: 'changedContent' } }</span> <span style="color: #0086b3;">console</span>.log(secObj) <span style="color: #999988;">// { name: 'changedName',</span>                     <span style="color: #999988;">//   nums: [ '一', [ '二', '三' ] ],</span>                     <span style="color: #999988;">//   objs: { innerObj: 'changedContent' } }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">从上例可以看出经过浅拷贝后得到的对象，对于第一层数据其修改后已经不能影响之前的数据，但对于内部还存在迭代器的数据属性，还是有引用情况的存在，所以后者对这些属性的修改，依旧会影响前者中这些属性的内容。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">引用与浅拷贝的区别就在于： 对第一层数据是否依旧修改后互相影响。</p><h4>浅拷贝相关方法</h4><ul style="padding: 0px 0px 0px 28px; margin: 0.27rem 0px 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h4>Object.assign()</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">assign方法效果类似于在数组中的concat拼接方法，其可以将源对象中可枚举属性进行复制到目标对象上，并返回目标对象，该方法中第一个参数便就是目标对象，其他参数为源对象。因此该方法我们定义源对象为空对象时便可以在对拷贝的实现中使用，但需要注意的是Object.assign()其方法自身实行的便是浅拷贝，而不是深拷贝，因此通过该方法实现的拷贝只能是浅拷贝。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">实现浅拷贝代码如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">var</span> testObj = {   <span style="color: #dd1144;">'name'</span>: <span style="color: #dd1144;">'currName'</span>,   <span style="color: #dd1144;">'nums'</span>: [<span style="color: teal;">1</span>, [<span style="color: teal;">2</span>, <span style="color: teal;">3</span>]],   <span style="color: #dd1144;">'objs'</span>: {     <span style="color: #dd1144;">'innerObj'</span>: <span style="color: #dd1144;">'content'</span>   } } <span style="font-weight: 700;">var</span> secObj = <span style="color: #0086b3;">Object</span>.assign({}, testObj) secObj.name = <span style="color: #dd1144;">'changedName'</span> secObj.nums[<span style="color: teal;">0</span>] = <span style="color: #dd1144;">'一'</span> secObj.nums[<span style="color: teal;">1</span>] = [<span style="color: #dd1144;">'二'</span>, <span style="color: #dd1144;">'三'</span>] secObj.objs[<span style="color: #dd1144;">'innerObj'</span>] = <span style="color: #dd1144;">'changedContent'</span> <span style="color: #0086b3;">console</span>.log(testObj) <span style="color: #999988;">// { name: 'currName',</span>                      <span style="color: #999988;">//   nums: [ '一', [ '二', '三' ] ],</span>                      <span style="color: #999988;">//   objs: { innerObj: 'changedContent' } }</span> <span style="color: #0086b3;">console</span>.log(secObj) <span style="color: #999988;">// { name: 'changedName',</span>                     <span style="color: #999988;">//   nums: [ '一', [ '二', '三' ] ],</span>                     <span style="color: #999988;">//   objs: { innerObj: 'changedContent' } }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>Object.freeze()</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">freeze方法其效果在有一定程度与浅拷贝相同，但效果上还要比拷贝多上一层，即freeze冻结，但因为该方法自身 内部属性，该方法的名称又可以称为&#8220;浅冻结&#8221;，对于第一层数据，如浅拷贝一般，不可被新对象改变，但被freeze方法冻结过的对象，其自身也无法添加、删除或修改其第一层数据，但因为&#8220;浅冻结&#8221;这名称中浅的这一明显属性，freeze方法对于内部如果存在更深层的数据，是可以被自身修改，且也会被&#8220;=&#8221;号所引用给新的变量。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">简单使用如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">var</span> testObj = {   <span style="color: #dd1144;">'name'</span>: <span style="color: #dd1144;">'currName'</span>,   <span style="color: #dd1144;">'nums'</span>: [<span style="color: teal;">1</span>, [<span style="color: teal;">2</span>, <span style="color: teal;">3</span>]],   <span style="color: #dd1144;">'objs'</span>: {     <span style="color: #dd1144;">'innerObj'</span>: <span style="color: #dd1144;">'content'</span>   } } <span style="font-weight: 700;">var</span> secObj = <span style="color: #0086b3;">Object</span>.freeze(testObj) secObj.name = <span style="color: #dd1144;">'changedName'</span> secObj.nums[<span style="color: teal;">0</span>] = <span style="color: #dd1144;">'一'</span> secObj.nums[<span style="color: teal;">1</span>] = [<span style="color: #dd1144;">'二'</span>, <span style="color: #dd1144;">'三'</span>] secObj.objs[<span style="color: #dd1144;">'innerObj'</span>] = <span style="color: #dd1144;">'changedContent'</span> secObj.age = <span style="color: teal;">18</span> <span style="font-weight: 700;">delete</span> secObj.name <span style="color: #0086b3;">console</span>.log(testObj) <span style="color: #999988;">// { name: 'currName',</span>                      <span style="color: #999988;">//   nums: [ '一', [ '二', '三' ] ],</span>                      <span style="color: #999988;">//   objs: { innerObj: 'changedContent' } }</span> <span style="color: #0086b3;">console</span>.log(secObj) <span style="color: #999988;">// { name: 'currName',</span>                     <span style="color: #999988;">//   nums: [ '一', [ '二', '三' ] ],</span>                     <span style="color: #999988;">//   objs: { innerObj: 'changedContent' } }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li></ul></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>深拷贝</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">接上面对浅拷贝的介绍，很容易就可以想到深拷贝便是在浅拷贝的基础上，让内部存在更深层数据的对象，不止第一层不能改变原有数据，内部更深层次数据修改时也不能使原有数据改变，即消除了数据中所有存在引用的情况。通过对浅拷贝的实现，我们很容易就想到通过递归的方法对深拷贝进行实现。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">以下就是通过递归实现深拷贝的过程：</p><ul style="padding: 0px 0px 0px 28px; margin: 0.27rem 0px 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h4>Version 1： 对于深拷贝，因为存在数组与对象互相嵌套的问题，第一个版本先简单统一处理对象的深拷贝，不深究数组对象的存在。</h4><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">function <span style="color: #990000;">deepCopy</span>(content) </span>{   <span style="font-weight: 700;">var</span> retObj = {}   <span style="font-weight: 700;">for</span> (<span style="font-weight: 700;">const</span> key <span style="font-weight: 700;">in</span> content) {     <span style="font-weight: 700;">if</span> (content.hasOwnProperty(key)) {       retObj[key] = <span style="font-weight: 700;">typeof</span> content[key] === <span style="color: #dd1144;">'object'</span>        ? deepCopy(content[key])       : content[key];     }   }   <span style="font-weight: 700;">return</span> retObj }  <span style="font-weight: 700;">var</span> testObj = {   <span style="color: #dd1144;">'name'</span>: <span style="color: #dd1144;">'currName'</span>,   <span style="color: #dd1144;">'nums'</span>: [<span style="color: teal;">1</span>, [<span style="color: teal;">2</span>, <span style="color: teal;">3</span>]],   <span style="color: #dd1144;">'objs'</span>: {     <span style="color: #dd1144;">'innerObj'</span>: <span style="color: #dd1144;">'content'</span>   } } <span style="font-weight: 700;">var</span> secObj = deepCopy(testObj) secObj.name = <span style="color: #dd1144;">'changedName'</span> secObj.nums[<span style="color: teal;">0</span>] = <span style="color: #dd1144;">'一'</span> secObj.nums[<span style="color: teal;">1</span>] = [<span style="color: #dd1144;">'二'</span>, <span style="color: #dd1144;">'三'</span>] secObj.objs[<span style="color: #dd1144;">'innerObj'</span>] = <span style="color: #dd1144;">'changedContent'</span> secObj.age = <span style="color: teal;">18</span> <span style="color: #0086b3;">console</span>.log(testObj) <span style="color: #999988;">// { name: 'currName',</span>                      <span style="color: #999988;">//   nums: [ 1, [ 2, 3 ] ],</span>                      <span style="color: #999988;">//   objs: { innerObj: 'content' } }</span> <span style="color: #0086b3;">console</span>.log(secObj) <span style="color: #999988;">// { name: 'changedName',</span>                     <span style="color: #999988;">//   nums: { '0': '一', '1': [ '二', '三' ] },</span>                     <span style="color: #999988;">//   objs: { innerObj: 'changedContent' },</span>                     <span style="color: #999988;">//   age: 18 }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>Version 2: 完善数组与对象组合嵌套的情况</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">此时对于内部存在的数组来说，会被转化为对象，键为数组的下标，值为数组的值，被存储在新的对象中，因此有了我们完善的第二版。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">function <span style="color: #990000;">deepCopy</span> (obj) </span>{   <span style="font-weight: 700;">var</span> tempTool = <span style="color: #0086b3;">Array</span>.isArray(obj) ? [] : {}    <span style="font-weight: 700;">for</span> (<span style="font-weight: 700;">const</span> key <span style="font-weight: 700;">in</span> obj) {     <span style="font-weight: 700;">if</span> (obj.hasOwnProperty(key)) {       tempTool[key] = <span style="font-weight: 700;">typeof</span> obj[key] === <span style="color: #dd1144;">'object'</span>        ? deepCopy(obj[key])       : <span style="color: #0086b3;">Array</span>.isArray(obj) ? <span style="color: #0086b3;">Array</span>.prototype.concat(obj[key]) : obj[key];     }   }   <span style="font-weight: 700;">return</span> tempTool }  <span style="font-weight: 700;">var</span> testObj = {   <span style="color: #dd1144;">'name'</span>: <span style="color: #dd1144;">'currName'</span>,   <span style="color: #dd1144;">'nums'</span>: [<span style="color: teal;">1</span>, [<span style="color: teal;">2</span>, <span style="color: teal;">3</span>]],   <span style="color: #dd1144;">'objs'</span>: {     <span style="color: #dd1144;">'innerObj'</span>: <span style="color: #dd1144;">'content'</span>   } } <span style="font-weight: 700;">var</span> secObj = deepCopy(testObj) secObj.name = <span style="color: #dd1144;">'changedName'</span> secObj.nums[<span style="color: teal;">0</span>] = <span style="color: #dd1144;">'一'</span> secObj.nums[<span style="color: teal;">1</span>] = [<span style="color: #dd1144;">'二'</span>, <span style="color: #dd1144;">'三'</span>] secObj.objs[<span style="color: #dd1144;">'innerObj'</span>] = <span style="color: #dd1144;">'changedContent'</span> secObj.age = <span style="color: teal;">18</span> <span style="color: #0086b3;">console</span>.log(testObj) <span style="color: #999988;">// { name: 'currName',</span>                      <span style="color: #999988;">//   nums: [ 1, [ 2, 3 ] ],</span>                      <span style="color: #999988;">//   objs: { innerObj: 'content' } }</span> <span style="color: #0086b3;">console</span>.log(secObj) <span style="color: #999988;">// { name: 'changedName',</span>                     <span style="color: #999988;">//   nums: [ '一', [ '二', '三' ] ],</span>                     <span style="color: #999988;">//   objs: { innerObj: 'changedContent' },</span>                     <span style="color: #999988;">//   age: 18 }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li></ul></li></ul><h2>ES6中 Map、Set</h2><ul style="padding: 0px 0px 0px 28px; margin: 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h3>Map</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">对于Hash结构 即 键值对的集合，Object对象只能用字符串作为key值，在使用上有很大的限制，ES6提供的新的数据结构Map相对于Object对象，其&#8220;键&#8221;的范围不限于字符串类型，实现了&#8220;值-值&#8221;的对应，使用上可以有更广泛的运用。但Map在赋值时，只能接受如数组一般有lterator接口且每个成员都是双元素的数组的数据结构作为参数，该数组成员是一个个表示键值对的数组，之外就只能通过Map自身set方法添加成员。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">所以以下我们先介绍将对象转为Map的方法，再对Map自身方法做一个简单介绍，本节最后介绍一个Map的运用场景</p><ul style="padding: 0px 0px 0px 28px; margin: 0.27rem 0px 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h4>Object转为Map方法：</h4><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">function <span style="color: #990000;">objToMap</span> (object) </span>{   <span style="font-weight: 700;">let</span> map = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Map</span>()   <span style="font-weight: 700;">for</span> (<span style="font-weight: 700;">const</span> key <span style="font-weight: 700;">in</span> object) {     <span style="font-weight: 700;">if</span> (object.hasOwnProperty(key)) {       map.set(key, object[key])     }   }   <span style="font-weight: 700;">return</span> map } <span style="font-weight: 700;">var</span> testObj = {   <span style="color: #dd1144;">'name'</span>: <span style="color: #dd1144;">'currName'</span>,   <span style="color: #dd1144;">'nums'</span>: [<span style="color: teal;">1</span>, [<span style="color: teal;">2</span>, <span style="color: teal;">3</span>]],   <span style="color: #dd1144;">'objs'</span>: {     <span style="color: #dd1144;">'innerObj'</span>: <span style="color: #dd1144;">'content'</span>   } } <span style="font-weight: 700;">let</span> map = objToMap(testObj) map.set(<span style="color: #dd1144;">'name'</span>, <span style="color: #dd1144;">'changedName'</span>) <span style="color: #0086b3;">console</span>.log(testObj) <span style="color: #999988;">// { name: 'currName',</span>                      <span style="color: #999988;">//   nums: [ 1, [ 2, 3 ] ],</span>                      <span style="color: #999988;">//   objs: { innerObj: 'content' } }</span> <span style="color: #0086b3;">console</span>.log(map) <span style="color: #999988;">// Map {</span>                  <span style="color: #999988;">// 'name' =&gt; 'changedName',</span>                  <span style="color: #999988;">// 'nums' =&gt; [ 1, [ 2, 3 ] ],</span>                  <span style="color: #999988;">// 'objs' =&gt; { innerObj: 'content' } }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>Map自身方法介绍</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">含增删改查方法：set、get、has、delete；</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">遍历方法：keys、values、entries、forEach；</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">其他方法：size、clear。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">需要注意的是forEach方法还可以接受第二个参数，改变第一个参数即回调函数的内部this指向。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">let</span> map = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Map</span>([  [<span style="color: #dd1144;">'name'</span>, <span style="color: #dd1144;">'currName'</span>],  [<span style="color: #dd1144;">'nums'</span>, [<span style="color: teal;">1</span>, [<span style="color: teal;">2</span>, <span style="color: teal;">3</span>]]],  [<span style="color: #dd1144;">'objs'</span>, {<span style="color: #dd1144;">'innerObj'</span>: <span style="color: #dd1144;">'content'</span>}] ]) <span style="color: #999988;">// 增 删 改 查</span> map.set(<span style="color: #dd1144;">'test'</span>, <span style="color: #dd1144;">'testContent'</span>) map.delete(<span style="color: #dd1144;">'objs'</span>) map.set(<span style="color: #dd1144;">'name'</span>, <span style="color: #dd1144;">'changedName'</span>) <span style="color: #0086b3;">console</span>.log(map.get(<span style="color: #dd1144;">'nums'</span>)) <span style="color: #999988;">// [ 1, [ 2, 3 ] ]</span> <span style="color: #0086b3;">console</span>.log(map.has(<span style="color: #dd1144;">'nums'</span>)) <span style="color: #999988;">// true</span> <span style="color: #0086b3;">console</span>.log(map) <span style="color: #999988;">// Map {</span>                 <span style="color: #999988;">// 'name' =&gt; 'changedName',</span>                 <span style="color: #999988;">// 'nums' =&gt; [ 1, [ 2, 3 ] ],</span>                 <span style="color: #999988;">// 'test' =&gt; 'testContent' }</span>  <span style="color: #999988;">// 遍历方法</span> <span style="color: #0086b3;">console</span>.log(map.keys()) <span style="color: #999988;">// [Map Iterator] { 'name', 'nums', 'test' }</span> <span style="color: #0086b3;">console</span>.log(map.values()) <span style="color: #999988;">// [Map Iterator] { 'changedName', [ 1, [ 2, 3 ] ], 'testContent' }</span> <span style="color: #0086b3;">console</span>.log(map.entries()) <span style="color: #999988;">// [Map Iterator] {</span>                           <span style="color: #999988;">// [ 'name', 'changedName' ],</span>                           <span style="color: #999988;">// [ 'nums', [ 1, [ 2, 3 ] ] ],</span>                           <span style="color: #999988;">// [ 'test', 'testContent' ] }</span>  <span style="font-weight: 700;">const</span> testObj = {  objName: <span style="color: #dd1144;">'objName'</span> } map.forEach(<span style="font-weight: 700;">function (value, key) </span>{  <span style="color: #0086b3;">console</span>.log(key, value, <span style="font-weight: 700;">this</span>.objName) <span style="color: #999988;">// name changedName objName</span>                                        <span style="color: #999988;">// nums [ 1, [ 2, 3 ] ] objName</span>                                        <span style="color: #999988;">// test testContent objName</span> }, testObj)  <span style="color: #999988;">// 其他方法</span> <span style="color: #0086b3;">console</span>.log(map.size) <span style="color: #999988;">// 3</span>  <span style="color: #0086b3;">console</span>.log(map) <span style="color: #999988;">// Map {</span>                 <span style="color: #999988;">// 'name' =&gt; 'changedName',</span>                 <span style="color: #999988;">// 'nums' =&gt; [ 1, [ 2, 3 ] ],</span>                 <span style="color: #999988;">// 'test' =&gt; 'testContent' }</span> map.clear() <span style="color: #0086b3;">console</span>.log(map) <span style="color: #999988;">// Map {}</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>Map应用场景</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">对于经典算法问题中 上楼梯问题：共n层楼梯，一次仅能跨1或2步，总共有多少种走法？</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">这一类问题都有一个递归过程中内存溢出的bug存在，此时就可以运用Map减少递归过程中重复运算的部分，解决内存溢出的问题。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">let</span> n = <span style="color: teal;">100</span> <span style="font-weight: 700;">let</span> map = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Map</span>() <span style="font-weight: 700;">function <span style="color: #990000;">upStairs</span> (n) </span>{   <span style="font-weight: 700;">if</span> (n === <span style="color: teal;">1</span>) <span style="font-weight: 700;">return</span> <span style="color: teal;">1</span>   <span style="font-weight: 700;">if</span> (n === <span style="color: teal;">2</span>) <span style="font-weight: 700;">return</span> <span style="color: teal;">2</span>   <span style="font-weight: 700;">if</span> (map.has(n)) <span style="font-weight: 700;">return</span> map.get(n)   <span style="font-weight: 700;">let</span> ret = upStairs(n - <span style="color: teal;">1</span>) + upStairs(n - <span style="color: teal;">2</span>)   map.set(n, ret)   <span style="font-weight: 700;">return</span> ret } <span style="color: #0086b3;">console</span>.log(upStairs(n)) <span style="color: #999988;">// 573147844013817200000</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li></ul></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>WeakMap</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">本节介绍在ES6中，与Map相关且一同发布的WeakMap数据结构。</p><ul style="padding: 0px 0px 0px 28px; margin: 0.27rem 0px 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h4>WeakMap与Map区别</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">WeakMap与Map主要有下图三个区别：</p><table style="font-size: 1rem; width: auto; max-width: 100%; overflow: auto; border-style: solid; border-color: #f6f6f6; display: inline-block !important;"><thead style="background: #f6f6f6;"><tr><th style="padding: 1rem 0.6rem; line-height: 2rem;">区别</th><th style="padding: 1rem 0.6rem; line-height: 2rem;">Map</th><th style="padding: 1rem 0.6rem; line-height: 2rem;">WeakMap</th></tr></thead><tbody><tr><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">&#8220;键&#8221;类型：</td><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">任何类型</td><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">Object对象</td></tr><tr style="background-color: #fcfcfc;"><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">自身方法：</td><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">基本方法：set、get、has、delete；<br />遍历方法：keys、values、entries、forEach；<br />其他方法：size、clear。</td><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">基本方法：set、get、has、delete。</td></tr><tr><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">键引用类型：</td><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">强引用</td><td style="padding: 1rem 0.6rem; line-height: 2rem; min-width: 10rem;">弱引用</td></tr></tbody></table><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">此处我们对强弱引用进行简单介绍：弱引用在回收机制上比强引用好，在&#8220;适当&#8221;的情况将会被回收，减少内存资源浪费，但由于不是强引用，WeakMap不能进行遍历与size方法取得内部值数量。</p></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>WeakMap自身方法</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">含增删改查方法：set、get、has、delete。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">let</span> wMap = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">WeakMap</span>() <span style="font-weight: 700;">let</span> key = {} <span style="font-weight: 700;">let</span> obj = {name: <span style="color: #dd1144;">'objName'</span>}  wMap.set(key, obj) <span style="color: #0086b3;">console</span>.log(wMap.get(key)) <span style="color: #999988;">// { name: 'objName' }</span> <span style="color: #0086b3;">console</span>.log(wMap.has(key)) <span style="color: #999988;">// true</span>  wMap.delete(key) <span style="color: #0086b3;">console</span>.log(wMap.has(key)) <span style="color: #999988;">// false</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>WeakMap应用场景</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">WeakMap因为键必须为对象，且在回收机制上的优越性，其可以用在以下两个场景：</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">1. 对特定DOM节点添加状态时。当DOM节点被删除，将DOM节点作为&#8220;键&#8221;的WeakMap也会自动被回收。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">2. 对类或构造函数中私有属性绑定定义。当实例被删除，被作为&#8220;键&#8221;的this消失，WeakMap自动回收。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">示例代码如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;">&lt;!--示例一--&gt; <span style="font-weight: 700;">let</span> element = <span style="color: #0086b3;">document</span>.getElementById(<span style="color: #dd1144;">'box'</span>) <span style="font-weight: 700;">let</span> wMap = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">WeakMap</span>() wMap.set(element, {clickCount: <span style="color: teal;">0</span>}) element.addEventListener(<span style="color: #dd1144;">'click'</span>, () =&gt; {   <span style="font-weight: 700;">let</span> countObj = wMap.get(element)   countObj.clickCount++    <span style="color: #0086b3;">console</span>.log(wMap.get(element).clickCount) <span style="color: #999988;">// click -&gt; n+=1</span> })  &lt;!--示例二--&gt; <span style="font-weight: 700;">const</span> _age = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">WeakMap</span>() <span style="font-weight: 700;">const</span> _fn = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">WeakMap</span>() <span style="font-weight: 700;">class <span style="color: #445588;">Girl</span> </span>{   <span style="font-weight: 700;">constructor</span> (age, fn) {     _age.set(<span style="font-weight: 700;">this</span>, age)     _fn.set(<span style="font-weight: 700;">this</span>, fn)   }   changeAge () {     <span style="font-weight: 700;">let</span> age = _age.get(<span style="font-weight: 700;">this</span>)     age = age &gt;= <span style="color: teal;">18</span> ? <span style="color: teal;">18</span> : <span style="color: teal;">null</span>     _age.set(<span style="font-weight: 700;">this</span>, age)      _age.get(<span style="font-weight: 700;">this</span>) === <span style="color: teal;">18</span>     ? _fn.get(<span style="font-weight: 700;">this</span>)()     : <span style="color: #0086b3;">console</span>.log(<span style="color: #dd1144;">'error'</span>)   } }  <span style="font-weight: 700;">const</span> girl = <span style="font-weight: 700;">new</span> Girl(<span style="color: teal;">25</span>, () =&gt; <span style="color: #0086b3;">console</span>.log(<span style="color: #dd1144;">'forever 18 !'</span>)) girl.changeAge() <span style="color: #999988;">// forever 18 !</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li></ul></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>Set</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">介绍完ES6新增的Map与WeakMap数据结构，我们继续介绍一同新增的Set数据结构。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Set之于Array，其实有点像Map之于Object，Set是在数组的数据结构基础上做了一些改变，新出的一种类似于数组的数据结构，Set的成员的值唯一，不存在重复的值。以下将对Set数据结构作一些简单的介绍。</p><ul style="padding: 0px 0px 0px 28px; margin: 0.27rem 0px 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h4>Set与Array之间的相互转换</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Set可以将具有Iterable接口的其他数据结构作为参数用于初始化，此处不止有数组，但仅以数组作为例子，单独讲述一下。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="color: #999988;">// Set -&gt; Array</span> <span style="font-weight: 700;">let</span> arr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>, <span style="color: teal;">3</span>] <span style="font-weight: 700;">let</span> set = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>(arr) <span style="color: #0086b3;">console</span>.log(set) <span style="color: #999988;">// Set { 1, 2, 3 }</span>  <span style="color: #999988;">// Array -&gt; Set</span> <span style="font-weight: 700;">const</span> arrFromSet1 = <span style="color: #0086b3;">Array</span>.from(set) <span style="font-weight: 700;">const</span> arrFromSet2 = [...set] <span style="color: #0086b3;">console</span>.log(arrFromSet1) <span style="color: #999988;">// [ 1, 2, 3 ]</span> <span style="color: #0086b3;">console</span>.log(arrFromSet2) <span style="color: #999988;">// [ 1, 2, 3 ]</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>Set自身方法</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Set内置的方法与Map类似</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">含增删查方法：add、has、delete；</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">遍历方法：keys、values、entries、forEach；</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">其他方法：size、clear。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">let</span> arr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>, <span style="color: teal;">3</span>] <span style="font-weight: 700;">let</span> set = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>(arr) <span style="color: #999988;">// 增删改查</span> set.add(<span style="color: teal;">4</span>) <span style="color: #0086b3;">console</span>.log(set) <span style="color: #999988;">// Set { 1, 2, 3, 4 }</span> set.delete(<span style="color: teal;">3</span>) <span style="color: #0086b3;">console</span>.log(set) <span style="color: #999988;">// Set { 1, 2, 4 }</span> <span style="color: #0086b3;">console</span>.log(set.has(<span style="color: teal;">4</span>)) <span style="color: #999988;">// true</span>  <span style="color: #999988;">// 遍历方法 因为在Set结构中没有键名只有健值，所以keys方法和values方法完全一致</span> <span style="color: #0086b3;">console</span>.log(set.keys()) <span style="color: #999988;">// [Set Iterator] { 1, 2, 4 }</span> <span style="color: #0086b3;">console</span>.log(set.values()) <span style="color: #999988;">// [Set Iterator] { 1, 2, 4 }</span>  <span style="font-weight: 700;">for</span> (<span style="font-weight: 700;">const</span> item <span style="font-weight: 700;">of</span> set.entries()) {   <span style="color: #0086b3;">console</span>.log(item) <span style="color: #999988;">//[ 1, 1 ]</span>                     <span style="color: #999988;">// [ 2, 2 ]</span>                     <span style="color: #999988;">// [ 4, 4 ]</span> }  <span style="font-weight: 700;">const</span> obj = {   name: <span style="color: #dd1144;">'objName'</span> } set.forEach(<span style="font-weight: 700;">function (key, value) </span>{   <span style="color: #0086b3;">console</span>.log(key, value, <span style="font-weight: 700;">this</span>.name) <span style="color: #999988;">// 1 1 'objName'</span>                                      <span style="color: #999988;">// 2 2 'objName'</span>                                      <span style="color: #999988;">// 4 4 'objName'</span> }, obj)  <span style="color: #999988;">// 其他方法</span> <span style="color: #0086b3;">console</span>.log(set.size) <span style="color: #999988;">// 3</span> set.clear() <span style="color: #0086b3;">console</span>.log(set) <span style="color: #999988;">// Set {}</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>Set应用场景</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">因为扩展运算符...对Set作用，再通过Array遍历方法，很容易求得并集、交集及差集，也可以通过间接使用Array方法，构造新的数据赋给Set结构变量。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">let</span> a = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>([<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>]) <span style="font-weight: 700;">let</span> b = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>([<span style="color: teal;">2</span>, <span style="color: teal;">3</span>, <span style="color: teal;">4</span>])  <span style="color: #999988;">// 并集</span> <span style="font-weight: 700;">let</span> union = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>([...a, ...b]) <span style="color: #0086b3;">console</span>.log(union) <span style="color: #999988;">// Set { 1, 2, 3, 4 }</span> <span style="color: #999988;">// 交集</span> <span style="font-weight: 700;">let</span> intersect = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>([...a].filter(x =&gt; b.has(x))) <span style="color: #0086b3;">console</span>.log(intersect) <span style="color: #999988;">// Set { 2, 3 }</span> <span style="color: #999988;">// 差集</span> <span style="font-weight: 700;">let</span> difference = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>([...[...a].filter(x =&gt; !b.has(x)), ...[...b].filter(x =&gt; !a.has(x))]) <span style="color: #0086b3;">console</span>.log(difference) <span style="color: #999988;">// Set { 1, 4 }</span>  <span style="color: #999988;">// 赋新值</span> <span style="font-weight: 700;">let</span> aDouble = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>([...a].map(x =&gt; x * <span style="color: teal;">2</span>)) <span style="color: #0086b3;">console</span>.log(aDouble) <span style="color: #999988;">// Set { 2, 4, 6 }</span>  <span style="font-weight: 700;">let</span> bDouble = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">Set</span>(<span style="color: #0086b3;">Array</span>.from(b, x =&gt; x * <span style="color: teal;">2</span>)) <span style="color: #0086b3;">console</span>.log(bDouble) <span style="color: #999988;">// Set { 4, 6, 8 }</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li></ul></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>WeakSet</h3><ul style="padding: 0px 0px 0px 28px; margin: 0.27rem 0px 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h4>WeakSet与Set对比</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">WeakSet之于Set，依旧相当于WeakMap之于Map。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">WeakSet与Set之间不同之处，依然是：</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">1. WeakSet内的值只能为对象；</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">2. WeakSet依旧是弱引用。</p></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>WeakSet自身方法</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">因为弱引用的关系，WeakSet只有简单的增删查方法：add、delete、has</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">let</span> obj1 = {<span style="color: #dd1144;">'name'</span>: <span style="color: teal;">1</span>} <span style="font-weight: 700;">let</span> obj2 = {<span style="color: #dd1144;">'name'</span>: <span style="color: teal;">2</span>} <span style="font-weight: 700;">let</span> wSet = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">WeakSet</span>() wSet.add(obj1).add(obj2) <span style="color: #0086b3;">console</span>.log(wSet.has(obj2)) <span style="color: #999988;">// true</span> wSet.delete(obj2) <span style="color: #0086b3;">console</span>.log(wSet.has(obj2)) <span style="color: #999988;">// false</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h4>WeakSet应用场景</h4><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">对于WeakSet的应用场景，其与WeakMap类似，因为弱引用的优良回收机制，WeakSet依旧可以存放DOM节点，避免删除这些节点后引发的内存泄漏的情况；也可以在构造函数和类中存放实例this，同样避免删除实例的时候产生的内存泄漏的情况。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="color: #999988;">// 1</span> <span style="font-weight: 700;">let</span> wSet = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">WeakSet</span>() wSet.add(<span style="color: #0086b3;">document</span>.getElementById(<span style="color: #dd1144;">'box'</span>))  <span style="font-weight: 700;">const</span> _boy = <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">WeakSet</span>() <span style="color: #999988;">// 2</span> <span style="font-weight: 700;">class <span style="color: #445588;">Boy</span> </span>{   <span style="font-weight: 700;">constructor</span> () {     _boy.add(<span style="font-weight: 700;">this</span>)   }   method () {     <span style="font-weight: 700;">if</span> (!_boy.has(<span style="font-weight: 700;">this</span>)) {       <span style="font-weight: 700;">throw</span> <span style="font-weight: 700;">new</span> <span style="color: #0086b3;">TypeError</span>(<span style="color: #dd1144;">'Boy.prototype.method 只能在Boy的实例上调用！'</span>)     }   } } <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li></ul></li></ul><h2>数组中map方法及遍历相关方法</h2><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">讲完大Map，此时我们继续了解完小map，map即为Array.map()，是数组中一个遍历方法。并将map作为一个引子，我们对比多介绍几个Array中遍历相关的方法。</p><ul style="padding: 0px 0px 0px 28px; margin: 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h3>Array.map()、Array.flatMap()</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.map() &#8212;&#8212; 可以有三个参数，item、index、arr，此时当做forEach使用；常用方法是通过第一个参数遍历修改后返回一个新数组。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.flatMap() &#8212;&#8212; 前置知识：Array方法中有一个ES6中新加入的数组展开嵌套的方法Array.flat()，其中可以有一个参数表示展开层数，默认只展开一层。而Array.flatMap() 为 Array.map()与Array.flat()方法的叠加。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">例子如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="color: #999988;">// flat</span> <span style="font-weight: 700;">const</span> testArr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, [<span style="color: teal;">3</span>, [<span style="color: teal;">4</span>]]] <span style="font-weight: 700;">const</span> flatArr = testArr.flat() <span style="color: #0086b3;">console</span>.log(flatArr) <span style="color: #999988;">// [1, 2, 3, Array(1)] -&gt; 0: 1</span>                      <span style="color: #999988;">//                        1: 2</span>                      <span style="color: #999988;">//                        2: 3</span>                      <span style="color: #999988;">//                        3: [4]</span>  <span style="font-weight: 700;">const</span> arr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>] <span style="color: #999988;">// map</span> <span style="font-weight: 700;">const</span> mapArr = arr.map(x =&gt; x * <span style="color: teal;">2</span>) <span style="color: #0086b3;">console</span>.log(mapArr) <span style="color: #999988;">// [2, 4, 6]</span>  arr.map((item, index, arr) =&gt; {   <span style="color: #0086b3;">console</span>.log(item, index, arr) <span style="color: #999988;">// 1 0 [1, 2, 3]</span>                                 <span style="color: #999988;">// 2 1 [1, 2, 3]</span>                                 <span style="color: #999988;">// 3 2 [1, 2, 3]</span> })  <span style="color: #999988;">// flatMap</span> <span style="color: #999988;">// arr.flatMap(x =&gt; [x * 2]) === arr.map(x =&gt; x * 2)</span> <span style="font-weight: 700;">const</span> flatMapArr = arr.flatMap(x =&gt; [x * <span style="color: teal;">2</span>]) <span style="color: #0086b3;">console</span>.log(flatMapArr) <span style="color: #999988;">// [2, 4, 6]</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>Array.reduce()</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.reduce() &#8212;&#8212; reduce方法与map最大的不同是不返回新的数组，其返回的是一个计算值，参数为回调函数与回调函数参数pre初始值，回调函数中参数为pre与next，当在默认情况时，pre为数组中第一个值，next为数组中第二个值，回调函数返回值可以滚雪球般更改pre值；而当index设置数值后，pre初始值为参数值，next从数组中第一个值一直取到数组最后一位。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">例子如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">const</span> arr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>, <span style="color: teal;">4</span>, <span style="color: teal;">5</span>]  <span style="font-weight: 700;">const</span> result = arr.reduce((pre, next) =&gt; {   <span style="color: #0086b3;">console</span>.log(pre, next) <span style="color: #999988;">// 1 2</span>                          <span style="color: #999988;">// 3 3</span>                          <span style="color: #999988;">// 6 4</span>                          <span style="color: #999988;">// 10 5</span>   <span style="font-weight: 700;">return</span> pre + next }) <span style="color: #0086b3;">console</span>.log(result) <span style="color: #999988;">// 15</span>  arr.reduce((pre, next) =&gt; {   <span style="color: #0086b3;">console</span>.log(pre, next) <span style="color: #999988;">// 9 1</span>                          <span style="color: #999988;">// 9bala 2</span>                          <span style="color: #999988;">// 9balabala 3</span>                          <span style="color: #999988;">// 9balabalabala 4</span>                          <span style="color: #999988;">// 9balabalabalabala 5</span>   <span style="font-weight: 700;">return</span> pre += <span style="color: #dd1144;">'bala'</span> }, <span style="color: teal;">9</span>) <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>Array.filter()、Array.find()、Array.findIndex()</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.filter() &#8212;&#8212; 返回值是一个数组，第一个参数为回调函数，第二个参数为回调函数中this指向。回调函数的参数有value，index及arr。满足回调函数的中过滤条件的，会被push到返回值中新的数组中。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.find() &#8212;&#8212; 返回值是数组内的一个值，该方法返回数组内满足条件的第一个值，第一个参数为回调函数，第二个参数为回调函数中this指向。回调函数的参数有查找到的符合条件前的value，index及arr。当查找的是数组中不可重复的值时，建议使用find方法，会比filter更优越。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.findIndex() &#8212;&#8212; 返回值为Number，该方法返回数组内满足条件的第一个值在数组中的index，第一个参数为回调函数，第二个参数为回调函数中this指向。回调函数中的参数与find方法类似。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">例子如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">const</span> arr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>, <span style="color: teal;">4</span>, <span style="color: teal;">5</span>] <span style="font-weight: 700;">const</span> obj = {num: <span style="color: teal;">3</span>}  <span style="color: #999988;">// filter</span> <span style="font-weight: 700;">const</span> filterArr = arr.filter(<span style="font-weight: 700;">function (value, index, arr) </span>{   <span style="color: #0086b3;">console</span>.log(index, arr) <span style="color: #999988;">// 0 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 1 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 2 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 3 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 4 [1, 2, 3, 4, 5]</span>   <span style="font-weight: 700;">return</span> value &gt; <span style="font-weight: 700;">this</span>.num }, obj) <span style="color: #0086b3;">console</span>.log(filterArr) <span style="color: #999988;">// [4, 5]</span>  <span style="color: #999988;">// find</span> <span style="font-weight: 700;">const</span> findResult = arr.find(<span style="font-weight: 700;">function (value, index, arr) </span>{   <span style="color: #0086b3;">console</span>.log(index, arr) <span style="color: #999988;">// 0 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 1 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 2 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 3 [1, 2, 3, 4, 5]</span>   <span style="font-weight: 700;">return</span> value &gt; <span style="font-weight: 700;">this</span>.num }, obj) <span style="color: #0086b3;">console</span>.log(findResult) <span style="color: #999988;">// 4</span>  <span style="color: #999988;">// findIndex</span> <span style="font-weight: 700;">const</span> findIndexResult = arr.findIndex(<span style="font-weight: 700;">function (value) </span>{ <span style="font-weight: 700;">return</span> value &gt; <span style="font-weight: 700;">this</span>.num }, obj) <span style="color: #0086b3;">console</span>.log(findIndexResult) <span style="color: #999988;">// 3</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>Array.includes()</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.includes() &#8212;&#8212; 返回值为Boolean值，其可以简单快捷的判断数组中是否含有某个值。其第一个参数为需要查找的值，第二个参数为开始遍历的位置，遍历位置起始点默认为0。相比于indexOf、filter、find及findIndex方法，includes方法更简单快捷返回Boolean值进行判断，其二对于数组中NaN值，includes可以识别到NaN。</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="font-weight: 700;">const</span> arr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>, <span style="color: teal;">NaN</span>] <span style="color: #0086b3;">console</span>.log(arr.includes(<span style="color: teal;">NaN</span>)) <span style="color: #999988;">// true</span> <span style="color: #0086b3;">console</span>.log(arr.includes(<span style="color: teal;">2</span>, <span style="color: teal;">2</span>)) <span style="color: #999988;">// false</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li><li style="list-style: inherit; margin-bottom: 0px;"><h3>Array.every()、Array.some()</h3><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.every() &#8212;&#8212; 返回值为Boolean类型，类似于if判断中的 &amp;&amp; 条件符，当数组中每个值都满足条件时返回true。其第一个参数为回调函数，第二个参数为回调函数的this指向。回调函数的参数为对比结果为true的value，index及arr，到碰到false停止。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">Array.some() &#8212;&#8212; 返回值为Boolean类型，类似于if判断中的 || 条件符，当数组中存在任意一个值满足条件时返回true。其参数与every方法相同，但回调函数的参数，some方法为对比结果为false的value，index及arr，到碰到true停止。</p><p style="line-height: inherit; margin-top: 22px; margin-bottom: 22px;">例子如下：</p><pre><code><code js=""  copyable"="" style="font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 1rem; padding: 18px 15px 12px; word-break: normal; background: #f8f8f8; border-radius: 2px; overflow-x: auto; margin: 0px; display: block;"><span style="color: #999988;">// every</span> <span style="font-weight: 700;">const</span> arr = [<span style="color: teal;">1</span>, <span style="color: teal;">2</span>, <span style="color: teal;">3</span>, <span style="color: teal;">4</span>, <span style="color: teal;">5</span>] <span style="font-weight: 700;">const</span> obj = { num: <span style="color: teal;">3</span> } <span style="font-weight: 700;">const</span> everyResult = arr.every(<span style="font-weight: 700;">function(value, index, arr) </span>{   <span style="color: #0086b3;">console</span>.log(index, arr) <span style="color: #999988;">// 0 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 1 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 2 [1, 2, 3, 4, 5]</span>   <span style="font-weight: 700;">return</span> value &lt; <span style="font-weight: 700;">this</span>.num }, obj) <span style="color: #0086b3;">console</span>.log(everyResult) <span style="color: #999988;">// false</span>  <span style="color: #999988;">// some</span> <span style="font-weight: 700;">const</span> someResult = arr.some(<span style="font-weight: 700;">function(value, index, arr) </span>{   <span style="color: #0086b3;">console</span>.log(index, arr) <span style="color: #999988;">// 0 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 1 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 2 [1, 2, 3, 4, 5]</span>                           <span style="color: #999988;">// 3 [1, 2, 3, 4, 5]</span>   <span style="font-weight: 700;">return</span> value &gt; <span style="font-weight: 700;">this</span>.num }, obj) <span style="color: #0086b3;">console</span>.log(someResult) <span style="color: #999988;">// true</span> <span style="position: absolute; top: 6px; right: 15px; font-size: 12px; line-height: 1; cursor: pointer; color: rgba(140, 140, 140, 0.8); transition: color 0.1s ease 0s;">复制代码</span></code></pre></li></ul><h2>相关文章</h2><ul style="padding: 0px 0px 0px 28px; margin: 0px;"><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://juejin.im/post/59ac1c4ef265da248e75892b" target="_blank" rel="" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">js 深拷贝 vs 浅拷贝</a></h3></li><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://juejin.im/post/5b5dcf8351882519790c9a2e" target="_blank" rel="" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">浅拷贝与深拷贝</a></h3></li><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://juejin.im/post/59658504f265da6c415f3324" target="_blank" rel="" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">JavaScript专题之深浅拷贝</a></h3></li><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://juejin.im/post/5d5e89aee51d453bdb1d9b61" target="_blank" rel="" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">Vue性能提升之Object.freeze()</a></h3></li><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://juejin.im/post/5835808067f3560065ed4ab2" target="_blank" rel="" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">一张图看懂JavaScript中数组的迭代方法：forEach、map、filter、reduce、every、some</a></h3></li><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://juejin.im/post/5bb9e3085188255c352d7326" target="_blank" rel="" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">[译] 五个小技巧让你写出更好的 JavaScript 条件语句</a></h3></li><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://juejin.im/post/5b8d0a74f265da431d0e7ec0" target="_blank" rel="" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">[译文] 如何在 JavaScript 中更好地使用数组</a></h3></li><li style="list-style: inherit; margin-bottom: 0px;"><h3><a href="https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com" target="_blank" rel="nofollow noopener noreferrer" style="margin: initial; text-decoration-line: none; cursor: pointer; color: #0269c8; border-bottom: 1px solid #d1e9ff;">ES6 - 阮一峰大大</a></h3></li></ul></div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>