<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修彻底弄懂ES6中的Map和Set' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>彻底弄懂ES6中的Map和Set</center></div><div class='banquan'>原文出处:本文由博客园博主pubdreamcc提供。<br/>
原文连接:https://www.cnblogs.com/dreamcc/p/10892918.html</div><br>
    <h2 id="map">Map</h2>
<p><code>Map</code>对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数<code>Map</code>可以接受一个数组作为参数。</p>
<h2 id="map和object的区别">Map和Object的区别</h2>
<ul>
<li><p>一个<code>Object</code> 的键只能是字符串或者 <code>Symbols</code>，但一个<code>Map</code> 的键可以是任意值。</p></li>
<li><p><code>Map</code>中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</p></li>
<li><p><code>Map</code>的键值对个数可以从 size 属性获取，而 <code>Object</code> 的键值对个数只能手动计算。</p></li>
<li><p><code>Object</code> 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</p></li>
</ul>
<ol>
<li>Map对象的属性</li>
</ol>
<ul>
<li>size：返回Map对象中所包含的键值对个数</li>
</ul>
<ol>
<li>Map对象的方法</li>
</ol>
<ul>
<li><p>set(key, val): 向Map中添加新元素</p></li>
<li><p>get(key): 通过键值查找特定的数值并返回</p></li>
<li><p>has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false</p></li>
<li><p>delete(key): 通过键值从Map中移除对应的数据</p></li>
<li><p>clear(): 将这个Map中的所有元素删除</p></li>
</ul>
<pre><code><code>const m1 = new Map([[&#39;a&#39;, 111], [&#39;b&#39;, 222]])
console.log(m1) // {&quot;a&quot; =&gt; 111, &quot;b&quot; =&gt; 222}
m1.get(&#39;a&#39;)  // 111

const m2 = new Map([[&#39;c&#39;, 3]])
const m3 = new Map(m2)
m3.get(&#39;c&#39;) // 3
m3.has(&#39;c&#39;) // true
m3.set(&#39;d&#39;, 555)
m3.get(&#39;d&#39;) // 555</code></pre>
<ol>
<li>遍历方法</li>
</ol>
<ul>
<li><p><code>keys()</code>：返回键名的遍历器</p></li>
<li><p><code>values()</code>：返回键值的遍历器</p></li>
<li><p><code>entries()</code>：返回键值对的遍历器</p></li>
<li><p><code>forEach()</code>：使用回调函数遍历每个成员</p></li>
</ul>
<pre><code><code>const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;,  2]])

for (let key of map.keys()) {
  console.log(key)
}
// &quot;a&quot;
// &quot;b&quot;

for (let value of map.values()) {
  console.log(value)
}
// 1
// 2

for (let item of map.entries()) {
  console.log(item)
}
// [&quot;a&quot;, 1]
// [&quot;b&quot;, 2]

// 或者
for (let [key, value] of map.entries()) {
  console.log(key, value)
}
// &quot;a&quot; 1
// &quot;b&quot; 2

// for...of...遍历map等同于使用map.entries()

for (let [key, value] of map) {
  console.log(key, value)
}
// &quot;a&quot; 1
// &quot;b&quot; 2</code></pre>
<ol>
<li>map与其他数据结构的互相转换</li>
</ol>
<ul>
<li>map转换为数组（使用扩展运算符）</li>
</ul>
<pre><code><code>
const arr = [[{&#39;a&#39;: 1}, 111], [&#39;b&#39;: 222]]

const myMap = new Map(arr)

[...myMap] // map转数组。 [[{&#39;a&#39;: 1}, 111], [&#39;b&#39;: 222]]</code></pre>
<ul>
<li><code>Map</code>与对象的互换</li>
</ul>
<pre><code><code>const obj = {}
const map = new Map([&#39;a&#39;, 111], [&#39;b&#39;, 222])
for(let [key,value] of map) {
  obj[key] = value
}
console.log(obj) // {a:111, b: 222}</code></pre>
<ul>
<li><code>JSON</code>字符串要转换成<code>Map</code>可以先利用JSON.parse()转换成数组或者对象，然后再转换即可。</li>
</ul>
<h2 id="set">Set</h2>
<p><code>Set</code>对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br />
<code>Set</code> 本身是一个构造函数，用来生成<code>Set</code> 数据结构。<code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<h2 id="set中的特殊值">Set中的特殊值</h2>
<p><code>Set</code> 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<ul>
<li><p>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复</p></li>
<li><p>undefined 与 undefined 是恒等的，所以不重复</p></li>
<li><p>NaN 与 NaN 是不恒等的，但是在 Set 中认为NaN与NaN相等，所有只能存在一个，不重复。</p></li>
</ul>
<ol>
<li>Set实例对象的属性</li>
</ol>
<ul>
<li>size：返回Set实例的成员总数。</li>
</ul>
<ol>
<li>Set实例对象的方法</li>
</ol>
<ul>
<li><p><code>add(value)</code>：添加某个值，返回 Set 结构本身(可以链式调用)。</p></li>
<li><p><code>delete(value)</code>：删除某个值，删除成功返回<code>true</code>，否则返回<code>false</code>。</p></li>
<li><p><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</p></li>
<li><p><code>clear()</code>：清除所有成员，没有返回值。</p></li>
</ul>
<pre><code><code>const mySet = new Set([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, 1, 2, 1])
console.log(mySet)  // {&#39;a&#39;, &#39;b&#39;, 1, 2}
myset.add(&#39;c&#39;).add({&#39;a&#39;: 1})
console.log(mySet) // {&#39;a&#39;, &#39;b&#39;, 1, 2, &#39;c&#39;, {a: 1}}
console.log(mySet.size) // 6

mySet.has(2) // true</code></pre>
<ol>
<li>遍历方法</li>
</ol>
<ul>
<li><p><code>keys()</code>：返回键名的遍历器。</p></li>
<li><code>values()</code>：返回键值的遍历器。</li>
<li><code>entries()</code>：返回键值对的遍历器。</li>
<li><p><code>forEach()</code>：使用回调函数遍历每个成员。</p></li>
</ul>
<p>由于<code>Set</code>结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p>
<pre><code><code>const set = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])

for (let item of set.keys()) {
  console.log(item)
}
// a
// b
// c

for (let item of set.values()) {
  console.log(item)
}
// a
// b
// c

for (let item of set.entries()) {
  console.log(item)
}
// [&quot;a&quot;, &quot;a&quot;]
// [&quot;b&quot;, &quot;b&quot;]
// [&quot;c&quot;, &quot;c&quot;]

// 直接遍历set实例，等同于遍历set实例的values方法
for (let i of set) {
  console.log(i)
}
// a
// b
// c

set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))

// a: a
// b: b
// c: c</code></pre>
<ol>
<li>Set 对象作用</li>
</ol>
<ul>
<li>数组去重(利用扩展运算符)</li>
</ul>
<pre><code><code>const mySet = new Set([1, 2, 3, 4, 4])
[...mySet] // [1, 2, 3, 4]</code></pre>
<ul>
<li>合并两个set对象</li>
</ul>
<pre><code><code>let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])
let union = new Set([...a, ...b]) // {1, 2, 3, 4}</code></pre>
<ul>
<li>交集</li>
</ul>
<pre><code><code>let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])
let intersect = new Set([...a].filter(x =&gt; b.has(x)))  // {2, 3} 利用数组的filter方法</code></pre>
<ul>
<li>差集</li>
</ul>
<pre><code><code>let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])
let difference = new Set([...a].filter(x =&gt; !b.has(x))) //  {1} </code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>