<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修我的react学习' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>我的react学习</center></div><div class='banquan'>原文出处:本文由博客园博主Aerfajj提供。<br/>
原文连接:https://www.cnblogs.com/Aerfajj/p/10738231.html</div><br>
    <h2 id="基础部分">基础部分</h2>
<h3 id="创建一个react的项目">创建一个react的项目</h3>
<ul>
<li><p>创建一个react的项目</p>
<p>全局安装 react 指令</p>
<pre><code><code>    // 全局安装react （根据需要安装，不是必须的）
    npm i -g react // 或者 yarn -global react

    // 全局安装 react的脚手架 (创建react的应用，必须安装脚手架)
    npm i -g create-react-app // 或者 yarn -global create-react-app</code></pre>
<p>使用脚手架创建应用</p>
<pre><code><code>create-react-app 应用名称
// 例如创建一个TodoList应用
create-react-app todo-list</code></pre>
<p>注意点：</p>
<pre><code><code>  1.全局安装create-react-app才能使用脚手架创建应用
  2.应用名称全部为小写字母，不能出现“TodoList”这样的名称</code></pre></li>
</ul>
<h3 id="组件的使用">组件的使用</h3>
<ul>
<li><p>组件的组成</p>
<pre><code><code>    // React 是react组件必不可少的，用于支持jsx语法的模块，虽然看不到引用，但是不能少
    // Component 所有的react的组件都继承于Component，它是react组件的基类
    import React, { Component } from &#39;react&#39;;

    // TodoItem 自定义的组件
    import TodoItem from &quot;./TodoItem&quot;

    // 定义TodoList组件 ，该组件继承于基类Component
    class TodoList extends Component {
            /***
             * constructor 当前类的构造函数
            * props 简单的理解：是父类传递的参数，例如 传递的值 或 方法，它是一个对象
            * super(props) 简单的理解是：继承父类中的传递的参数
            **/
        constructor(props){
            super(props)
            // state 是 所有react变量的仓储，简单理解就是：当前组件的变量都放在这个对象中
            this.state = {
                inputValue: &quot;&quot;,
                List: []
            }
            // 使用 bind绑定this，让方法中的this永远指向当前的组件（可根据需求改变this的指向）
            this.getList =  this.getList.bind(this)
            this.inputChang = this.inputChang.bind(this)
            this.addItem = this.addItem.bind(this)
            this.delItem = this.delItem.bind(this)
        }
        // react组件必不可少的方法，return 返回的是jsx的模板，可以理解为类似html+js的模板
        render() {
            return (
                {/*在jsx中只能有一个根标签，使用&lt;&gt;&lt;/&gt;(幽灵标签)包裹，既能满足jsx的语法格式，在浏览器解析时不会解析幽灵标签，减少了dom树结构节点 */}
                &lt;&gt;
                    &lt;div&gt;
                        &lt;input value={this.state.inputValue} onChange={this.inputChang} /&gt; &lt;button onClick={this.addItem}&gt;添加&lt;/button&gt;
                    &lt;/div&gt;
                    &lt;ul&gt;
                        {this.getList()}
                    &lt;/ul&gt;
                &lt;/&gt;
            );
        };

        // 遍历输出item
        getList() {
            ...
        }
        // 动态改变输入框的值
        inputChang( e ) {
            ...
        }

        // 添加item
        addItem() {
            ...
        }

        // 删除item
        delItem(index) {
            ...
        }
    }
    // 导出TodoList
    export default TodoList;</code></pre></li>
<li><p>认识jsx</p>
<p>简单的jsx的语法</p>
<pre><code><code>...
    render() {
        return (
            {/*在jsx中只能有一个根标签，使用&lt;&gt;&lt;/&gt;(幽灵标签)包裹，既能满足jsx的语法格式，在浏览器解析时不会解析幽灵标签，减少了dom树结构节点 */}
            &lt;&gt;
                &lt;div&gt;
                    &lt;input value={this.state.inputValue} onChange={this.inputChang} /&gt; &lt;button onClick={this.addItem}&gt;添加&lt;/button&gt;
                &lt;/div&gt;
                &lt;ul&gt;
                    {this.getList()}
                &lt;/ul&gt;
            &lt;/&gt;
        );
    };

...</code></pre>
<ol>
<li><p>在jsx中只能有一个根标签，使用&lt;&gt;&lt;/&gt;(幽灵标签)包裹，既能满足jsx的语法格式，在浏览器解析时不会解析幽灵标签，减少了dom树结构节点,也可以使用代码片段（Fragments ），效果和&lt;&gt;&lt;/&gt;相同，只是Fragments 还有更广泛的使用，后面会有详细说明</p></li>
<li><p>在jsx中使用注释，多行使用{/* 注释内容 */}，单行使用</p>
<pre><code><code>    // 多行

    {/* 多行注释内容 */}
    {/*
        多行注释内容
    */}


    // 单行
    {
        // 单行注释内容
    }
</code></pre></li>
<li><p>在jsx中使用组件的变量或者方法，使用{}包裹</p></li>
<li><p>在jsx中绑定的方法默认this指向undefined，所以需要使用bind绑定this的指向</p>
<pre><code><code>    // 方式1： 在constructor指定this
    constructor(props){
        super(props)
        this.state = {
            inputValue: &quot;&quot;,
            List: []
        }
        this.getList =  this.getList.bind(this)
        this.inputChang = this.inputChang.bind(this)
        this.addItem = this.addItem.bind(this)
        this.delItem = this.delItem.bind(this)
    }

    // 方式2：绑定事件的时候指定this

    ...
        &lt;li onClick={this.delItem.bind(this,index)}&gt;&lt;/li&gt;
    ...
</code></pre></li>
</ol></li>
<li><p>组件的基本通讯</p></li>
</ul>
<ol>
<li><p>最简单的 父 ---&gt; 子 传值</p>
<pre><code><code>
// 父组件通过在子组件标签上设置属性传递数据
    &lt;Boy
        teacherName={ this.state.teacherName }
    /&gt;

    &lt;Girl
        teacherName={ this.state.teacherName }
    /&gt;

// 子组件通过this.props获取父组件传递的数据
// this.props.teacherName 获取老师的名称
    render(){
        return (
            &lt;&gt;
                &lt;p&gt;
                    我是{this.state.boyName},我的老师是{this.props.teacherName},
                    我对老师很
                    &lt;button onClick={()=&gt; this.props.say(this.state.boyName,&quot;满意&quot;) } &gt;
                        满意
                    &lt;/button&gt;
                &lt;/p&gt;
            &lt;/&gt;
        )
    }
</code></pre></li>
<li><p>最简单的 子 ---&gt; 父 通讯</p>
<pre><code><code>
// 父组件通过在子组件标签上设置属性传递数据
    &lt;Boy
        say = { this.stuSay }
    /&gt;

    &lt;Girl
        say = { this.stuSay }
    /&gt;
// 子组件通过this.props获取父组件传递的数据
// this.props.say 获取父组件提供的方法，通过调用父组件的方法，将传递的数据作为参数传入，当父组件的方法被调用，就通过获取当前方法参数的方式，得到了子组件传递的数据
    render(){
        return (
            &lt;&gt;
                &lt;p&gt;
                    我是{this.state.boyName},
                    我对老师很
                    &lt;button onClick={()=&gt; this.props.say(this.state.boyName,&quot;满意&quot;) } &gt;
                        满意
                    &lt;/button&gt;
                &lt;/p&gt;
            &lt;/&gt;
        )
    }
</code></pre></li>
<li><p>最简单的非父子通讯</p></li>
</ol>
<p>核心思路：找到共同的父组件，同时使用父组件传递的值和方法</p>
<p>过程有些复杂，这里省略了</p>
<p>teacher.js</p>
<pre><code><code>import React,{ Component } from &quot;react&quot;

// 导入 Boy（男孩） 和 Girl（女孩） 组件
import Boy from &quot;./boy&quot;
import Girl from &quot;./girl&quot;

export default class Teacher extends Component {
    constructor(props){
        super(props)
        this.state = {
            teacherName: &quot;Tom&quot;,
            stuName: &quot;&quot;,
            stuSayContent: &quot;&quot;,
            boyName: &quot;&quot;,
            girlName: &quot;&quot;,
            boySayContent: &quot;&quot;,
            girlSayContent: &quot;&quot;
        }
        this.stuSay = this.stuSay.bind(this);
        this.boySaySecret = this.boySaySecret.bind(this);
        this.grilSaySecret = this.grilSaySecret.bind(this);
    }
    render(){
        let evaluation = false
        if (this.state.stuName!==&quot;&quot; &amp;&amp; this.state.stuSayContent) {
            evaluation = true
        }
        return (
            &lt;&gt;
                &lt;p&gt;我是{ this.state.teacherName }老师&lt;/p&gt;

                &lt;div&gt;
                    {
                        evaluation ? (&lt;p&gt;学生评价：{this.state.stuName}对我很{this.state.stuSayContent}&lt;/p&gt;) : &quot; &quot;
                    }
                &lt;/div&gt;

                &lt;Boy
                    say = { this.stuSay }
                    teacherName={ this.state.teacherName }
                    boySaySecret = {this.boySaySecret}
                    girlSayContent = {this.state.girlSayContent}
                /&gt;

                &lt;Girl
                    say = { this.stuSay }
                    teacherName={ this.state.teacherName }
                    grilSaySecret = {this.grilSaySecret}
                    boySayContent = {this.state.boySayContent}
               /&gt;
            &lt;/&gt;
        )
    }
    stuSay(stuName,stuSayContent){
        this.setState(()=&gt;{
            return {
                stuSayContent,
                stuName
            }
        })
    }
    boySaySecret(constent){
        this.setState(()=&gt;{
            return {
                boySayContent : constent
            }
        })
    }
    grilSaySecret(constent){
        this.setState(()=&gt;{
            return {
                girlSayContent : constent
            }
        })
    }
}
</code></pre>
<p>boy.js</p>
<pre><code><code>
import React,{ Component } from &quot;react&quot;

export default class Boy extends Component {
    constructor(props){
        super(props)
        this.state = {
            boyName: &quot;龙震天&quot;
        }
    }
    render(){
        return (
            &lt;&gt;
                &lt;p&gt;
                    我是{this.state.boyName},我的老师是{this.props.teacherName},
                    我对老师很
                    &lt;button onClick={()=&gt; this.props.say(this.state.boyName,&quot;满意&quot;) } &gt;
                        满意
                    &lt;/button&gt;,
                    我想对女孩说：&lt;button onClick={()=&gt; this.props.boySaySecret(&quot;我喜欢你&quot;)}&gt;悄悄话&lt;/button&gt;，
                    她对我说：{this.props.girlSayContent}

                &lt;/p&gt;
            &lt;/&gt;
        )
    }

}
</code></pre>
<p>gril.js</p>
<pre><code><code>
import React,{ Component } from &quot;react&quot;

export default class Boy extends Component {
    constructor(props){
        super(props)
        this.state = {
            girlName: &quot;怜香玉&quot;
        }
    }
    render(){
        return (
            &lt;&gt;
                &lt;p&gt;
                    我是{this.state.girlName}，我的老师是{this.props.teacherName},
                    我对老师很
                    &lt;button onClick={()=&gt; this.props.say(this.state.girlName,&quot;不满意&quot;) } &gt;
                        不满意
                    &lt;/button&gt;,
                    我想对男孩说：&lt;button onClick={() =&gt; this.props.grilSaySecret(&quot;我也是&quot;)}&gt;悄悄话&lt;/button&gt;，
                    他对我说：{this.props.boySayContent}
                &lt;/p&gt;
            &lt;/&gt;
        )
    }

}

</code></pre>
<h2 id="高级部分">高级部分</h2>
<p>待续....</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>