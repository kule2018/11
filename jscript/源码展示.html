<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修源码展示' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>源码展示</center></div><div class='banquan'>原文出处:本文由博客园博主世界を変える御宅族提供。<br/>
原文连接:https://www.cnblogs.com/otakus/p/showcodes.html</div><br>
    <h1>&nbsp;樱花效果</h1>
<p>需要修改才能成为Js</p>
<p>&nbsp;</p>
<p>&lt;!doctype html&gt;<br />&lt;html lang="en"&gt;&lt;head&gt;<br />&nbsp; &lt;meta charset="UTF-8"&gt;<br />&nbsp; &lt;title&gt;sakura&lt;/title&gt;<br />&nbsp; &lt;style&gt;<br />&nbsp; body {<br />&nbsp;&nbsp;&nbsp; padding:0;<br />&nbsp;&nbsp;&nbsp; margin:0;<br />&nbsp;&nbsp;&nbsp; overflow:hidden;<br />&nbsp;&nbsp; &nbsp;height: 600px;<br />}<br />canvas {<br />&nbsp;&nbsp;&nbsp; padding:0;<br />&nbsp;&nbsp;&nbsp; margin:0;<br />}<br />div.btnbg {<br />&nbsp;&nbsp;&nbsp; position:fixed;<br />&nbsp;&nbsp;&nbsp; left:0;<br />&nbsp;&nbsp;&nbsp; top:0;<br />}<br />&nbsp; &lt;/style&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br /><br />&lt;canvas id="sakura" width="1920" height="977"&gt;&lt;/canvas&gt;<br />&lt;div class="btnbg"&gt;<br />&lt;/div&gt;<br /><br />&lt;!-- sakura shader --&gt;<br />&lt;script id="sakura_point_vsh" type="x-shader/x_vertex"&gt;<br />uniform mat4 uProjection;<br />uniform mat4 uModelview;<br />uniform vec3 uResolution;<br />uniform vec3 uOffset;<br />uniform vec3 uDOF;&nbsp; //x:focus distance, y:focus radius, z:max radius<br />uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start<br /><br />attribute vec3 aPosition;<br />attribute vec3 aEuler;<br />attribute vec2 aMisc; //x:size, y:fade<br /><br />varying vec3 pposition;<br />varying float psize;<br />varying float palpha;<br />varying float pdist;<br /><br />//varying mat3 rotMat;<br />varying vec3 normX;<br />varying vec3 normY;<br />varying vec3 normZ;<br />varying vec3 normal;<br /><br />varying float diffuse;<br />varying float specular;<br />varying float rstop;<br />varying float distancefade;<br /><br />void main(void) {<br />&nbsp;&nbsp;&nbsp; // Projection is based on vertical angle<br />&nbsp;&nbsp;&nbsp; vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0);<br />&nbsp;&nbsp;&nbsp; gl_Position = uProjection * pos;<br />&nbsp;&nbsp;&nbsp; gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; pposition = pos.xyz;<br />&nbsp;&nbsp;&nbsp; psize = aMisc.x;<br />&nbsp;&nbsp;&nbsp; pdist = length(pos.xyz);<br />&nbsp;&nbsp;&nbsp; palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; vec3 elrsn = sin(aEuler);<br />&nbsp;&nbsp;&nbsp; vec3 elrcs = cos(aEuler);<br />&nbsp;&nbsp;&nbsp; mat3 rotx = mat3(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0, 0.0, 0.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0, elrcs.x, elrsn.x,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0, -elrsn.x, elrcs.x<br />&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp;&nbsp; mat3 roty = mat3(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elrcs.y, 0.0, -elrsn.y,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0, 1.0, 0.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elrsn.y, 0.0, elrcs.y<br />&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp;&nbsp; mat3 rotz = mat3(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elrcs.z, elrsn.z, 0.0, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -elrsn.z, elrcs.z, 0.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0, 0.0, 1.0<br />&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp;&nbsp; mat3 rotmat = rotx * roty * rotz;<br />&nbsp;&nbsp;&nbsp; normal = rotmat[2];<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; mat3 trrotm = mat3(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotmat[0][0], rotmat[1][0], rotmat[2][0],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotmat[0][1], rotmat[1][1], rotmat[2][1],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotmat[0][2], rotmat[1][2], rotmat[2][2]<br />&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp;&nbsp; normX = trrotm[0];<br />&nbsp;&nbsp;&nbsp; normY = trrotm[1];<br />&nbsp;&nbsp;&nbsp; normZ = trrotm[2];<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; float tmpdfs = dot(lit, normal);<br />&nbsp;&nbsp;&nbsp; if(tmpdfs &lt; 0.0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal = -normal;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpdfs = dot(lit, normal);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; diffuse = 0.4 + tmpdfs;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; vec3 eyev = normalize(-pos.xyz);<br />&nbsp;&nbsp;&nbsp; if(dot(eyev, normal) &gt; 0.0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vec3 hv = normalize(eyev + lit);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specular = pow(max(dot(hv, normal), 0.0), 20.0);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specular = 0.0;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0);<br />&nbsp;&nbsp;&nbsp; rstop = pow(rstop, 0.5);<br />&nbsp;&nbsp;&nbsp; //-0.69315 = ln(0.5)<br />&nbsp;&nbsp;&nbsp; distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y));<br />}<br />&lt;/script&gt;<br />&lt;script id="sakura_point_fsh" type="x-shader/x_fragment"&gt;<br />#ifdef GL_ES<br />//precision mediump float;<br />precision highp float;<br />#endif<br /><br />uniform vec3 uDOF;&nbsp; //x:focus distance, y:focus radius, z:max radius<br />uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start<br /><br />const vec3 fadeCol = vec3(0.08, 0.03, 0.06);<br /><br />varying vec3 pposition;<br />varying float psize;<br />varying float palpha;<br />varying float pdist;<br /><br />//varying mat3 rotMat;<br />varying vec3 normX;<br />varying vec3 normY;<br />varying vec3 normZ;<br />varying vec3 normal;<br /><br />varying float diffuse;<br />varying float specular;<br />varying float rstop;<br />varying float distancefade;<br /><br />float ellipse(vec2 p, vec2 o, vec2 r) {<br />&nbsp;&nbsp;&nbsp; vec2 lp = (p - o) / r;<br />&nbsp;&nbsp;&nbsp; return length(lp) - 1.0;<br />}<br /><br />void main(void) {<br />&nbsp;&nbsp;&nbsp; vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;<br />&nbsp;&nbsp;&nbsp; vec3 d = vec3(0.0, 0.0, -1.0);<br />&nbsp;&nbsp;&nbsp; float nd = normZ.z; //dot(-normZ, d);<br />&nbsp;&nbsp;&nbsp; if(abs(nd) &lt; 0.0001) discard;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; float np = dot(normZ, p);<br />&nbsp;&nbsp;&nbsp; vec3 tp = p + d * np / nd;<br />&nbsp;&nbsp;&nbsp; vec2 coord = vec2(dot(normX, tp), dot(normY, tp));<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //angle = 15 degree<br />&nbsp;&nbsp;&nbsp; const float flwrsn = 0.258819045102521;<br />&nbsp;&nbsp;&nbsp; const float flwrcs = 0.965925826289068;<br />&nbsp;&nbsp;&nbsp; mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs);<br />&nbsp;&nbsp;&nbsp; vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; float r;<br />&nbsp;&nbsp;&nbsp; if(flwrp.x &lt; 0.0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; if(r &gt; rstop) discard;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r);<br />&nbsp;&nbsp;&nbsp; float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35));<br />&nbsp;&nbsp;&nbsp; col *= vec3(1.0, grady, grady);<br />&nbsp;&nbsp;&nbsp; col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3));<br />&nbsp;&nbsp;&nbsp; col = col * diffuse + specular;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; col = mix(fadeCol, col, distancefade);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; float alpha = (rstop &gt; 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0;<br />&nbsp;&nbsp;&nbsp; alpha = smoothstep(0.0, 1.0, alpha) * palpha;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl_FragColor = vec4(col * 0.5, alpha);<br />}<br />&lt;/script&gt;<br />&lt;!-- effects --&gt;<br />&lt;script id="fx_common_vsh" type="x-shader/x_vertex"&gt;<br />uniform vec3 uResolution;<br />attribute vec2 aPosition;<br /><br />varying vec2 texCoord;<br />varying vec2 screenCoord;<br /><br />void main(void) {<br />&nbsp;&nbsp;&nbsp; gl_Position = vec4(aPosition, 0.0, 1.0);<br />&nbsp;&nbsp;&nbsp; texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);<br />&nbsp;&nbsp;&nbsp; screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);<br />}<br />&lt;/script&gt;<br />&lt;script id="bg_fsh" type="x-shader/x_fragment"&gt;<br />#ifdef GL_ES<br />//precision mediump float;<br />precision highp float;<br />#endif<br /><br />uniform vec2 uTimes;<br /><br />varying vec2 texCoord;<br />varying vec2 screenCoord;<br /><br />void main(void) {<br />&nbsp;&nbsp;&nbsp; vec3 col;<br />&nbsp;&nbsp;&nbsp; float c;<br />&nbsp;&nbsp;&nbsp; vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);<br />&nbsp;&nbsp;&nbsp; c = exp(-pow(length(tmpv) * 1.8, 2.0));<br />&nbsp;&nbsp;&nbsp; col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);<br />&nbsp;&nbsp;&nbsp; gl_FragColor = vec4(col * 0.5, 1.0);<br />}<br />&lt;/script&gt;<br />&lt;script id="fx_brightbuf_fsh" type="x-shader/x_fragment"&gt;<br />#ifdef GL_ES<br />//precision mediump float;<br />precision highp float;<br />#endif<br />uniform sampler2D uSrc;<br />uniform vec2 uDelta;<br /><br />varying vec2 texCoord;<br />varying vec2 screenCoord;<br /><br />void main(void) {<br />&nbsp;&nbsp;&nbsp; vec4 col = texture2D(uSrc, texCoord);<br />&nbsp;&nbsp;&nbsp; gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0);<br />}<br />&lt;/script&gt;<br />&lt;script id="fx_dirblur_r4_fsh" type="x-shader/x_fragment"&gt;<br />#ifdef GL_ES<br />//precision mediump float;<br />precision highp float;<br />#endif<br />uniform sampler2D uSrc;<br />uniform vec2 uDelta;<br />uniform vec4 uBlurDir; //dir(x, y), stride(z, w)<br /><br />varying vec2 texCoord;<br />varying vec2 screenCoord;<br /><br />void main(void) {<br />&nbsp;&nbsp;&nbsp; vec4 col = texture2D(uSrc, texCoord);<br />&nbsp;&nbsp;&nbsp; col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);<br />&nbsp;&nbsp;&nbsp; col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);<br />&nbsp;&nbsp;&nbsp; col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);<br />&nbsp;&nbsp;&nbsp; col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);<br />&nbsp;&nbsp;&nbsp; gl_FragColor = col / 5.0;<br />}<br />&lt;/script&gt;<br />&lt;!-- effect fragment shader template --&gt;<br />&lt;script id="fx_common_fsh" type="x-shader/x_fragment"&gt;<br />#ifdef GL_ES<br />//precision mediump float;<br />precision highp float;<br />#endif<br />uniform sampler2D uSrc;<br />uniform vec2 uDelta;<br /><br />varying vec2 texCoord;<br />varying vec2 screenCoord;<br /><br />void main(void) {<br />&nbsp;&nbsp;&nbsp; gl_FragColor = texture2D(uSrc, texCoord);<br />}<br />&lt;/script&gt;<br />&lt;!-- post processing --&gt;<br />&lt;script id="pp_final_vsh" type="x-shader/x_vertex"&gt;<br />uniform vec3 uResolution;<br />attribute vec2 aPosition;<br />varying vec2 texCoord;<br />varying vec2 screenCoord;<br />void main(void) {<br />&nbsp;&nbsp;&nbsp; gl_Position = vec4(aPosition, 0.0, 1.0);<br />&nbsp;&nbsp;&nbsp; texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);<br />&nbsp;&nbsp;&nbsp; screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);<br />}<br />&lt;/script&gt;<br />&lt;script id="pp_final_fsh" type="x-shader/x_fragment"&gt;<br />#ifdef GL_ES<br />//precision mediump float;<br />precision highp float;<br />#endif<br />uniform sampler2D uSrc;<br />uniform sampler2D uBloom;<br />uniform vec2 uDelta;<br />varying vec2 texCoord;<br />varying vec2 screenCoord;<br />void main(void) {<br />&nbsp;&nbsp;&nbsp; vec4 srccol = texture2D(uSrc, texCoord) * 2.0;<br />&nbsp;&nbsp;&nbsp; vec4 bloomcol = texture2D(uBloom, texCoord);<br />&nbsp;&nbsp;&nbsp; vec4 col;<br />&nbsp;&nbsp;&nbsp; col = srccol + bloomcol * (vec4(1.0) + srccol);<br />&nbsp;&nbsp;&nbsp; col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);<br />&nbsp;&nbsp;&nbsp; col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2)<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl_FragColor = vec4(col.rgb, 1.0);<br />&nbsp;&nbsp;&nbsp; gl_FragColor.a = 1.0;<br />}<br />&lt;/script&gt;<br />&lt;script&gt;<br />// Utilities<br />var Vector3 = {};<br />var Matrix44 = {};<br />Vector3.create = function(x, y, z) {<br />&nbsp;&nbsp;&nbsp; return {'x':x, 'y':y, 'z':z};<br />};<br />Vector3.dot = function (v0, v1) {<br />&nbsp;&nbsp;&nbsp; return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;<br />};<br />Vector3.cross = function (v, v0, v1) {<br />&nbsp;&nbsp;&nbsp; v.x = v0.y * v1.z - v0.z * v1.y;<br />&nbsp;&nbsp;&nbsp; v.y = v0.z * v1.x - v0.x * v1.z;<br />&nbsp;&nbsp;&nbsp; v.z = v0.x * v1.y - v0.y * v1.x;<br />};<br />Vector3.normalize = function (v) {<br />&nbsp;&nbsp;&nbsp; var l = v.x * v.x + v.y * v.y + v.z * v.z;<br />&nbsp;&nbsp;&nbsp; if(l &gt; 0.00001) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = 1.0 / Math.sqrt(l);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.x *= l;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.y *= l;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.z *= l;<br />&nbsp;&nbsp;&nbsp; }<br />};<br />Vector3.arrayForm = function(v) {<br />&nbsp;&nbsp;&nbsp; if(v.array) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.array[0] = v.x;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.array[1] = v.y;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.array[2] = v.z;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.array = new Float32Array([v.x, v.y, v.z]);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return v.array;<br />};<br />Matrix44.createIdentity = function () {<br />&nbsp;&nbsp;&nbsp; return new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);<br />};<br />Matrix44.loadProjection = function (m, aspect, vdeg, near, far) {<br />&nbsp;&nbsp;&nbsp; var h = near * Math.tan(vdeg * Math.PI / 180.0 * 0.5) * 2.0;<br />&nbsp;&nbsp;&nbsp; var w = h * aspect;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[0] = 2.0 * near / w;<br />&nbsp;&nbsp;&nbsp; m[1] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[2] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[3] = 0.0;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[4] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[5] = 2.0 * near / h;<br />&nbsp;&nbsp;&nbsp; m[6] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[7] = 0.0;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[8] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[9] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[10] = -(far + near) / (far - near);<br />&nbsp;&nbsp;&nbsp; m[11] = -1.0;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[12] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[13] = 0.0;<br />&nbsp;&nbsp;&nbsp; m[14] = -2.0 * far * near / (far - near);<br />&nbsp;&nbsp;&nbsp; m[15] = 0.0;<br />};<br />Matrix44.loadLookAt = function (m, vpos, vlook, vup) {<br />&nbsp;&nbsp;&nbsp; var frontv = Vector3.create(vpos.x - vlook.x, vpos.y - vlook.y, vpos.z - vlook.z);<br />&nbsp;&nbsp;&nbsp; Vector3.normalize(frontv);<br />&nbsp;&nbsp;&nbsp; var sidev = Vector3.create(1.0, 0.0, 0.0);<br />&nbsp;&nbsp;&nbsp; Vector3.cross(sidev, vup, frontv);<br />&nbsp;&nbsp;&nbsp; Vector3.normalize(sidev);<br />&nbsp;&nbsp;&nbsp; var topv = Vector3.create(1.0, 0.0, 0.0);<br />&nbsp;&nbsp;&nbsp; Vector3.cross(topv, frontv, sidev);<br />&nbsp;&nbsp;&nbsp; Vector3.normalize(topv);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[0] = sidev.x;<br />&nbsp;&nbsp;&nbsp; m[1] = topv.x;<br />&nbsp;&nbsp;&nbsp; m[2] = frontv.x;<br />&nbsp;&nbsp;&nbsp; m[3] = 0.0;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[4] = sidev.y;<br />&nbsp;&nbsp;&nbsp; m[5] = topv.y;<br />&nbsp;&nbsp;&nbsp; m[6] = frontv.y;<br />&nbsp;&nbsp;&nbsp; m[7] = 0.0;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[8] = sidev.z;<br />&nbsp;&nbsp;&nbsp; m[9] = topv.z;<br />&nbsp;&nbsp;&nbsp; m[10] = frontv.z;<br />&nbsp;&nbsp;&nbsp; m[11] = 0.0;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; m[12] = -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]);<br />&nbsp;&nbsp;&nbsp; m[13] = -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]);<br />&nbsp;&nbsp;&nbsp; m[14] = -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]);<br />&nbsp;&nbsp;&nbsp; m[15] = 1.0;<br />};<br /><br />//<br />var timeInfo = {<br />&nbsp;&nbsp;&nbsp; 'start':0, 'prev':0, // Date<br />&nbsp;&nbsp;&nbsp; 'delta':0, 'elapsed':0 // Number(sec)<br />};<br /><br />//<br />var gl;<br />var renderSpec = {<br />&nbsp;&nbsp;&nbsp; 'width':0,<br />&nbsp;&nbsp;&nbsp; 'height':0,<br />&nbsp;&nbsp;&nbsp; 'aspect':1,<br />&nbsp;&nbsp;&nbsp; 'array':new Float32Array(3),<br />&nbsp;&nbsp;&nbsp; 'halfWidth':0,<br />&nbsp;&nbsp;&nbsp; 'halfHeight':0,<br />&nbsp;&nbsp;&nbsp; 'halfArray':new Float32Array(3)<br />&nbsp;&nbsp;&nbsp; // and some render targets. see setViewport()<br />};<br />renderSpec.setSize = function(w, h) {<br />&nbsp;&nbsp;&nbsp; renderSpec.width = w;<br />&nbsp;&nbsp;&nbsp; renderSpec.height = h;<br />&nbsp;&nbsp;&nbsp; renderSpec.aspect = renderSpec.width / renderSpec.height;<br />&nbsp;&nbsp;&nbsp; renderSpec.array[0] = renderSpec.width;<br />&nbsp;&nbsp;&nbsp; renderSpec.array[1] = renderSpec.height;<br />&nbsp;&nbsp;&nbsp; renderSpec.array[2] = renderSpec.aspect;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; renderSpec.halfWidth = Math.floor(w / 2);<br />&nbsp;&nbsp;&nbsp; renderSpec.halfHeight = Math.floor(h / 2);<br />&nbsp;&nbsp;&nbsp; renderSpec.halfArray[0] = renderSpec.halfWidth;<br />&nbsp;&nbsp;&nbsp; renderSpec.halfArray[1] = renderSpec.halfHeight;<br />&nbsp;&nbsp;&nbsp; renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight;<br />};<br /><br />function deleteRenderTarget(rt) {<br />&nbsp;&nbsp;&nbsp; gl.deleteFramebuffer(rt.frameBuffer);<br />&nbsp;&nbsp;&nbsp; gl.deleteRenderbuffer(rt.renderBuffer);<br />&nbsp;&nbsp;&nbsp; gl.deleteTexture(rt.texture);<br />}<br /><br />function createRenderTarget(w, h) {<br />&nbsp;&nbsp;&nbsp; var ret = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'width':w,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'height':h,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'sizeArray':new Float32Array([w, h, w / h]),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'dtxArray':new Float32Array([1.0 / w, 1.0 / h])<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; ret.frameBuffer = gl.createFramebuffer();<br />&nbsp;&nbsp;&nbsp; ret.renderBuffer = gl.createRenderbuffer();<br />&nbsp;&nbsp;&nbsp; ret.texture = gl.createTexture();<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.bindTexture(gl.TEXTURE_2D, ret.texture);<br />&nbsp;&nbsp;&nbsp; gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);<br />&nbsp;&nbsp;&nbsp; gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);<br />&nbsp;&nbsp;&nbsp; gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);<br />&nbsp;&nbsp;&nbsp; gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);<br />&nbsp;&nbsp;&nbsp; gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer);<br />&nbsp;&nbsp;&nbsp; gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ret.texture, 0);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer);<br />&nbsp;&nbsp;&nbsp; gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);<br />&nbsp;&nbsp;&nbsp; gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, ret.renderBuffer);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.bindTexture(gl.TEXTURE_2D, null);<br />&nbsp;&nbsp;&nbsp; gl.bindRenderbuffer(gl.RENDERBUFFER, null);<br />&nbsp;&nbsp;&nbsp; gl.bindFramebuffer(gl.FRAMEBUFFER, null);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return ret;<br />}<br /><br />function compileShader(shtype, shsrc) {<br />&nbsp;&nbsp; &nbsp;var retsh = gl.createShader(shtype);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;gl.shaderSource(retsh, shsrc);<br />&nbsp;&nbsp; &nbsp;gl.compileShader(retsh);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;if(!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) {<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;var errlog = gl.getShaderInfoLog(retsh);<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gl.deleteShader(retsh);<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;console.error(errlog);<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return null;<br />&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;return retsh;<br />}<br /><br />function createShader(vtxsrc, frgsrc, uniformlist, attrlist) {<br />&nbsp;&nbsp;&nbsp; var vsh = compileShader(gl.VERTEX_SHADER, vtxsrc);<br />&nbsp;&nbsp;&nbsp; var fsh = compileShader(gl.FRAGMENT_SHADER, frgsrc);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; if(vsh == null || fsh == null) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; var prog = gl.createProgram();<br />&nbsp;&nbsp;&nbsp; gl.attachShader(prog, vsh);<br />&nbsp;&nbsp;&nbsp; gl.attachShader(prog, fsh);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.deleteShader(vsh);<br />&nbsp;&nbsp;&nbsp; gl.deleteShader(fsh);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.linkProgram(prog);<br />&nbsp;&nbsp;&nbsp; if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var errlog = gl.getProgramInfoLog(prog);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.error(errlog);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; if(uniformlist) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prog.uniforms = {};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(var i = 0; i &lt; uniformlist.length; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prog.uniforms[uniformlist[i]] = gl.getUniformLocation(prog, uniformlist[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; if(attrlist) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prog.attributes = {};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(var i = 0; i &lt; attrlist.length; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var attr = attrlist[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prog.attributes[attr] = gl.getAttribLocation(prog, attr);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return prog;<br />}<br /><br />function useShader(prog) {<br />&nbsp;&nbsp;&nbsp; gl.useProgram(prog);<br />&nbsp;&nbsp;&nbsp; for(var attr in prog.attributes) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.enableVertexAttribArray(prog.attributes[attr]);;<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />function unuseShader(prog) {<br />&nbsp;&nbsp;&nbsp; for(var attr in prog.attributes) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.disableVertexAttribArray(prog.attributes[attr]);;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; gl.useProgram(null);<br />}<br /><br />/////<br />var projection = {<br />&nbsp;&nbsp;&nbsp; 'angle':60,<br />&nbsp;&nbsp;&nbsp; 'nearfar':new Float32Array([0.1, 100.0]),<br />&nbsp;&nbsp;&nbsp; 'matrix':Matrix44.createIdentity()<br />};<br />var camera = {<br />&nbsp;&nbsp;&nbsp; 'position':Vector3.create(0, 0, 100),<br />&nbsp;&nbsp;&nbsp; 'lookat':Vector3.create(0, 0, 0),<br />&nbsp;&nbsp;&nbsp; 'up':Vector3.create(0, 1, 0),<br />&nbsp;&nbsp;&nbsp; 'dof':Vector3.create(10.0, 4.0, 8.0),<br />&nbsp;&nbsp;&nbsp; 'matrix':Matrix44.createIdentity()<br />};<br /><br />var pointFlower = {};<br />var meshFlower = {};<br />var sceneStandBy = false;<br /><br />var BlossomParticle = function () {<br />&nbsp;&nbsp;&nbsp; this.velocity = new Array(3);<br />&nbsp;&nbsp;&nbsp; this.rotation = new Array(3);<br />&nbsp;&nbsp;&nbsp; this.position = new Array(3);<br />&nbsp;&nbsp;&nbsp; this.euler = new Array(3);<br />&nbsp;&nbsp;&nbsp; this.size = 1.0;<br />&nbsp;&nbsp;&nbsp; this.alpha = 1.0;<br />&nbsp;&nbsp;&nbsp; this.zkey = 0.0;<br />};<br /><br />BlossomParticle.prototype.setVelocity = function (vx, vy, vz) {<br />&nbsp;&nbsp;&nbsp; this.velocity[0] = vx;<br />&nbsp;&nbsp;&nbsp; this.velocity[1] = vy;<br />&nbsp;&nbsp;&nbsp; this.velocity[2] = vz;<br />};<br /><br />BlossomParticle.prototype.setRotation = function (rx, ry, rz) {<br />&nbsp;&nbsp;&nbsp; this.rotation[0] = rx;<br />&nbsp;&nbsp;&nbsp; this.rotation[1] = ry;<br />&nbsp;&nbsp;&nbsp; this.rotation[2] = rz;<br />};<br /><br />BlossomParticle.prototype.setPosition = function (nx, ny, nz) {<br />&nbsp;&nbsp;&nbsp; this.position[0] = nx;<br />&nbsp;&nbsp;&nbsp; this.position[1] = ny;<br />&nbsp;&nbsp;&nbsp; this.position[2] = nz;<br />};<br /><br />BlossomParticle.prototype.setEulerAngles = function (rx, ry, rz) {<br />&nbsp;&nbsp;&nbsp; this.euler[0] = rx;<br />&nbsp;&nbsp;&nbsp; this.euler[1] = ry;<br />&nbsp;&nbsp;&nbsp; this.euler[2] = rz;<br />};<br /><br />BlossomParticle.prototype.setSize = function (s) {<br />&nbsp;&nbsp;&nbsp; this.size = s;<br />};<br /><br />BlossomParticle.prototype.update = function (dt, et) {<br />&nbsp;&nbsp;&nbsp; this.position[0] += this.velocity[0] * dt;<br />&nbsp;&nbsp;&nbsp; this.position[1] += this.velocity[1] * dt;<br />&nbsp;&nbsp;&nbsp; this.position[2] += this.velocity[2] * dt;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; this.euler[0] += this.rotation[0] * dt;<br />&nbsp;&nbsp;&nbsp; this.euler[1] += this.rotation[1] * dt;<br />&nbsp;&nbsp;&nbsp; this.euler[2] += this.rotation[2] * dt;<br />};<br /><br />function createPointFlowers() {<br />&nbsp;&nbsp;&nbsp; // get point sizes<br />&nbsp;&nbsp;&nbsp; var prm = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);<br />&nbsp;&nbsp;&nbsp; renderSpec.pointSize = {'min':prm[0], 'max':prm[1]};<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; var vtxsrc = document.getElementById("sakura_point_vsh").textContent;<br />&nbsp;&nbsp;&nbsp; var frgsrc = document.getElementById("sakura_point_fsh").textContent;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; pointFlower.program = createShader(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vtxsrc, frgsrc,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['uProjection', 'uModelview', 'uResolution', 'uOffset', 'uDOF', 'uFade'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['aPosition', 'aEuler', 'aMisc']<br />&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; useShader(pointFlower.program);<br />&nbsp;&nbsp;&nbsp; pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]);<br />&nbsp;&nbsp;&nbsp; pointFlower.fader = Vector3.create(0.0, 10.0, 0.0);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; // paramerters: velocity[3], rotate[3]<br />&nbsp;&nbsp;&nbsp; pointFlower.numFlowers = 1600;<br />&nbsp;&nbsp;&nbsp; pointFlower.particles = new Array(pointFlower.numFlowers);<br />&nbsp;&nbsp;&nbsp; // vertex attributes {position[3], euler_xyz[3], size[1]}<br />&nbsp;&nbsp;&nbsp; pointFlower.dataArray = new Float32Array(pointFlower.numFlowers * (3 + 3 + 2));<br />&nbsp;&nbsp;&nbsp; pointFlower.positionArrayOffset = 0;<br />&nbsp;&nbsp;&nbsp; pointFlower.eulerArrayOffset = pointFlower.numFlowers * 3;<br />&nbsp;&nbsp;&nbsp; pointFlower.miscArrayOffset = pointFlower.numFlowers * 6;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; pointFlower.buffer = gl.createBuffer();<br />&nbsp;&nbsp;&nbsp; gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);<br />&nbsp;&nbsp;&nbsp; gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);<br />&nbsp;&nbsp;&nbsp; gl.bindBuffer(gl.ARRAY_BUFFER, null);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; unuseShader(pointFlower.program);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; for(var i = 0; i &lt; pointFlower.numFlowers; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.particles[i] = new BlossomParticle();<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />function initPointFlowers() {<br />&nbsp;&nbsp;&nbsp; //area<br />&nbsp;&nbsp;&nbsp; pointFlower.area = Vector3.create(20.0, 20.0, 20.0);<br />&nbsp;&nbsp;&nbsp; pointFlower.area.x = pointFlower.area.y * renderSpec.aspect;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; pointFlower.fader.x = 10.0; //env fade start<br />&nbsp;&nbsp;&nbsp; pointFlower.fader.y = pointFlower.area.z; //env fade half<br />&nbsp;&nbsp;&nbsp; pointFlower.fader.z = 0.1;&nbsp; //near fade start<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //particles<br />&nbsp;&nbsp;&nbsp; var PI2 = Math.PI * 2.0;<br />&nbsp;&nbsp;&nbsp; var tmpv3 = Vector3.create(0, 0, 0);<br />&nbsp;&nbsp;&nbsp; var tmpv = 0;<br />&nbsp;&nbsp;&nbsp; var symmetryrand = function() {return (Math.random() * 2.0 - 1.0);};<br />&nbsp;&nbsp;&nbsp; for(var i = 0; i &lt; pointFlower.numFlowers; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var tmpprtcl = pointFlower.particles[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //velocity<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpv3.x = symmetryrand() * 0.3 + 0.8;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpv3.y = symmetryrand() * 0.2 - 1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpv3.z = symmetryrand() * 0.3 + 0.5;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3.normalize(tmpv3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpv = 2.0 + Math.random() * 1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //rotation<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpprtcl.setRotation(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symmetryrand() * PI2 * 0.5,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symmetryrand() * PI2 * 0.5,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symmetryrand() * PI2 * 0.5<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //position<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpprtcl.setPosition(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symmetryrand() * pointFlower.area.x,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symmetryrand() * pointFlower.area.y,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symmetryrand() * pointFlower.area.z<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //euler<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpprtcl.setEulerAngles(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.random() * Math.PI * 2.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.random() * Math.PI * 2.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.random() * Math.PI * 2.0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //size<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpprtcl.setSize(0.9 + Math.random() * 0.1);<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />function renderPointFlowers() {<br />&nbsp;&nbsp;&nbsp; //update<br />&nbsp;&nbsp;&nbsp; var PI2 = Math.PI * 2.0;<br />&nbsp;&nbsp;&nbsp; var limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z];<br />&nbsp;&nbsp;&nbsp; var repeatPos = function (prt, cmp, limit) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Math.abs(prt.position[cmp]) - prt.size * 0.5 &gt; limit) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //out of area<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(prt.position[cmp] &gt; 0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prt.position[cmp] -= limit * 2.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prt.position[cmp] += limit * 2.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; var repeatEuler = function (prt, cmp) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prt.euler[cmp] = prt.euler[cmp] % PI2;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(prt.euler[cmp] &lt; 0.0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prt.euler[cmp] += PI2;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; for(var i = 0; i &lt; pointFlower.numFlowers; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var prtcl = pointFlower.particles[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prtcl.update(timeInfo.delta, timeInfo.elapsed);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repeatPos(prtcl, 0, pointFlower.area.x);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repeatPos(prtcl, 1, pointFlower.area.y);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repeatPos(prtcl, 2, pointFlower.area.z);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repeatEuler(prtcl, 0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repeatEuler(prtcl, 1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repeatEuler(prtcl, 2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prtcl.alpha = 1.0;//(pointFlower.area.z - prtcl.position[2]) * 0.5;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prtcl.zkey = (camera.matrix[2] * prtcl.position[0]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + camera.matrix[6] * prtcl.position[1]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + camera.matrix[10] * prtcl.position[2]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + camera.matrix[14]);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; // sort<br />&nbsp;&nbsp;&nbsp; pointFlower.particles.sort(function(p0, p1){return p0.zkey - p1.zkey;});<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; // update data<br />&nbsp;&nbsp;&nbsp; var ipos = pointFlower.positionArrayOffset;<br />&nbsp;&nbsp;&nbsp; var ieuler = pointFlower.eulerArrayOffset;<br />&nbsp;&nbsp;&nbsp; var imisc = pointFlower.miscArrayOffset;<br />&nbsp;&nbsp;&nbsp; for(var i = 0; i &lt; pointFlower.numFlowers; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var prtcl = pointFlower.particles[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[ipos] = prtcl.position[0];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[ipos + 1] = prtcl.position[1];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[ipos + 2] = prtcl.position[2];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ipos += 3;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[ieuler] = prtcl.euler[0];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[ieuler + 1] = prtcl.euler[1];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[ieuler + 2] = prtcl.euler[2];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ieuler += 3;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[imisc] = prtcl.size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.dataArray[imisc + 1] = prtcl.alpha;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imisc += 2;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //draw<br />&nbsp;&nbsp;&nbsp; gl.enable(gl.BLEND);<br />&nbsp;&nbsp;&nbsp; //gl.disable(gl.DEPTH_TEST);<br />&nbsp;&nbsp;&nbsp; gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; var prog = pointFlower.program;<br />&nbsp;&nbsp;&nbsp; useShader(prog);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix);<br />&nbsp;&nbsp;&nbsp; gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix);<br />&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);<br />&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof));<br />&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader));<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);<br />&nbsp;&nbsp;&nbsp; gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.vertexAttribPointer(prog.attributes.aPosition, 3, gl.FLOAT, false, 0, pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT);<br />&nbsp;&nbsp;&nbsp; gl.vertexAttribPointer(prog.attributes.aEuler, 3, gl.FLOAT, false, 0, pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT);<br />&nbsp;&nbsp;&nbsp; gl.vertexAttribPointer(prog.attributes.aMisc, 2, gl.FLOAT, false, 0, pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; // doubler<br />&nbsp;&nbsp;&nbsp; for(var i = 1; i &lt; 2; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var zpos = i * -2.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[0] = pointFlower.area.x * -1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[1] = pointFlower.area.y * -1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[2] = pointFlower.area.z * zpos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[0] = pointFlower.area.x * -1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[1] = pointFlower.area.y *&nbsp; 1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[2] = pointFlower.area.z * zpos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[0] = pointFlower.area.x *&nbsp; 1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[1] = pointFlower.area.y * -1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[2] = pointFlower.area.z * zpos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[0] = pointFlower.area.x *&nbsp; 1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[1] = pointFlower.area.y *&nbsp; 1.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointFlower.offset[2] = pointFlower.area.z * zpos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //main<br />&nbsp;&nbsp;&nbsp; pointFlower.offset[0] = 0.0;<br />&nbsp;&nbsp;&nbsp; pointFlower.offset[1] = 0.0;<br />&nbsp;&nbsp;&nbsp; pointFlower.offset[2] = 0.0;<br />&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);<br />&nbsp;&nbsp;&nbsp; gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.bindBuffer(gl.ARRAY_BUFFER, null);<br />&nbsp;&nbsp;&nbsp; unuseShader(prog);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.enable(gl.DEPTH_TEST);<br />&nbsp;&nbsp;&nbsp; gl.disable(gl.BLEND);<br />}<br /><br />// effects<br />//common util<br />function createEffectProgram(vtxsrc, frgsrc, exunifs, exattrs) {<br />&nbsp;&nbsp;&nbsp; var ret = {};<br />&nbsp;&nbsp;&nbsp; var unifs = ['uResolution', 'uSrc', 'uDelta'];<br />&nbsp;&nbsp;&nbsp; if(exunifs) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unifs = unifs.concat(exunifs);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; var attrs = ['aPosition'];<br />&nbsp;&nbsp;&nbsp; if(exattrs) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs = attrs.concat(exattrs);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; ret.program = createShader(vtxsrc, frgsrc, unifs, attrs);<br />&nbsp;&nbsp;&nbsp; useShader(ret.program);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; ret.dataArray = new Float32Array([<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1.0, -1.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0, -1.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1.0,&nbsp; 1.0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0,&nbsp; 1.0<br />&nbsp;&nbsp;&nbsp; ]);<br />&nbsp;&nbsp;&nbsp; ret.buffer = gl.createBuffer();<br />&nbsp;&nbsp;&nbsp; gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer);<br />&nbsp;&nbsp;&nbsp; gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.bindBuffer(gl.ARRAY_BUFFER, null);<br />&nbsp;&nbsp;&nbsp; unuseShader(ret.program);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; return ret;<br />}<br /><br />// basic usage<br />// useEffect(prog, srctex({'texture':texid, 'dtxArray':(f32)[dtx, dty]})); //basic initialize<br />// gl.uniform**(...); //additional uniforms<br />// drawEffect()<br />// unuseEffect(prog)<br />// TEXTURE0 makes src<br />function useEffect(fxobj, srctex) {<br />&nbsp;&nbsp;&nbsp; var prog = fxobj.program;<br />&nbsp;&nbsp;&nbsp; useShader(prog);<br />&nbsp;&nbsp;&nbsp; gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; if(srctex != null) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform1i(prog.uniforms.uSrc, 0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.activeTexture(gl.TEXTURE0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.bindTexture(gl.TEXTURE_2D, srctex.texture);<br />&nbsp;&nbsp;&nbsp; }<br />}<br />function drawEffect(fxobj) {<br />&nbsp;&nbsp;&nbsp; gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer);<br />&nbsp;&nbsp;&nbsp; gl.vertexAttribPointer(fxobj.program.attributes.aPosition, 2, gl.FLOAT, false, 0, 0);<br />&nbsp;&nbsp;&nbsp; gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);<br />}<br />function unuseEffect(fxobj) {<br />&nbsp;&nbsp;&nbsp; unuseShader(fxobj.program);<br />}<br /><br />var effectLib = {};<br />function createEffectLib() {<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; var vtxsrc, frgsrc;<br />&nbsp;&nbsp;&nbsp; //common<br />&nbsp;&nbsp;&nbsp; var cmnvtxsrc = document.getElementById("fx_common_vsh").textContent;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //background<br />&nbsp;&nbsp;&nbsp; frgsrc = document.getElementById("bg_fsh").textContent;<br />&nbsp;&nbsp;&nbsp; effectLib.sceneBg = createEffectProgram(cmnvtxsrc, frgsrc, ['uTimes'], null);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; // make brightpixels buffer<br />&nbsp;&nbsp;&nbsp; frgsrc = document.getElementById("fx_brightbuf_fsh").textContent;<br />&nbsp;&nbsp;&nbsp; effectLib.mkBrightBuf = createEffectProgram(cmnvtxsrc, frgsrc, null, null);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; // direction blur<br />&nbsp;&nbsp;&nbsp; frgsrc = document.getElementById("fx_dirblur_r4_fsh").textContent;<br />&nbsp;&nbsp;&nbsp; effectLib.dirBlur = createEffectProgram(cmnvtxsrc, frgsrc, ['uBlurDir'], null);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //final composite<br />&nbsp;&nbsp;&nbsp; vtxsrc = document.getElementById("pp_final_vsh").textContent;<br />&nbsp;&nbsp;&nbsp; frgsrc = document.getElementById("pp_final_fsh").textContent;<br />&nbsp;&nbsp;&nbsp; effectLib.finalComp = createEffectProgram(vtxsrc, frgsrc, ['uBloom'], null);<br />}<br /><br />// background<br />function createBackground() {<br />&nbsp;&nbsp;&nbsp; //console.log("create background");<br />}<br />function initBackground() {<br />&nbsp;&nbsp;&nbsp; //console.log("init background");<br />}<br />function renderBackground() {<br />&nbsp;&nbsp;&nbsp; gl.disable(gl.DEPTH_TEST);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; useEffect(effectLib.sceneBg, null);<br />&nbsp;&nbsp;&nbsp; gl.uniform2f(effectLib.sceneBg.program.uniforms.uTimes, timeInfo.elapsed, timeInfo.delta);<br />&nbsp;&nbsp;&nbsp; drawEffect(effectLib.sceneBg);<br />&nbsp;&nbsp;&nbsp; unuseEffect(effectLib.sceneBg);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.enable(gl.DEPTH_TEST);<br />}<br /><br />// post process<br />var postProcess = {};<br />function createPostProcess() {<br />&nbsp;&nbsp;&nbsp; //console.log("create post process");<br />}<br />function initPostProcess() {<br />&nbsp;&nbsp;&nbsp; //console.log("init post process");<br />}<br /><br />function renderPostProcess() {<br />&nbsp;&nbsp;&nbsp; gl.enable(gl.TEXTURE_2D);<br />&nbsp;&nbsp;&nbsp; gl.disable(gl.DEPTH_TEST);<br />&nbsp;&nbsp;&nbsp; var bindRT = function (rt, isclear) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.viewport(0, 0, rt.width, rt.height);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(isclear) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.clearColor(0, 0, 0, 0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //make bright buff<br />&nbsp;&nbsp;&nbsp; bindRT(renderSpec.wHalfRT0, true);<br />&nbsp;&nbsp;&nbsp; useEffect(effectLib.mkBrightBuf, renderSpec.mainRT);<br />&nbsp;&nbsp;&nbsp; drawEffect(effectLib.mkBrightBuf);<br />&nbsp;&nbsp;&nbsp; unuseEffect(effectLib.mkBrightBuf);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; // make bloom<br />&nbsp;&nbsp;&nbsp; for(var i = 0; i &lt; 2; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var p = 1.5 + 1 * i;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var s = 2.0 + 1 * i;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bindRT(renderSpec.wHalfRT1, true);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; useEffect(effectLib.dirBlur, renderSpec.wHalfRT0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, p, 0.0, s, 0.0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawEffect(effectLib.dirBlur);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unuseEffect(effectLib.dirBlur);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bindRT(renderSpec.wHalfRT0, true);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; useEffect(effectLib.dirBlur, renderSpec.wHalfRT1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, 0.0, p, 0.0, s);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawEffect(effectLib.dirBlur);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unuseEffect(effectLib.dirBlur);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //display<br />&nbsp;&nbsp;&nbsp; gl.bindFramebuffer(gl.FRAMEBUFFER, null);<br />&nbsp;&nbsp;&nbsp; gl.viewport(0, 0, renderSpec.width, renderSpec.height);<br />&nbsp;&nbsp;&nbsp; gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; useEffect(effectLib.finalComp, renderSpec.mainRT);<br />&nbsp;&nbsp;&nbsp; gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1);<br />&nbsp;&nbsp;&nbsp; gl.activeTexture(gl.TEXTURE1);<br />&nbsp;&nbsp;&nbsp; gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture);<br />&nbsp;&nbsp;&nbsp; drawEffect(effectLib.finalComp);<br />&nbsp;&nbsp;&nbsp; unuseEffect(effectLib.finalComp);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.enable(gl.DEPTH_TEST);<br />}<br /><br />/////<br />var SceneEnv = {};<br />function createScene() {<br />&nbsp;&nbsp;&nbsp; createEffectLib();<br />&nbsp;&nbsp;&nbsp; createBackground();<br />&nbsp;&nbsp;&nbsp; createPointFlowers();<br />&nbsp;&nbsp;&nbsp; createPostProcess();<br />&nbsp;&nbsp;&nbsp; sceneStandBy = true;<br />}<br /><br />function initScene() {<br />&nbsp;&nbsp;&nbsp; initBackground();<br />&nbsp;&nbsp;&nbsp; initPointFlowers();<br />&nbsp;&nbsp;&nbsp; initPostProcess();<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //camera.position.z = 17.320508;<br />&nbsp;&nbsp;&nbsp; camera.position.z = pointFlower.area.z + projection.nearfar[0];<br />&nbsp;&nbsp;&nbsp; projection.angle = Math.atan2(pointFlower.area.y, camera.position.z + pointFlower.area.z) * 180.0 / Math.PI * 2.0;<br />&nbsp;&nbsp;&nbsp; Matrix44.loadProjection(projection.matrix, renderSpec.aspect, projection.angle, projection.nearfar[0], projection.nearfar[1]);<br />}<br /><br />function renderScene() {<br />&nbsp;&nbsp;&nbsp; //draw<br />&nbsp;&nbsp;&nbsp; Matrix44.loadLookAt(camera.matrix, camera.position, camera.lookat, camera.up);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.enable(gl.DEPTH_TEST);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; //gl.bindFramebuffer(gl.FRAMEBUFFER, null);<br />&nbsp;&nbsp;&nbsp; gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer);<br />&nbsp;&nbsp;&nbsp; gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height);<br />&nbsp;&nbsp;&nbsp; gl.clearColor(0.005, 0, 0.05, 0);<br />&nbsp;&nbsp;&nbsp; gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; renderBackground();<br />&nbsp;&nbsp;&nbsp; renderPointFlowers();<br />&nbsp;&nbsp;&nbsp; renderPostProcess();<br />}<br /><br />/////<br />function onResize(e) {<br />&nbsp;&nbsp;&nbsp; makeCanvasFullScreen(document.getElementById("sakura"));<br />&nbsp;&nbsp;&nbsp; setViewports();<br />&nbsp;&nbsp;&nbsp; if(sceneStandBy) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initScene();<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />function setViewports() {<br />&nbsp;&nbsp;&nbsp; renderSpec.setSize(gl.canvas.width, gl.canvas.height);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; gl.clearColor(0.2, 0.2, 0.5, 1.0);<br />&nbsp;&nbsp;&nbsp; gl.viewport(0, 0, renderSpec.width, renderSpec.height);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; var rtfunc = function (rtname, rtw, rth) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var rt = renderSpec[rtname];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(rt) deleteRenderTarget(rt);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; renderSpec[rtname] = createRenderTarget(rtw, rth);<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; rtfunc('mainRT', renderSpec.width, renderSpec.height);<br />&nbsp;&nbsp;&nbsp; rtfunc('wFullRT0', renderSpec.width, renderSpec.height);<br />&nbsp;&nbsp;&nbsp; rtfunc('wFullRT1', renderSpec.width, renderSpec.height);<br />&nbsp;&nbsp;&nbsp; rtfunc('wHalfRT0', renderSpec.halfWidth, renderSpec.halfHeight);<br />&nbsp;&nbsp;&nbsp; rtfunc('wHalfRT1', renderSpec.halfWidth, renderSpec.halfHeight);<br />}<br /><br />function render() {<br />&nbsp;&nbsp;&nbsp; renderScene();<br />}<br /><br />var animating = true;<br />function toggleAnimation(elm) {<br />&nbsp;&nbsp;&nbsp; animating ^= true;<br />&nbsp;&nbsp;&nbsp; if(animating) animate();<br />&nbsp;&nbsp;&nbsp; if(elm) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elm.innerHTML = animating? "Stop":"Start";<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />function stepAnimation() {<br />&nbsp;&nbsp;&nbsp; if(!animating) animate();<br />}<br /><br />function animate() {<br />&nbsp;&nbsp;&nbsp; var curdate = new Date();<br />&nbsp;&nbsp;&nbsp; timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0;<br />&nbsp;&nbsp;&nbsp; timeInfo.delta = (curdate - timeInfo.prev) / 1000.0;<br />&nbsp;&nbsp;&nbsp; timeInfo.prev = curdate;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; if(animating) requestAnimationFrame(animate);<br />&nbsp;&nbsp;&nbsp; render();<br />}<br /><br />function makeCanvasFullScreen(canvas) {<br />&nbsp;&nbsp;&nbsp; var b = document.body;<br />&nbsp;&nbsp; &nbsp;var d = document.documentElement;<br />&nbsp;&nbsp; &nbsp;fullw = Math.max(b.clientWidth , b.scrollWidth, d.scrollWidth, d.clientWidth);<br />&nbsp;&nbsp; &nbsp;fullh = Math.max(b.clientHeight , b.scrollHeight, d.scrollHeight, d.clientHeight);<br />&nbsp;&nbsp; &nbsp;canvas.width = fullw;<br />&nbsp;&nbsp; &nbsp;canvas.height = fullh;<br />}<br /><br />window.addEventListener('load', function(e) {<br />&nbsp;&nbsp;&nbsp; var canvas = document.getElementById("sakura");<br />&nbsp;&nbsp;&nbsp; try {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeCanvasFullScreen(canvas);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gl = canvas.getContext('experimental-webgl');<br />&nbsp;&nbsp;&nbsp; } catch(e) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("WebGL not supported." + e);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.error(e);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; window.addEventListener('resize', onResize);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; setViewports();<br />&nbsp;&nbsp;&nbsp; createScene();<br />&nbsp;&nbsp;&nbsp; initScene();<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; timeInfo.start = new Date();<br />&nbsp;&nbsp;&nbsp; timeInfo.prev = timeInfo.start;<br />&nbsp;&nbsp;&nbsp; animate();<br />});<br /><br />//set window.requestAnimationFrame<br />(function (w, r) {<br />&nbsp;&nbsp;&nbsp; w['r'+r] = w['r'+r] || w['webkitR'+r] || w['mozR'+r] || w['msR'+r] || w['oR'+r] || function(c){ w.setTimeout(c, 1000 / 60); };<br />})(window, 'equestAnimationFrame'); &nbsp;<br />&nbsp; <br />&nbsp; &lt;/script&gt;<br />&nbsp; <br /><br />&lt;/body&gt;&lt;/html&gt;</p>
<h1>粒子效果</h1>
<p>1、简介</p>
<p>Canvas-nest.js是一个非常好看的网页粒子背景插件，不需要依赖任何第三方库即可运行，提供额非常炫酷的背景。</p>
<p>&nbsp;</p>
<p>2、特点</p>
<p>不依赖于任何框架或者库，使用原生js编写。轻量级，只有不到2kb（50行代码左右）。使用起来非常简单，直接在html页面引入即可。</p>
<p>&nbsp;</p>
<p>3、使用方法</p>
<p>直接把下面这段代码粘贴到HTML的body标签中即可</p>
<p><code>&lt;</code><code>script</code><code>type</code><code>=</code><code>"text/javascript"</code><code>src</code><code>=</code><code>"canvas-nest.js"</code><code>&gt;&lt;/</code><code>script</code><code>&gt;</code></p>
<p>注：不要把上面代码放到head标签之类，否则不会生效。</p>
<p>&nbsp;</p>
<p>4、自定义外观</p>
<p>在script中加入相应的参数，自定义参数值即可，如下：</p>
<p><code>&lt;</code><code>script</code><code>type</code><code>=</code><code>"text/javascript"</code><code>color</code><code>=</code><code>"255,0,0"</code><code>opacity</code><code>=</code><code>"0.5"</code><code>count</code><code>=</code><code>"99"</code><code>src<code>=</code><code>"canvas-nest.js"</code><code>&gt;&lt;/</code></code><code>script</code><code>&gt;</code></p>
<p>&nbsp;</p>
<p>参数说明：</p>
<p><code>color="255,0,0"</code>&nbsp;&nbsp;&nbsp; 背景粒子线的颜色</p>
<p><code>opacity</code><code>=</code><code>"0.5"&nbsp;&nbsp;&nbsp;&nbsp;背景粒子线的透明度，一般设置成0.5-1之间</code></p>
<p><code>count</code><code>=</code><code>"99"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;背景粒子线的密度，建议不要太大，否则页面容易卡死</code></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>另附官网地址：<a href="http://www.atool.org/" rel="nofollow">http://www.atool.org/</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;canvas-nest.js源码如下：</p>
<p>&nbsp;</p>
<p>&nbsp;/**<br />&nbsp;* Copyright (c) 2016 hustcc<br />&nbsp;* License: MIT<br />&nbsp;* Version: v1.0.1<br />&nbsp;* GitHub:&nbsp;<a href="https://github.com/hustcc/canvas-nest.js" rel="nofollow">https://github.com/hustcc/canvas-nest.js</a><br />**/<br />!function(){function n(n,e,t){return n.getAttribute(e)||t}function e(n){return document.getElementsByTagName(n)}function t(){var t=e("script"),o=t.length,i=t[o-1];return{l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)}}function o(){a=m.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,c=m.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function i(){r.clearRect(0,0,a,c);var n,e,t,o,m,l;s.forEach(function(i,x){for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;a||i.x&lt;0?-1:1,i.ya*=i.y&gt;c||i.y&lt;0?-1:1,r.fillRect(i.x-.5,i.y-.5,1,1),e=x+1;e&lt;u.length;e++)n=u[e],null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,m=i.y-n.y,l=o*o+m*m,l&lt;n.max&amp;&amp;(n===y&amp;&amp;l&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*m),t=(n.max-l)/n.max,r.beginPath(),r.lineWidth=t/2,r.strokeStyle="rgba("+d.c+","+(t+.2)+")",r.moveTo(i.x,i.y),r.lineTo(n.x,n.y),r.stroke()))}),x(i)}var a,c,u,m=document.createElement("canvas"),d=t(),l="c_n"+d.l,r=m.getContext("2d"),x=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n){window.setTimeout(n,1e3/45)},w=Math.random,y={x:null,y:null,max:2e4};m.id=l,m.style.cssText="position:fixed;top:0;left:0;z-index:"+d.z+";opacity:"+d.o,e("body")[0].appendChild(m),o(),window.&omicron;nresize=o,window.&omicron;nm&omicron;usem&omicron;ve=function(n){n=n||window.event,y.x=n.clientX,y.y=n.clientY},window.&omicron;nm&omicron;use&omicron;ut=function(){y.x=null,y.y=null};for(var s=[],f=0;d.n&gt;f;f++){var h=w()*a,g=w()*c,v=2*w()-1,p=2*w()-1;s.push({x:h,y:g,xa:v,ya:p,max:6e3})}u=s.concat([y]),setTimeout(function(){i()},100)}();</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>