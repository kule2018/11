<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修这一次，彻底弄懂 Promise 原理' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>这一次，彻底弄懂 Promise 原理</center></div><div class='banquan'>原文出处:本文由博客园博主小蚊提供。<br/>
原文连接:https://www.cnblogs.com/LuckyWinty/p/11490662.html</div><br>
    <div>
<p><span style="color: #ff0000; font-size: 18px;"><strong>作者声明</strong></span></p>
<p><strong>本人将迁移至个人公众号「前端Q」及「掘金」平台写文章。欢迎大家关注公众号「前端Q」及<a href="https://juejin.im/user/5874526761ff4b006d4fd9a4/posts">我的掘金主页</a>：<a href="https://juejin.im/user/5874526761ff4b006d4fd9a4/posts">https://juejin.im/user/5874526761ff4b006d4fd9a4/posts</a></strong></p>
<p><img src="./images/这一次，彻底弄懂 Promise 原理0.png" alt="" width="651" height="186" /></p>
<p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。</p>
<p>基本过程：</p>
<ol>
<li>初始化 Promise 状态（pending）</li>
<li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li>
<li>立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li>
<li>Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li>
</ol>
<p><strong>真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.</strong></p>
<h3 class="heading" data-id="heading-0">链式调用</h3>
<p>先从 Promise 执行结果看一下，有如下一段代码：</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">new</span> Promise((resolve, reject) =&gt;<span style="color: #000000;"> {
        setTimeout(() </span>=&gt;<span style="color: #000000;"> {
            resolve({ test: </span>1<span style="color: #000000;"> })
            resolve({ test: </span>2<span style="color: #000000;"> })
            reject({ test: </span>2<span style="color: #000000;"> })
        }, </span>1000<span style="color: #000000;">)
    }).then((data) </span>=&gt;<span style="color: #000000;"> {
        console.log(</span>'result1'<span style="color: #000000;">, data)
    },(data1)</span>=&gt;<span style="color: #000000;">{
        console.log(</span>'result2'<span style="color: #000000;">,data1)
    }).then((data) </span>=&gt;<span style="color: #000000;"> {
        console.log(</span>'result3'<span style="color: #000000;">, data)
    })
    </span><span style="color: #008000;">//</span><span style="color: #008000;">result1 { test: 1 }</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">result3 undefined</span></pre>
</div>
<p>显然这里输出了不同的 data。由此可以看出几点：</p>
<ol>
<li>可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。</li>
<li>只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。</li>
<li>then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。</li>
</ol>
<p>基于以上几点，我们先写个基于 <a href="https://link.juejin.im?target=https%3A%2F%2Fpromisesaplus.com%2F" rel="nofollow noopener noreferrer" target="_blank">PromiseA+</a> 规范的只含 resolve 方法的 Promise 模型:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        let state </span>= 'pending'<span style="color: #000000;">;
        let value </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        const callbacks </span>=<span style="color: #000000;"> [];

        </span><span style="color: #0000ff;">this</span>.then = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onFulfilled){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve, reject)=&gt;<span style="color: #000000;">{
                handle({ </span><span style="color: #008000;">//</span><span style="color: #008000;">桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中</span>
<span style="color: #000000;">                    onFulfilled, 
                    resolve
                })
            })
        }

        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> handle(callback){
            </span><span style="color: #0000ff;">if</span>(state === 'pending'<span style="color: #000000;">){
                callbacks.push(callback)
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            
            </span><span style="color: #0000ff;">if</span>(state === 'fulfilled'<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">callback.onFulfilled){
                    callback.resolve(value)
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }
                const ret </span>= callback.onFulfilled(value) <span style="color: #008000;">//</span><span style="color: #008000;">处理回调</span>
                callback.resolve(ret) <span style="color: #008000;">//</span><span style="color: #008000;">处理下一个 promise 的resolve</span>
<span style="color: #000000;">            }
        }
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> resolve(newValue){
            const fn </span>= ()=&gt;<span style="color: #000000;">{
                </span><span style="color: #0000ff;">if</span>(state !== 'pending')<span style="color: #0000ff;">return</span><span style="color: #000000;">

                state </span>= 'fulfilled'<span style="color: #000000;">;
                value </span>=<span style="color: #000000;"> newValue
                handelCb()
            }
            
            setTimeout(fn,</span>0) <span style="color: #008000;">//</span><span style="color: #008000;">基于 PromiseA+ 规范</span>
<span style="color: #000000;">        }
        
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> handelCb(){
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(callbacks.length) {
                const fulfiledFn </span>=<span style="color: #000000;"> callbacks.shift();
                handle(fulfiledFn);
            };
        }
        
        fn(resolve)
    }</span></pre>
</div>
<p><strong>这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去...链式调用的效应就出来了。</strong></p>
<p>但是如果仅仅是例子中的情况，我们可以这样写：</p>
<div class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">new</span> Promise((resolve, reject) =&gt;<span style="color: #000000;"> {
        setTimeout(() </span>=&gt;<span style="color: #000000;"> {
            resolve({ test: </span>1<span style="color: #000000;"> })
        }, </span>1000<span style="color: #000000;">)
    }).then((data) </span>=&gt;<span style="color: #000000;"> {
        console.log(</span>'result1'<span style="color: #000000;">, data)
        </span><span style="color: #008000;">//</span><span style="color: #008000;">dosomething</span>
        console.log('result3'<span style="color: #000000;">)
    })
    </span><span style="color: #008000;">//</span><span style="color: #008000;">result1 { test: 1 }</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">result3</span></pre>
</div>
<p>实际上，我们常用的链式调用，是用在异步回调中，以解决"回调地狱"的问题。如下例子：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">new</span> Promise((resolve, reject) =&gt;<span style="color: #000000;"> {
  setTimeout(() </span>=&gt;<span style="color: #000000;"> {
    resolve({ test: </span>1<span style="color: #000000;"> })
  }, </span>1000<span style="color: #000000;">)
}).then((data) </span>=&gt;<span style="color: #000000;"> {
  console.log(</span>'result1'<span style="color: #000000;">, data)
  </span><span style="color: #008000;">//</span><span style="color: #008000;">dosomething</span>
  <span style="color: #0000ff;">return</span><span style="color: #000000;"> test()
}).then((data) </span>=&gt;<span style="color: #000000;"> {
  console.log(</span>'result2'<span style="color: #000000;">, data)
})

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> test(id) {
  </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(((resolve) =&gt;<span style="color: #000000;"> {
    setTimeout(() </span>=&gt;<span style="color: #000000;"> {
      resolve({ test: </span>2<span style="color: #000000;"> })
    }, </span>5000<span style="color: #000000;">)
  }))
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">基于第一个 Promise 模型，执行后的输出</span><span style="color: #008000;">
//</span><span style="color: #008000;">result1 { test: 1 }</span><span style="color: #008000;">
//</span><span style="color: #008000;">result2 Promise {then: &fnof;}</span></pre>
</div>
<p>用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下:</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        ...
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> resolve(newValue){
            const fn </span>= ()=&gt;<span style="color: #000000;">{
                </span><span style="color: #0000ff;">if</span>(state !== 'pending')<span style="color: #0000ff;">return</span>

                <span style="color: #0000ff;">if</span>(newValue &amp;&amp; (<span style="color: #0000ff;">typeof</span> newValue === 'object' || <span style="color: #0000ff;">typeof</span> newValue === 'function'<span style="color: #000000;">)){
                    const {then} </span>=<span style="color: #000000;"> newValue
                    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> then === 'function'<span style="color: #000000;">){
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span>
<span style="color: #000000;">                        then.call(newValue,resolve)
                        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
                    }
                }
                state </span>= 'fulfilled'<span style="color: #000000;">;
                value </span>=<span style="color: #000000;"> newValue
                handelCb()
            }
            
            setTimeout(fn,</span>0<span style="color: #000000;">)
        }
        ...
    }</span></pre>
</div>
<p>用这个模型，再测试我们的例子，就得到了正确的结果：</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">new</span> Promise((resolve, reject) =&gt;<span style="color: #000000;"> {
        setTimeout(() </span>=&gt;<span style="color: #000000;"> {
            resolve({ test: </span>1<span style="color: #000000;"> })
        }, </span>1000<span style="color: #000000;">)
    }).then((data) </span>=&gt;<span style="color: #000000;"> {
        console.log(</span>'result1'<span style="color: #000000;">, data)
        </span><span style="color: #008000;">//</span><span style="color: #008000;">dosomething</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> test()
    }).then((data) </span>=&gt;<span style="color: #000000;"> {
        console.log(</span>'result2'<span style="color: #000000;">, data)
    })

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> test(id) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(((resolve, reject) =&gt;<span style="color: #000000;"> {
            setTimeout(() </span>=&gt;<span style="color: #000000;"> {
            resolve({ test: </span>2<span style="color: #000000;"> })
            }, </span>5000<span style="color: #000000;">)
        }))
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">result1 { test: 1 }</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">result2 { test: 2 }</span></pre>
</div>
<p>显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。</p>
<p>显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。</p>
<p>我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。</p>
<p>基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表：</p>
<table>
<thead>
<tr><th>Promise</th><th>callback</th></tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>[{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}]</td>
</tr>
<tr>
<td>P2 (P1 调用 then 时产生)</td>
<td>[{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}]</td>
</tr>
<tr>
<td>P3 (P2 调用 then 时产生)</td>
<td>[]</td>
</tr>
<tr>
<td>P4 (执行c1中产生[调用 test ])</td>
<td>[{onFulfilled:p2resolve,resolve:p5resolve}]</td>
</tr>
<tr>
<td>P5 (调用p2resolve 时，进入 then.call 逻辑中产生)</td>
<td>[]</td>
</tr>
</tbody>
</table>
<p>有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是：</p>
<p>c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; []</p>
<p>以上就是链式调用的原理了。</p>
<h3 class="heading" data-id="heading-1">reject</h3>
<p>下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。</p>
<p>完整代码如下:</p>
<div class="cnblogs_code">
<pre><code>   <span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        let state </span>= 'pending'<span style="color: #000000;">;
        let value </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        const callbacks </span>=<span style="color: #000000;"> [];

        </span><span style="color: #0000ff;">this</span>.then = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onFulfilled,onRejected){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve, reject)=&gt;<span style="color: #000000;">{
                handle({
                    onFulfilled, 
                    onRejected,
                    resolve, 
                    reject
                })
            })
        }

        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> handle(callback){
            </span><span style="color: #0000ff;">if</span>(state === 'pending'<span style="color: #000000;">){
                callbacks.push(callback)
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            
            const cb </span>= state === 'fulfilled' ?<span style="color: #000000;"> callback.onFulfilled:callback.onRejected;
            const next </span>= state === 'fulfilled'?<span style="color: #000000;"> callback.resolve:callback.reject;

            </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">cb){
                next(value)
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            const ret </span>=<span style="color: #000000;"> cb(value)
            next(ret)
        }
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> resolve(newValue){
            const fn </span>= ()=&gt;<span style="color: #000000;">{
                </span><span style="color: #0000ff;">if</span>(state !== 'pending')<span style="color: #0000ff;">return</span>

                <span style="color: #0000ff;">if</span>(newValue &amp;&amp; (<span style="color: #0000ff;">typeof</span> newValue === 'object' || <span style="color: #0000ff;">typeof</span> newValue === 'function'<span style="color: #000000;">)){
                    const {then} </span>=<span style="color: #000000;"> newValue
                    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> then === 'function'<span style="color: #000000;">){
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span>
<span style="color: #000000;">                        then.call(newValue,resolve, reject)
                        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
                    }
                }
                state </span>= 'fulfilled'<span style="color: #000000;">;
                value </span>=<span style="color: #000000;"> newValue
                handelCb()
            }
            
            setTimeout(fn,</span>0<span style="color: #000000;">)
        }
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> reject(error){

            const fn </span>= ()=&gt;<span style="color: #000000;">{
                </span><span style="color: #0000ff;">if</span>(state !== 'pending')<span style="color: #0000ff;">return</span>

                <span style="color: #0000ff;">if</span>(error &amp;&amp; (<span style="color: #0000ff;">typeof</span> error === 'object' || <span style="color: #0000ff;">typeof</span> error === 'function'<span style="color: #000000;">)){
                    const {then} </span>=<span style="color: #000000;"> error
                    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> then === 'function'<span style="color: #000000;">){
                        then.call(error,resolve, reject)
                        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
                    }
                }
                state </span>= 'rejected'<span style="color: #000000;">;
                value </span>=<span style="color: #000000;"> error
                handelCb()
            }
            setTimeout(fn,</span>0<span style="color: #000000;">)
        }
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> handelCb(){
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(callbacks.length) {
                const fn </span>=<span style="color: #000000;"> callbacks.shift();
                handle(fn);
            };
        }
        fn(resolve, reject)
    }</span></pre>
</div>
<h3 class="heading" data-id="heading-2">异常处理</h3>
<p>异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。</p>
<p>handle代码改造如下：</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">function</span><span style="color: #000000;"> handle(callback){
        </span><span style="color: #0000ff;">if</span>(state === 'pending'<span style="color: #000000;">){
            callbacks.push(callback)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        
        const cb </span>= state === 'fulfilled' ?<span style="color: #000000;"> callback.onFulfilled:callback.onRejected;
        const next </span>= state === 'fulfilled'?<span style="color: #000000;"> callback.resolve:callback.reject;

        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">cb){
            next(value)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            const ret </span>=<span style="color: #000000;"> cb(value)
            next(ret)
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (e) {
            callback.reject(e);
        }  
    }</span></pre>
</div>
<p>我们实际使用时，常习惯注册 catch 方法来处理错误，例：</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">new</span> Promise((resolve, reject) =&gt;<span style="color: #000000;"> {
        setTimeout(() </span>=&gt;<span style="color: #000000;"> {
            resolve({ test: </span>1<span style="color: #000000;"> })
        }, </span>1000<span style="color: #000000;">)
    }).then((data) </span>=&gt;<span style="color: #000000;"> {
        console.log(</span>'result1'<span style="color: #000000;">, data)
        </span><span style="color: #008000;">//</span><span style="color: #008000;">dosomething</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> test()
    }).</span><span style="color: #0000ff;">catch</span>((ex) =&gt;<span style="color: #000000;"> {
        console.log(</span>'error'<span style="color: #000000;">, ex)
    })</span></pre>
</div>
<p>实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法：</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        ...
        </span><span style="color: #0000ff;">this</span>.then = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onFulfilled,onRejected){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve, reject)=&gt;<span style="color: #000000;">{
                handle({
                    onFulfilled, 
                    onRejected,
                    resolve, 
                    reject
                })
            })
        }
        </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">catch</span> = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onError){
            </span><span style="color: #0000ff;">this</span>.then(<span style="color: #0000ff;">null</span><span style="color: #000000;">,onError)
        }
        ...
    }</span></pre>
</div>
<h3 class="heading" data-id="heading-3">Finally方法</h3>
<p>在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        ...
        </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">catch</span> = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onError){
            </span><span style="color: #0000ff;">this</span>.then(<span style="color: #0000ff;">null</span><span style="color: #000000;">,onError)
        }
        </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">finally</span> = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onDone){
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.then(onDone,onError)
        }
        ...
    }</span></pre>
</div>
<h3 class="heading" data-id="heading-4">resolve 方法和 reject 方法</h3>
<p>实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子：</p>
<div class="cnblogs_code">
<pre><code>Promise.resolve({name:'winty'<span style="color: #000000;">})
Promise.reject({name:</span>'winty'<span style="color: #000000;">})
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 等价于</span>
<span style="color: #0000ff;">new</span> Promise(resolve =&gt; resolve({name:'winty'<span style="color: #000000;">}))
</span><span style="color: #0000ff;">new</span> Promise((resolve,reject) =&gt; reject({name:'winty'}))</pre>
</div>
<p>这些情况下，Promise.resolve 的入参可能有以下几种情况：</p>
<ul>
<li>无参数 [直接返回一个resolved状态的 Promise 对象]</li>
<li>普通数据对象 [直接返回一个resolved状态的 Promise 对象]</li>
<li>一个Promise实例 [直接返回当前实例]</li>
<li>一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。]</li>
</ul>
<p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p>
<div class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        ...
        </span><span style="color: #0000ff;">this</span>.resolve = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (value){
            </span><span style="color: #0000ff;">if</span> (value &amp;&amp; value <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Promise) {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> value;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (value &amp;&amp; <span style="color: #0000ff;">typeof</span> value === 'object' &amp;&amp; <span style="color: #0000ff;">typeof</span> value.then === 'function'<span style="color: #000000;">){
                let then </span>=<span style="color: #000000;"> value.then;
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(resolve =&gt;<span style="color: #000000;"> {
                    then(resolve);
                });
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (value) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(resolve =&gt;<span style="color: #000000;"> resolve(value));
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(resolve =&gt;<span style="color: #000000;"> resolve());
            }
        }
        ...
    }</span></pre>
</div>
<p>Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        ...
        </span><span style="color: #0000ff;">this</span>.reject = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (value){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(<span style="color: #0000ff;">function</span><span style="color: #000000;">(resolve, reject) {
                reject(value);
            });
        }
        ...
    }</span></pre>
</div>
<h3 class="heading" data-id="heading-5">Promise.all</h3>
<p>入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
        ...
        </span><span style="color: #0000ff;">this</span>.all = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (arr){
            </span><span style="color: #0000ff;">var</span> args =<span style="color: #000000;"> Array.prototype.slice.call(arr);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(<span style="color: #0000ff;">function</span><span style="color: #000000;">(resolve, reject) {
                </span><span style="color: #0000ff;">if</span>(args.length === 0) <span style="color: #0000ff;">return</span><span style="color: #000000;"> resolve([]);
                </span><span style="color: #0000ff;">var</span> remaining =<span style="color: #000000;"> args.length;

                </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> res(i, val) {
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">if</span>(val &amp;&amp; (<span style="color: #0000ff;">typeof</span> val === 'object' || <span style="color: #0000ff;">typeof</span> val === 'function'<span style="color: #000000;">)) {
                            </span><span style="color: #0000ff;">var</span> then =<span style="color: #000000;"> val.then;
                            </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> then === 'function'<span style="color: #000000;">) {
                                then.call(val, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(val) {
                                    res(i, val);
                                }, reject);
                                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                            }
                        }
                        args[i] </span>=<span style="color: #000000;"> val;
                        </span><span style="color: #0000ff;">if</span>(--remaining === 0<span style="color: #000000;">) {
                            resolve(args);
                        }
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(ex) {
                        reject(ex);
                    }
                }
                </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i = 0; i &lt; args.length; i++<span style="color: #000000;">) {
                    res(i, args[i]);
                }
            });
        }
        ...
    }</span></pre>
</div>
<h3 class="heading" data-id="heading-6">Promise.race</h3>
<p>有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn){ 
    ...
    </span><span style="color: #0000ff;">this</span>.race = <span style="color: #0000ff;">function</span><span style="color: #000000;">(values) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(<span style="color: #0000ff;">function</span><span style="color: #000000;">(resolve, reject) {
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i = 0, len = values.length; i &lt; len; i++<span style="color: #000000;">) {
                values[i].then(resolve, reject);
            }
        });
    }
    ...
    }  </span></pre>
</div>
<h3 class="heading" data-id="heading-7">总结</h3>
<p>Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。</p>
<h3 class="heading" data-id="heading-8">参考资料</h3>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fpromisesaplus.com%2F" rel="nofollow noopener noreferrer" target="_blank">PromiseA+规范</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F58428287" rel="nofollow noopener noreferrer" target="_blank">Promise 实现原理精解</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fmengera88.github.io%2F2017%2F05%2F18%2FPromise%25E5%258E%259F%25E7%2590%2586%25E8%25A7%25A3%25E6%259E%2590%2F" rel="nofollow noopener noreferrer" target="_blank">30分钟，让你彻底明白Promise原理</a></li>
</ul>
<h3 class="heading" data-id="heading-9">完整 Promise 模型</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Promise(fn) {
  let state </span>= 'pending'<span style="color: #000000;">
  let value </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">
  const callbacks </span>=<span style="color: #000000;"> []

  </span><span style="color: #0000ff;">this</span>.then = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onFulfilled, onRejected) {
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve, reject) =&gt;<span style="color: #000000;"> {
      handle({
        onFulfilled,
        onRejected,
        resolve,
        reject,
      })
    })
  }

  </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">catch</span> = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onError) {
    </span><span style="color: #0000ff;">this</span>.then(<span style="color: #0000ff;">null</span><span style="color: #000000;">, onError)
  }

  </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">finally</span> = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (onDone) {
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.then(onDone, onError)
  }

  </span><span style="color: #0000ff;">this</span>.resolve = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (value) {
    </span><span style="color: #0000ff;">if</span> (value &amp;&amp; value <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Promise) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> value
    } </span><span style="color: #0000ff;">if</span> (value &amp;&amp; <span style="color: #0000ff;">typeof</span> value === 'object' &amp;&amp; <span style="color: #0000ff;">typeof</span> value.then === 'function'<span style="color: #000000;">) {
      const { then } </span>=<span style="color: #000000;"> value
      </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve) =&gt;<span style="color: #000000;"> {
        then(resolve)
      })
    } </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (value) {
      </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(resolve =&gt;<span style="color: #000000;"> resolve(value))
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(resolve =&gt;<span style="color: #000000;"> resolve())
  }

  </span><span style="color: #0000ff;">this</span>.reject = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (value) {
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(((resolve, reject) =&gt;<span style="color: #000000;"> {
      reject(value)
    }))
  }

  </span><span style="color: #0000ff;">this</span>.all = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (arr) {
    const args </span>=<span style="color: #000000;"> Array.prototype.slice.call(arr)
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(((resolve, reject) =&gt;<span style="color: #000000;"> {
      </span><span style="color: #0000ff;">if</span> (args.length === 0) <span style="color: #0000ff;">return</span><span style="color: #000000;"> resolve([])
      let remaining </span>=<span style="color: #000000;"> args.length

      </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> res(i, val) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
          </span><span style="color: #0000ff;">if</span> (val &amp;&amp; (<span style="color: #0000ff;">typeof</span> val === 'object' || <span style="color: #0000ff;">typeof</span> val === 'function'<span style="color: #000000;">)) {
            const { then } </span>=<span style="color: #000000;"> val
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> then === 'function'<span style="color: #000000;">) {
              then.call(val, (val) </span>=&gt;<span style="color: #000000;"> {
                res(i, val)
              }, reject)
              </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
            }
          }
          args[i] </span>=<span style="color: #000000;"> val
          </span><span style="color: #0000ff;">if</span> (--remaining === 0<span style="color: #000000;">) {
            resolve(args)
          }
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (ex) {
          reject(ex)
        }
      }
      </span><span style="color: #0000ff;">for</span> (let i = 0; i &lt; args.length; i++<span style="color: #000000;">) {
        res(i, args[i])
      }
    }))
  }

  </span><span style="color: #0000ff;">this</span>.race = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (values) {
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise(((resolve, reject) =&gt;<span style="color: #000000;"> {
      </span><span style="color: #0000ff;">for</span> (let i = 0, len = values.length; i &lt; len; i++<span style="color: #000000;">) {
        values[i].then(resolve, reject)
      }
    }))
  }

  </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> handle(callback) {
    </span><span style="color: #0000ff;">if</span> (state === 'pending'<span style="color: #000000;">) {
      callbacks.push(callback)
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
    }

    const cb </span>= state === 'fulfilled' ?<span style="color: #000000;"> callback.onFulfilled : callback.onRejected
    const next </span>= state === 'fulfilled' ?<span style="color: #000000;"> callback.resolve : callback.reject

    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">cb) {
      next(value)
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
    }
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
      const ret </span>=<span style="color: #000000;"> cb(value)
      next(ret)
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (e) {
      callback.reject(e)
    }
  }
  </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> resolve(newValue) {
    const fn </span>= () =&gt;<span style="color: #000000;"> {
      </span><span style="color: #0000ff;">if</span> (state !== 'pending') <span style="color: #0000ff;">return</span>

      <span style="color: #0000ff;">if</span> (newValue &amp;&amp; (<span style="color: #0000ff;">typeof</span> newValue === 'object' || <span style="color: #0000ff;">typeof</span> newValue === 'function'<span style="color: #000000;">)) {
        const { then } </span>=<span style="color: #000000;"> newValue
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> then === 'function'<span style="color: #000000;">) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;"> newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span>
          <span style="color: #008000;">//</span><span style="color: #008000;"> 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span>
<span style="color: #000000;">          then.call(newValue, resolve, reject)
          </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
        }
      }
      state </span>= 'fulfilled'<span style="color: #000000;">
      value </span>=<span style="color: #000000;"> newValue
      handelCb()
    }

    setTimeout(fn, </span>0<span style="color: #000000;">)
  }
  </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> reject(error) {
    const fn </span>= () =&gt;<span style="color: #000000;"> {
      </span><span style="color: #0000ff;">if</span> (state !== 'pending') <span style="color: #0000ff;">return</span>

      <span style="color: #0000ff;">if</span> (error &amp;&amp; (<span style="color: #0000ff;">typeof</span> error === 'object' || <span style="color: #0000ff;">typeof</span> error === 'function'<span style="color: #000000;">)) {
        const { then } </span>=<span style="color: #000000;"> error
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> then === 'function'<span style="color: #000000;">) {
          then.call(error, resolve, reject)
          </span><span style="color: #0000ff;">return</span><span style="color: #000000;">
        }
      }
      state </span>= 'rejected'<span style="color: #000000;">
      value </span>=<span style="color: #000000;"> error
      handelCb()
    }
    setTimeout(fn, </span>0<span style="color: #000000;">)
  }
  </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> handelCb() {
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (callbacks.length) {
      const fn </span>=<span style="color: #000000;"> callbacks.shift()
      handle(fn)
    }
  }
  fn(resolve, reject)
}</span></pre>
</div>
<h3 class="heading" data-id="heading-10">最后</h3>
<p>觉得内容有帮助可以关注下<a href="https://juejin.im/user/5874526761ff4b006d4fd9a4/posts">我的掘金主页</a>：<a href="https://juejin.im/user/5874526761ff4b006d4fd9a4/posts">https://juejin.im/user/5874526761ff4b006d4fd9a4/posts</a></p>
<p>觉得内容有帮助可以关注下我的公众号 「前端Q」，一起学习成长～～</p>
<img src="./images/这一次，彻底弄懂 Promise 原理0.png" alt="" width="651" height="186" /></div>
<p><br /><br /></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>