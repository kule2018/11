<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修重读《学习JavaScript数据结构与算法-第三版》- 第4章 栈' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>重读《学习JavaScript数据结构与算法-第三版》- 第4章 栈</center></div><div class='banquan'>原文出处:本文由博客园博主胡哥有话说提供。<br/>
原文连接:https://www.cnblogs.com/justbecoder/p/11375372.html</div><br>
    <h2 id="定场诗">定场诗</h2>
<pre><code><code>金山竹影几千秋，云索高飞水自流；
万里长江飘玉带，一轮银月滚金球。
远自湖北三千里，近到江南十六州；
美景一时观不透，天缘有分画中游。</code></pre>
<h2 id="前言">前言</h2>
<p>本章是重读《学习JavaScript数据结构与算法-第三版》的系列文章，本章为各位小伙伴分享数据结构-<code>栈</code>的故事，请让胡哥带你走进<code>栈</code>的世界</p>
<h2 id="栈">栈</h2>
<p>何为栈？栈是一种遵从<strong>后进先出（LIFO）</strong>原则的有序集合。</p>
<blockquote>
<p>新添加或待删除的元素都保存在栈的同一端，称作栈顶；另一端就叫栈底。</p>
<p>在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p>
</blockquote>
<h2 id="基于数组的栈">基于数组的栈</h2>
<blockquote>
<p>我们将创建一个基于数组的栈，了解栈的结构、运行规则</p>
</blockquote>
<pre><code><code>/**
 * 基于数组array的栈Stack
 * @author huxiaoshuai
 */
class Stack {
  // 初始化
  constructor () {
    this.items = []
  }
}</code></pre>
<blockquote>
<p>使用数组保存栈里的元素</p>
</blockquote>
<p>数组允许我们在任何位置添加和删除元素，那基于栈遵循<strong>LIFO</strong>原则，我们对元素的插入和删除功能进行封装</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>push(element(s))</td>
<td>添加一个（或多个）新元素到栈顶</td>
</tr>
<tr class="even">
<td>pop()</td>
<td>移除栈顶元素，同时返回被移除的元素</td>
</tr>
<tr class="odd">
<td>peek()</td>
<td>返回栈顶的元素，不对栈做任何修改</td>
</tr>
<tr class="even">
<td>isEmpty()</td>
<td>判断栈是否为空，为空则返回true，否则返回false</td>
</tr>
<tr class="odd">
<td>clear()</td>
<td>移除栈的所有元素</td>
</tr>
<tr class="even">
<td>size()</td>
<td>返回栈的元素个数</td>
</tr>
</tbody>
</table>
<h3 id="代码实现">代码实现</h3>
<pre><code><code>class Stack {
  // 初始化
  constructor () {
    this.items = []
  }

  /**
   * push() 添加元素到栈顶
   */ 
  push (element) {
    this.items.push(element)
  }

  /**
   * pop() 移除栈顶元素并返回
   */
  pop () {
    return this.items.pop()
  }

  /**
   * peek() 返回栈顶部元素
   */
  peek () {
    return this.items[this.items.length - 1]
  }

  /***
   * isEmpty() 检测栈是否为空
   */
  isEmpty () {
    return this.items.length === 0
  }

  /**
   * size() 返回栈的长度
   */
  size () {
    return this.items.length
  }
  
  /**
   * clear() 清空栈元素
   */
  clear () {
    this.items = []
  }
}</code></pre>
<h3 id="使用stack类">使用Stack类</h3>
<pre class="javacript"><code>const stack = new Stack()

console.log(stack.isEmpty()) // true

// 添加元素
stack.push(5)
stack.push(8)

// 输出元素
console.log(stack.peek()) // 8

stack.push(11)
console.log(stack.size()) // 3
console.log(stack.isEmpty()) // false

stack.push(15)</code></pre>
<p>基于以上栈操作的示意图<br />
<img src="./images/重读《学习JavaScript数据结构与算法-第三版》- 第4章 栈0.png" alt="基于以上栈操作的示意图" /></p>
<pre><code><code>stack.pop()
stack.pop()
console.log(stack.size()) // 2</code></pre>
<p>基于以上栈操作的示意图<br />
<img src="./images/重读《学习JavaScript数据结构与算法-第三版》- 第4章 栈1.png" alt="基于以上栈操作的示意图" /></p>
<h3 id="基于对象的栈">基于对象的栈</h3>
<p>创建一个Stack类最简单的方式是使用一个数组来存储元素。在处理大量数据的时候，我们同样需要评估如何操作数据是最高效的。</p>
<p>使用数组时，大部分方法的时间复杂度是O(n)。简单理解：O(n)的意思为我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的n代表数组的长度。数组越长，所需时间会更长。另外，数组是元素的一个有序集合，为保证元素的有序排列，会占用更多的内存空间。</p>
<p><strong>使用</strong>JavaScript<strong>对象</strong>来<strong>存储</strong>所有的<strong>栈元素</strong>，以实现可以直接获取元素，同时占用较少的内存空间，同时保证所有的元素按照我们的需要进行排列，遵循<strong>后进先出（LIFO）</strong>原则。</p>
<h3 id="代码实现-1">代码实现</h3>
<pre><code><code>/**
 * 基于对象的Stack类
 * @author huxiaoshai
 */
class Stack {
  // 初始化
  constructor () {
    this.items = {}
    this.count = 0
  }

  /**
   * push() 向栈中添加元素
   */
  push (element) {
    this.items[this.count] = element
    this.count++
  }

  /**
   * isEmpty() 判断是否为空
   */
  isEmpty () {
    return this.count === 0
  }

  /**
   * size() 返回栈的长度
   */
  size () {
    return this.count
  }

  /**
   * pop() 栈顶移除元素并返回
   */
  pop () {
    if (this.isEmpty()) {
      return undefined
    }
    this.count--
    let result = this.items[this.count]
    delete this.items[this.count]
    return result
  }

  /**
   * peek() 返回栈顶元素，如果为空则返回undefined
   */
  peek () {
    if (this.isEmpty()) {
      return undefined
    }
    return this.items[this.count - 1]
  }

  /**
   * clear() 清空栈数据
   */
  clear () {
    this.items = {}
    this.count = 0
  }

  /**
   * toString() 实现类似于数组结构打印栈内容
   */
  toString () {
    if (this.isEmpty()) {
      return &#39;&#39;
    }
    let objStr = `${this.items[0]}`
    for (let i = 1; i &lt; this.count; i++) {
      objStr = `${objStr},${this.items[i]}`
    }
    return objStr
  }
}</code></pre>
<h3 id="保护数据结构内部元素">保护数据结构内部元素</h3>
<blockquote>
<p>私有属性</p>
</blockquote>
<p>有时候我们需要创建供其他开发者使用的数据结构和对象时，我们希望保存内部元素，只有使用允许的方法才能修改内部结构。很不幸，目前JS是没有办法直接声明私有属性的，目前业内主要使用一下几种方式实现私有属性。</p>
<ol>
<li><p>下划线命名约定</p>
<pre><code><code>class Stack {
  constructor () {
    this._items = {}
    this._count = 0
  }
}</code></pre>
<blockquote>
<p>这只是约定，一种规范，并不能实际保护数据</p>
</blockquote></li>
<li><p>基于ES6的限定作用域Symbol实现类</p>
<pre><code><code>const _items = Symbol(&#39;stackItems&#39;)
class Stack {
  constructor () {
    this[_items] = []
  }
}</code></pre>
<blockquote>
<p>假的私有属性，ES6新增的Object.getOwnPropertySymbols方法能够获取类里面声明的所有Symbols属性</p>
</blockquote></li>
<li><p>基于ES6的WeakMap实现类</p>
<pre><code><code>/**
 * 使用WeekMap实现类的私有属性
 */
const items = new WeakMap()
console.log(items) // WeakMap { [items unknown] }

class Stack {
  constructor () {
    items.set(this, [])
  }

  push (element) {
    const s = items.get(this)
    s.push(element)
  }

  pop () {
    const s = items.get(this)
    const r = s.pop()
    return r
  }

  toString () {
    const s = items.get(this)
    return s.toString()
  }
}

const stack = new Stack()
stack.push(1)
stack.push(2)
stack.push(3)

console.log(stack.toString()) // 1,2,3
console.log(stack.items) // undefined</code></pre>
<blockquote>
<p>使用该方式，items是Stack类里的私有属性，但是此种方式代码的可读性不强，而且在扩展该类时无法继承私有属性。</p>
</blockquote></li>
<li><p>ECMAScript类属性提案</p>
<blockquote>
<p>有一个关于JavaScript类中增加私有属性的提案。通过在属性前添加井号(#)作为前缀来声明私有属性。</p>
</blockquote></li>
</ol>
<pre><code><code>class Stack {
  #count = 0
  #items = []
}</code></pre>
<h2 id="使用栈来解决问题">使用栈来解决问题</h2>
<p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后续会在讨论图和回溯问题时进一步详细讲解）。栈的使用场景有很多，如汉诺塔问题、平衡圆括号、计算机科学问题：十进制转二进制问题</p>
<pre><code><code>/**
 * decimalToBinary() 实现十进制转二进制的算法
 */ 
function decimalToBinary (decNumber) {
  // 实例化栈数据结构
  const remStack = new Stack()
  let number = decNumber
  let rem;
  let binaryString = &#39;&#39;

  // 依次将获取的二进制数压入栈中
  while (number &gt; 0) {
    rem = Math.floor(number % 2)
    remStack.push(rem)
    number = Math.floor(number / 2)
  }
  // 拼接要输出的二进制字符串
  while (!remStack.isEmpty()) {
    binaryString += remStack.pop().toString()
  }
  return binaryString
}

console.log(decimalToBinary(10)) // 1010
console.log(decimalToBinary(23)) // 10111</code></pre>
<h2 id="后记">后记</h2>
<p>以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得<strong><code>收藏</code></strong>、<strong><code>转发</code></strong>、点击右下角按钮<strong><code>在看</code></strong>，推荐给更多小伙伴呦，欢迎多多留言交流...</p>
<blockquote>
<p>胡哥有话说，一个有技术，有情怀的胡哥！京东开放平台首席前端攻城狮。与你一起聊聊大前端，分享前端系统架构，框架实现原理，最新最高效的技术实践！</p>
</blockquote>
<p>长按扫码关注，更帅更漂亮呦！关注胡哥有话说公众号，可与胡哥继续深入交流呦！</p>
<p><img src="./images/重读《学习JavaScript数据结构与算法-第三版》- 第4章 栈2.png" alt="胡哥有话说" /></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>