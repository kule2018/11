<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修重读《学习JavaScript数据结构与算法-第三版》-第2章 ECMAScript与TypeScript概述' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>重读《学习JavaScript数据结构与算法-第三版》-第2章 ECMAScript与TypeScript概述</center></div><div class='banquan'>原文出处:本文由博客园博主胡哥有话说提供。<br/>
原文连接:https://www.cnblogs.com/justbecoder/p/11353384.html</div><br>
    <h2 id="定场诗">定场诗</h2>
<p>八月中秋白露，路上行人凄凉；</p>
<p>小桥流水桂花香，日夜千思万想。</p>
<p>心中不得宁静，清早览罢文章，</p>
<p>十年寒苦在书房，方显才高志广。</p>
<h2 id="前言">前言</h2>
<p>洛伊安妮·格罗纳女士所著的《学习JavaScript数据结构与算法》第三版于2019年的5月份再次刊印发行，新版内容契合当下，实为JavaScript开发人员的必备之佳作。有幸重读此版，与诸君分享共勉。</p>
<h2 id="内容提要">内容提要</h2>
<p>此章节为第2章-ECMAScript与TypeScript概述，主要介绍了JS和TS的相关概念，以及在JS新版本中的新特性：let、解构、箭头函数等。</p>
<h2 id="ecmascript还是javascript">2.1 ECMAScript还是JavaScript</h2>
<blockquote>
<p>ECMA是一个将信息标准化的组织。ECMAScript是一个语言的标准，而JavaScript是该标准(最流行)的一个实现。</p>
<p>或恰如：ECMAScript是JS身份证上的名字(标准)，JavaScript是常用的称呼(常见、亲切)。</p>
</blockquote>
<h3 id="js的版本问题">JS的版本问题</h3>
<table>
<thead>
<tr class="header">
<th>版本</th>
<th>简称</th>
<th>发布时间</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ECMAScript5</td>
<td>ES5</td>
<td>2009年12月</td>
<td></td>
</tr>
<tr class="even">
<td>ECMAScript2015</td>
<td>ES6</td>
<td>2015年6月</td>
<td>ECMAScript规范委员会决定每年更新标准一次，js的标准称呼为：ECMAScript+年份</td>
</tr>
<tr class="odd">
<td>ECMAScript2016</td>
<td>ES7</td>
<td>2016年6月</td>
<td>ECMAScript第7个版本</td>
</tr>
<tr class="even">
<td>ECMAScript2017</td>
<td>ES8</td>
<td>2017年6月</td>
<td>ECMAScript第8个版本</td>
</tr>
<tr class="odd">
<td></td>
<td>ES.NEXT</td>
<td></td>
<td>泛指下一个版本的ECMAScript</td>
</tr>
</tbody>
</table>
<h3 id="js版本的兼容性问题">JS版本的兼容性问题</h3>
<p>一定要明白，即便ES2015到ES2017已经发布，但不是所有的浏览器都支持新特性。</p>
<ol>
<li>使用最新版的浏览器进行体验</li>
<li><p>使用Babel.js对使用ECMAScript新语言特性的JavaScript代码转换成只使用广泛支持的ES5特性的等价代码</p>
<blockquote>
<p>Babel.js是一个JavaScript的转译器，具体使用文档：<a href="https://babeljs.io/">官网-传送门</a> <a href="https://www.babeljs.cn/">Babel.js中文网</a></p>
</blockquote></li>
</ol>
<h2 id="es6的新功能">2.2 ES6+的新功能</h2>
<h3 id="let和const定义变量">let和const定义变量</h3>
<ol>
<li><p>不存在变量提升</p>
<pre><code><code>console.log(a) // ReferenceError: Cannot access &#39;a&#39; before initialization
let a = 10</code></pre></li>
<li><p>不允许重复声明定义变量</p>
<pre><code><code>let a = 10
let a = 20  // SyntaxError: Identifier &#39;a&#39; has already been declared</code></pre></li>
<li><p>变量作用域</p>
<blockquote>
<p>块状作用域 {}</p>
</blockquote>
<pre><code><code>if (true) {
  const b = 10
}
console.log(b) // ReferenceError: b is not defined</code></pre></li>
</ol>
<h3 id="let和const到底选择谁">let和const到底选择谁？</h3>
<p>const与let的行为是一样的，唯一的区别在于，使用const定义的变量是只读的，也就是常量。</p>
<blockquote>
<p>const保证的其实并不是变量的值不能改动，而是变量指向的内存地址所保存的数据不得改动。</p>
</blockquote>
<h3 id="扩展基本类型值和引用类型值">扩展：基本类型值和引用类型值</h3>
<p>每一个变量都指向了一个内存地址。</p>
<p><code>基本类型值</code>：指向了一个内存地址，变量的值就存储在改内存内置中。</p>
<p><code>引用类型值</code>：指向了一个内存地址，该内存地址中存储的是一个指针，一个指向实际数据的指针。</p>
<blockquote>
<p>const保证的是这个指针是固定的，总是指向另一个固定地址；但实际上指针指向的数据结构是否可变，则不能控制。</p>
</blockquote>
<h3 id="模板字面量">模板字面量</h3>
<p>模板字面量语法``提供了很大的帮助，支持JS书写时换行，可定义多行字符串；使用${}插入变量的值。</p>
<pre><code><code>let person = {
  name: &#39;王二狗&#39;,
  age: 18
}

let str = `给你介绍个人：
这个人的名字是${person.name}
`
console.log(str)</code></pre>
<h3 id="箭头函数">箭头函数</h3>
<blockquote>
<p>箭头函数 () =&gt; {} 简化了函数语法</p>
</blockquote>
<pre><code><code>let f = () =&gt; {
  console.log(&#39;我是箭头函数....&#39;)
}
f()

// 简化return关键字
let sum = (a, b) =&gt; a+b
sum(1, 2)
</code></pre>
<h3 id="函数参数默认值">函数参数默认值</h3>
<blockquote>
<p>支持定义函数参数的默认值</p>
</blockquote>
<pre><code><code>function sum (x = 1, y = 2, z = 3) {
  return x + y + z
}</code></pre>
<h3 id="声明展开与剩余参数">声明展开与剩余参数</h3>
<blockquote>
<p>展开运算符... 将对象或数组展开为一层，亦可当做剩余参数</p>
</blockquote>
<pre><code><code>let p = {
  name: &#39;人&#39;,
  age: 20,
  sex: &#39;男&#39;
}
let wangErGou = {
  ...p,
  name: &#39;王二狗&#39;
}
console.log(wangErGou)

// 剩余参数
function sum (x, y, ...a) {
  return x * y * a.length
}
sum(1, 2, 2, &#39;abc&#39;, true) // 6 等同于a是数组[2, &#39;abc&#39;, true]</code></pre>
<h3 id="解构">解构</h3>
<blockquote>
<p>数组与对象解构</p>
</blockquote>
<pre><code><code>let [x, y] = [10, 20]
console.log(x, y) // 10, 20

let {age, name} = {
  name: &#39;李四&#39;,
  age: 20
}
console.log(name, age) // 李四, 20</code></pre>
<blockquote>
<p>数组解构中许注意顺序，对象解构中无需注意顺序；解构中无对应的值，则改值为undefined</p>
</blockquote>
<p><strong>解构应用</strong></p>
<ol>
<li>交换变量值</li>
</ol>
<pre><code><code>let x = 10
let y = 20
[y, x] = [x, y]</code></pre>
<ol>
<li>属性简写</li>
</ol>
<pre><code><code>let x = 10
let y = 10
let obj = {x, y} // 相当于 {x: x, y: y}</code></pre>
<h3 id="简写方法名">简写方法名</h3>
<blockquote>
<p>对象中的方法名可简写</p>
</blockquote>
<pre><code><code>let obj = {
  name: &#39;王二狗&#39;,
  print () {
    console.log(this.name)
  }
} </code></pre>
<h3 id="使用类进行面向对象编程">使用类进行面向对象编程</h3>
<p><strong>定义</strong></p>
<pre><code><code>class Book {
  constructor (title, author, isbn) {
    this.title = title
    this.author = author
    this.isbn = isbn
  }
  printIsbn () {
    console.log(this.isbn)
  }
}
let book = new Book(&#39;郭德纲相声选&#39;, &#39;郭德纲&#39;, &#39;00111011&#39;)
book.printIsbn()</code></pre>
<p><strong>继承</strong></p>
<pre><code><code>class ITBook extends Book {
  constructor (title, author, isbn, technology) {
    // 代表调用父类构造函数
    super(title, author, isbn)
    this.technology = technology
  }
  printTechnology () {
    console.log(this.technology)
  }
}
let jsBook = new ITBook(&#39;JS数据结构与算法&#39;, &#39;Groner&#39;, &#39;123456789&#39;, &#39;JavaScript&#39;)
jsBook.printIsbn()
jsBook.printTechnology()</code></pre>
<h3 id="乘方运算符">乘方运算符</h3>
<pre><code><code>let r = 2
let area = Math.PI * r ** 2
console.log(area)</code></pre>
<h3 id="模块">模块</h3>
<ol>
<li>CommonJS规范是服务器端模块化开发规范，使用require方法加载；</li>
<li>AMD(Asynchronous Module Definition) 异步模块定义，RequireJS是AMD最流行的实现，是浏览器端模块化开发规范；</li>
<li>CMD(Common Module Definition) 通用模块定义，SeaJS是CMD的流行实现，是浏览器端模块化开发规范</li>
</ol>
<p><strong>ES6模块化开发</strong></p>
<blockquote>
<p>export 导出模块；import 导入模块</p>
</blockquote>
<pre><code><code>// moduleA.js
export const moduleA = &#39;moduleA&#39;</code></pre>
<pre><code><code>// html中引入，注意type=&quot;module&quot;
&lt;script type=&quot;module&quot;&gt;
  import { moduleA } from &#39;./moduleA.js&#39;
  console.log(moduleA)
&lt;/script&gt;</code></pre>
<h2 id="介绍typescript">2.3 介绍TypeScript</h2>
<blockquote>
<p>TypeScript是一个开源的、渐进式包含类型的JavaScript超集，由微软创建并维护。目的是让开发者增强JavaScript的能力并使应用的规模扩展变得更容易。</p>
</blockquote>
<p>TS在JavaScript中提供类型支持可以实现静态检查，从而更容易地重构代码和寻找BUG。最后，TypeScript为被编译为简单的JavaScript代码。</p>
<blockquote>
<p>编写时为.ts文件，使用TypeScript对其进行tsc编译，最终为js文件</p>
</blockquote>
<p><strong>下载TypeScript</strong></p>
<pre><code><code>npm i -g typescript</code></pre>
<p><strong>创建.ts文件，写入内容</strong></p>
<pre class="typescript"><code>// demo.ts
let a = &#39;初始化为字符串内容&#39;
a = 10
console.log(a)</code></pre>
<p><strong>编译ts文件</strong></p>
<pre class="typescript"><code>tsc demo.ts</code></pre>
<blockquote>
<p>此处回生成demo.js文件，同时控制台报警告信息：error TS2322: Type '10' is not assignable to type 'string'. 说明TS对变量类型进行了校验，但并未阻止编译器生成最终的js代码。</p>
</blockquote>
<h3 id="ts类型推断">TS类型推断</h3>
<pre class="typescript"><code>// 定义变量，并约束变量类型
let age: number = 20
let flag: Boolean = true</code></pre>
<blockquote>
<p>TS允许我们给变量设置一个类型，但是此种写法太麻烦。TS提供了便捷的类型推断机制，相当于在给变量赋初始值时就约束了变量的类型。</p>
</blockquote>
<pre class="typescript"><code>// 上面的代码改造
let age = 20 // 数值类型
let flag = true // 布尔值类型</code></pre>
<blockquote>
<p>那么，什么时候需要给变量设置类型呢？声明变量，但没有设置其初始值的时候！</p>
<p>如果没有给变量设置类型，那么它的类型会被自动设置为any，意思为接受任何类型的值。</p>
</blockquote>
<h3 id="接口">接口</h3>
<p>在TS中，有两种接口概念：</p>
<h4 id="第一种给变量设置类型是对一个对象必须包含的属性和方法的描述">第一种：给变量设置类型，是对一个对象必须包含的属性和方法的描述</h4>
<pre><code><code>interface Person {
  age: number,
  name: string
}

function printName (person: Person) {
  console.log(person.name)
}

const john = {
  name: &#39;john&#39;,
  age: 21
}
const mary = {
  name: &#39;mary&#39;,
  age: 20,
  phone: &#39;123456&#39;
}

printName(john)
printName(mary)</code></pre>
<blockquote>
<p>执行tsc编译，木有任何问题。但是小伙伴可能会比较奇怪，对象mary中属性多了个phone，但是并未影响代码的执行。</p>
<p><strong>鸭子类型概念</strong>：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子！</p>
<p>变量mary的行为与Person接口定义的一样，那么它就是一个Person。</p>
</blockquote>
<h4 id="第二种ts接口的概念和面向对象编程相关">第二种：TS接口的概念和面向对象编程相关</h4>
<blockquote>
<p>接口视为一份合约，在合约里可以定义这份合约的类或接口的行为</p>
</blockquote>
<pre class="typescript"><code>interface Comparable {
  compareTo (b): number
}

class myObject implements Comparable {
  age: number
  compareTo(b): number {
    if (this.age === b.age) {
      return 0
    }
    return this.age &gt; b.age ? 1 : -1
  }
}

let obj = new MyObject()
obj.age = 10
let res = obj.compareTo(20)
console.log(res) // -1</code></pre>
<blockquote>
<p>Comparable接口告诉MyObject类，它需要实现一个叫做compareTo的方法，并且该方法接收一个参数。</p>
</blockquote>
<h4 id="泛型">泛型</h4>
<blockquote>
<p>对数据结构和算法作用强大的TS特性是泛型这一概念</p>
</blockquote>
<pre class="typescript"><code>interface Comparable&lt;T&gt; {
  compareTo (b: T): number
}

class MyObject implements Comparable&lt;MyObject&gt; {
  age: number
  compareTo(b: MyObject): number {
    if (this.age === b.age) {
      return 0
    }
    return this.age &gt; b.age ? 1 : -1
  }
}

let obj = new MyObject()
obj.age = 10
let obj2 = new MyObject()
obj2.age = 20
let res = obj.compareTo(obj2)
console.log(res) // -1</code></pre>
<h2 id="后记">后记</h2>
<p>以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得<strong><code>收藏</code></strong>、<strong><code>转发</code></strong>、点击右下角按钮<strong><code>在看</code></strong>，推荐给更多小伙伴呦，欢迎多多留言交流...</p>
<blockquote>
<p>胡哥有话说，一个有技术，有情怀的胡哥！京东开放平台首席前端攻城狮。与你一起聊聊大前端，分享前端系统架构，框架实现原理，最新最高效的技术实践！</p>
</blockquote>
<p>长按扫码关注，更帅更漂亮呦！关注胡哥有话说公众号，可与胡哥继续深入交流呦！</p>
<p><img src="./images/重读《学习JavaScript数据结构与算法-第三版》-第2章 ECMAScript与TypeScript概述0.png" alt="胡哥有话说" /></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>