<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修21个React开发神器' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>21个React开发神器</center></div><div class='banquan'>原文出处:本文由博客园博主Fundebug提供。<br/>
原文连接:https://www.cnblogs.com/fundebug/p/22-miraculous-tools-for-react-developers-in-2019.html</div><br>
    <p><strong>摘要：</strong> React开发神器。</p>
<ul>
<li>原文：<a href="https://medium.com/better-programming/22-miraculous-tools-for-react-developers-in-2019-7d72054e2306">22 Miraculous Tools for React Developers in 2019</a></li>
<li>译者：前端小智</li>
</ul>
<p>下列工具中的重要性与排序无关。</p>
<h3 id="webpack-bundle-analyzer">1.Webpack Bundle Analyzer</h3>
<p>有没有想过你的应用程序的哪些包或哪部分代码所占总大小的多少? <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack Bundle Analyzer</a>可以帮助咱们分析。</p>
<p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack Bundle Analyzer</a>创建一个实时服务器，并提供依赖包交互式树形图可视化。 通过这个工具包，可以看到所渲染文件的位置，gzip大小，解析大小以及所父子级之间详情。</p>
<p>这个工具的好处是，可以根据你所看到来优化你的React应用。</p>
<p>收下是它生成的一个分析图：</p>
<p><img src="./images/21个React开发神器0.png" /></p>
<p>可以清楚地看到<code>pdf</code>包大小占用应用程序是最多的，同时也是占用分析图片最大比例，这对于咱们来说是所看即所得效果。</p>
<p>然而，生成分析图空间有限，你还可以传递一些有用的选项来更详细地查看它，比如<code>generateStatsFile: true</code>，还可以选择生成一个静态<code>HTML</code>文件，可以将其保存在开发环境之外的某个地方，以供以后使用。</p>
<h3 id="react-proto">2. React-Proto</h3>
<p><a href="https://github.com/React-Proto/react-proto">React-Proto</a> 是一个面向开发人员和设计人员的原型工具。这是一个桌面软件，所以在使用之前你必须下载并安装这个软件。</p>
<p>以下是使用方式一个简单演示：</p>
<p><img src="./images/21个React开发神器1.png" /></p>
<p>该应用程序允许你声明<code>props</code>及其<code>types</code>，在树中查看组件，导入背景图像，将它们定义为有状态或无状态，定义其父组件将是什么，放大/缩小，以及将原型导出到新的或现有项目。</p>
<p>该应用程序似乎更适合<code>Mac</code>用户，但它仍适用于<code>Windows</code>用户。</p>
<p>完成用户界面后，可以选择导出到现有项目或新项目。 如果你选择导出到现有项目并选择根目录，它会将它们导出到<code>./src/components</code>，如下所示：</p>
<p><img src="./images/21个React开发神器2.png" /></p>
<p>随着<code>React hook</code>的发布，这个应用程序需要更新做更多的工作。当然，开源是这个应用程序的好处，因为它使它有可能成为未来流行的开源存储库列表。</p>
<h3 id="why-did-you-render">3. Why Did You Render</h3>
<p><a href="https://github.com/welldone-software/why-did-you-render">Why Did You Render</a> 猴子补丁React通知你有关可避免的重新渲染的信息。</p>
<blockquote>
<p>猴子补丁: 这个叫法起源于Zope框架，大家在修正Zope的Bug的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁(guerilla patch)”，后来guerilla就渐渐的写成了gorllia((猩猩)，再后来就写了monkey(猴子)，所以猴子补丁的叫法是这么莫名其妙的得来的。</p>
</blockquote>
<p>猴子补丁主要有以下几个用处：</p>
<ul>
<li>在运行时替换方法、属性等</li>
<li>在不修改第三方代码的情况下增加原来不支持的功能</li>
<li>在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加</li>
</ul>
<p>这非常有用，不仅可以指导咱们修复项目的性能，还可以帮助你理解<code>React</code>是如何工作的。而且，当你更好地理解<code>React</code>的工作原理时，你就会成为更好的<code>React</code>开发人员。</p>
<p>通过声明一个额外的静态属性<code>whyDidYouRender</code>并将其值设置为<code>true</code>，可以将侦听器附加到任何自定义组件</p>
<pre><code><code>    import React from &#39;react&#39;
    import Button from &#39;@material-ui/core/Button&#39;
    
    const Child = (props) =&gt; &lt;div {...props} /&gt;
    
    const Child2 = ({ children, ...props }) =&gt; (
      &lt;div {...props}&gt;
        {children} &lt;Child /&gt;
      &lt;/div&gt;
    )
    
    Child2.whyDidYouRender = true
    
    const App = () =&gt; {
      const [state, setState] = React.useState({})
    
      return (
        &lt;div&gt;
          &lt;Child&gt;{JSON.stringify(state, null, 2)}&lt;/Child&gt;
          &lt;div&gt;
            &lt;Button type=&quot;button&quot; onClick={() =&gt; setState({ hello: &#39;hi&#39; })}&gt;
              Submit
            &lt;/Button&gt;
          &lt;/div&gt;
          &lt;Child2&gt;Child #2&lt;/Child2&gt;
        &lt;/div&gt;
      )
    }
    
    export default App</code></pre>
<p>这样做之后，在控制台才会打印令人恼人冗长警告：</p>
<p><img src="./images/21个React开发神器3.png" /></p>
<p>不要认为这是错误的提示，把它当成一件好事。 利用那些烦人的消息，这样你就可以修复那些浪费的重新渲染。</p>
<h3 id="create-react-app">4. Create React App</h3>
<p>大家都知道，<a href="https://github.com/facebook/create-react-app">Create React App</a>是创建 React项目的最快方式（开箱即用）。</p>
<p>还有什么比 <code>npx create-react-app &lt;name&gt;</code>更简单的呢</p>
<p>咱们还有些人可能不知道的是如何使用CRA创建<code>TypeScript</code>项目，这个也很简单，只需要在末尾添加<code>--typescript</code> 即可：</p>
<pre class="bash"><code>    npx create-react-app &lt;name&gt; — typescript</code></pre>
<p>这样可以省去手动将<code>TypeScript</code>添加到CRA创建项目中的麻烦。</p>
<h3 id="react-lifecycle-visualizer">5. React Lifecycle Visualizer</h3>
<p><a href="https://github.com/Oblosys/react-lifecycle-visualizer">React Lifecycle Visualizer</a>是一个npm包，用于跟踪和可视化任意<strong>React</strong>组件的生命周期方法。</p>
<p>与 <strong>Why Did You Render</strong> 工具类似，你可以选择任何组件来启动生命周期可视化工具：</p>
<pre><code><code>    import React from &#39;react&#39;
    import {
      Log,
      VisualizerProvider,
      traceLifecycle,
    } from &#39;react-lifecycle-visualizer&#39;
    
    class TracedComponent extends React.Component {
      state = {
        loaded: false,
      }
    
      componentDidMount() {
        this.props.onMount()
      }
    
      render() {
        return &lt;h2&gt;Traced Component&lt;/h2&gt;
      }
    }
    
    const EnhancedTracedComponent = traceLifecycle(TracedComponent)
    
    const App = () =&gt; (
      &lt;VisualizerProvider&gt;
        &lt;EnhancedTracedComponent /&gt;
        &lt;Log /&gt;
      &lt;/VisualizerProvider&gt;
    )</code></pre>
<p>运行结果，如下所示：</p>
<p><img src="./images/21个React开发神器4.png" /></p>
<p>但是，其中一个缺点是它目前仅适用于<strong>类组件</strong>，因此尚不支持 <strong>Hook</strong>。</p>
<h3 id="guppy">6. Guppy</h3>
<p><a href="https://github.com/joshwcomeau/guppy">Guppy</a> 是<code>React</code>的一个友好且免费的应用程序管理器和任务运行器，它在桌面上运行且跨平台的，你可以放心用。</p>
<p>它为开发人员经常面临的许多典型任务(如创建新项目、执行任务和管理依赖项)提供了友好的图形用户界面。</p>
<p><strong>Guppy</strong> 启动后的的样子</p>
<p><img src="./images/21个React开发神器5.png" /></p>
<h3 id="react-testing-library">7. react-testing-library</h3>
<p><a href="https://github.com/testing-library/react-testing-library">react-testing-library</a> 是一个很棒的测试库，编写单元测试时，它会让你感觉很好。这个包提供了<strong>React DOM</strong>测试实用程序，鼓励良好的测试实践。</p>
<p>此解决方案旨在解决测试实现细节的问题，而不是测试React组件的输入/输出，就像用户会看到它们一样。</p>
<p>这是<code>react-test -library</code>解决的一个问题，因为理想情况下，你只希望您的用户界面能够正常工作，并最终正确地渲染出来。</p>
<p>如何将数据获取到这些组件并不重要，只要它们仍然提供预期的输出即可。</p>
<p>以下是使用此库进行测试的示例代码：</p>
<pre><code><code>    // Hoist helper functions (but not vars) to reuse between test cases
    const renderComponent = ({ count }) =&gt;
      render(
        &lt;StateMock state={{ count }}&gt;
          &lt;StatefulCounter /&gt;
        &lt;/StateMock&gt;,
      )
    
    it(&#39;renders initial count&#39;, async () =&gt; {
      // Render new instance in every test to prevent leaking state
      const { getByText } = renderComponent({ count: 5 })
    
      await waitForElement(() =&gt; getByText(/clicked 5 times/i))
    })
    
    it(&#39;increments

     count&#39;, async () =&gt; {
      // Render new instance in every test to prevent leaking state
      const { getByText } = renderComponent({ count: 5 })
    
      fireEvent.click(getByText(&#39;+1&#39;))
      await waitForElement(() =&gt; getByText(/clicked 6 times/i))
    })</code></pre>
<h3 id="react-developer-tools">8. React Developer Tools</h3>
<p><a href="https://github.com/facebook/react-devtools">React Developer Tools</a>是一个扩展插件，允许在<code>Chrome</code>和<code>Firefox Developer Tools</code>中检查React的组件层次结构。</p>
<p>这是<code>React</code>开发中最常见的扩展插件，并且是<code>React</code>开发人员可以用来调试其应用程序的最有用的工具之一。</p>
<h3 id="bit">9. Bit</h3>
<p>通过<a href="https://bit.dev/">Bit</a>可以看到数以千计的开源组件，并允许还可以使用它们来构建项目。</p>
<p><img src="./images/21个React开发神器6.png" /></p>
<p>列表中有很多很多React组件可供咱们使用，包括选项卡，按钮，图表，表格，导航栏，下拉列表，加载微调器，日期选择器，面包屑，图标，布局等。</p>
<h3 id="storybook">10. Storybook</h3>
<p><a href="https://storybook.js.org/">Storybook</a> 是一个轻松地构建UI组件的库。该工具启动一个实时开发服务器，支持开箱即用的热重载，你可以在其中独立地实时开发<strong>React</strong>组件。</p>
<p>这足以作为普通文档页面：</p>
<p><img src="./images/21个React开发神器7.png" /></p>
<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href="https://www.fundebug.com/?utm_source=xiaozhi">Fundebug</a>。</strong></p>
<h3 id="react-sight">11. React Sight</h3>
<p>你有没有想过你的应用程序在流程图中的样子？ <a href="https://www.reactsight.com/">React Sight</a>允许你通过展示整个应用程序的实时组件层次结构树来可视化React应用程序。</p>
<p>它还支持<strong>react-router</strong>，<strong>Redux</strong>以及<strong>React Fiber</strong>。</p>
<p>使用此工具，您可以将鼠标悬停在节点上，这些节点是指向与树中组件直接相关的组件的链接。</p>
<p>如果在查看结果时遇到问题，可以在地址栏中输入<code>chrome:extensions</code> ，查找“React Sight”框，然后单击<code>“Allow access to file URLs”</code>开关，如下所示：</p>
<p><img src="./images/21个React开发神器8.png" /></p>
<h3 id="react-cosmos">12. React Cosmos</h3>
<p><a href="https://github.com/react-cosmos/react-cosmos">React Cosmos</a>是一个用于创建可重用React组件的开发工具。</p>
<p>它扫描项目中的组件，并使你能够:</p>
<ul>
<li>通过 props，context和state任意组合来渲染组件。</li>
<li>模拟每个外部依赖项(API响应、<code>localStorage</code>等)。</li>
<li>查看应用程序状态在与运行实例交互时的实时演变。</li>
</ul>
<h3 id="codesandbox">13. CodeSandbox</h3>
<p><a href="https://codesandbox.io/">CodeSandbox</a>一个在线编辑器，可以在上面创建Web应用程序并实行运行。</p>
<p>CodeSandbox 最初只在早期阶段支持<strong>React</strong>，但它们现在已经扩展到<strong>Vue</strong>和<strong>Angular</strong>等库的其他入门模板。</p>
<p>他们还支持使用常见的静态站点生成器（如<a href="https://www.gatsbyjs.org/">Gatsby</a>或<a href="https://nextjs.org/">Next.js</a>）创建项目来启动React Web项目。</p>
<p><img src="./images/21个React开发神器9.png" /></p>
<h3 id="react-bits">14. React Bits</h3>
<p><a href="https://vasanthk.gitbooks.io/react-bits/">React Bits</a>是一个React模式、技术、技巧和技巧的集合，所有这些都以类似于在线文档的格式编写，你可以在同一个选项卡上快速访问不同的设计模式和技术、反模式、样式、UX变体以及其他与React相关的有用材料。</p>
<p><a href="https://github.com/vasanthk/react-bits">GitHub repo</a>，目前有10083颗星星。</p>
<p><img src="./images/21个React开发神器10.png" /></p>
<h3 id="folderize">15. folderize</h3>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ee92.folderize">folderize</a>是一个VS Code 扩展。 它允许您将组件文件转换为组件文件夹结构。 React 组件仍然是一个组件，只是转换为一个目录。</p>
<p>例如，假设正在创建一个React组件，该组件将文件作为<code>props</code>来显示有用的信息，如元数据</p>
<p>元数据组件的逻辑占用了大量的行，因此咱们决定将其拆分为单独的文件。 但是，当这样做时，咱们就有两个相互关联的文件。</p>
<p>所以，就有有一个大概如下所示的目录：</p>
<p><img src="./images/21个React开发神器11.png" /></p>
<p>咱们可能想要将<code>FileView.js</code>和<code>filemetada.js</code>抽象到目录结构中，就像<code>Apple</code>一样，尤其是考虑添加更多与<code>FileScanner.js</code>等文件相关的组件时。</p>
<p>这就是<code>folderize</code>为咱们所做的，这样组件们就可以得到一个类似的结构</p>
<p><img src="./images/21个React开发神器12.png" /></p>
<h3 id="react-starter-projects">16. React Starter Projects</h3>
<p><a href="https://www.javascriptstuff.com/react-starter-projects/#react%20dev">React starter projects</a> 是一个依赖库列表，可以在上面快速你需要要的依赖库的名称并可以跳转对应的 <code>github</code> 上。</p>
<p>一旦看到一个你喜欢的入门项目，你就可以简单地克隆这个库，并根据你的需要进行修改。</p>
<p>但是，并不是所有的依赖库都是通过克隆使用，因为其中一些库需要通过安装形式，才能成为项目的依赖项。</p>
<p><img src="./images/21个React开发神器13.png" /></p>
<h3 id="highlight-updates">17. Highlight Updates</h3>
<p>这可能是开发工具包中最重要的工具。 <a href="https://reactjs.org/docs/optimizing-performance.html">Highlight Updates</a>是<strong>React DevTools</strong>扩展的一个特性，可以查看页面中的哪些组件正在不必要地重新渲染。</p>
<p><img src="./images/21个React开发神器14.png" /></p>
<p>它可以帮助你在开发页面时是更容易发现一些性能问题，因为它们会使用橙色或红色对严重的重新渲染问题进行着色。</p>
<h3 id="react-diff-viewer">18. React Diff Viewer</h3>
<p><a href="https://praneshravi.in/react-diff-viewer/">React Diff Viewer</a>是一个简单而美观的文本差异对比工具 这支持分割视图，内嵌视图，字符差异，线条突出显示等功能。</p>
<p><img src="./images/21个React开发神器15.png" /></p>
<h3 id="js.coach">19. JS.coach</h3>
<p><a href="https://js.coach/?collection=React">JS.coach</a> 是我最常用来与 React 有需要的库的网站。从这个页面可以找到需要的任何东西。</p>
<p>它快速、简单、不断更新，并且总是能给我所有项目所需的结果。最近还添加了React VR，非常棒。</p>
<h3 id="awesome-react">20. Awesome React</h3>
<p><a href="https://github.com/enaqx/awesome-react">Awesome React</a>开源库是一个与React相关的很棒的列表。</p>
<p>我可能会忘记其他网站并单独从这个链接学习React。 因为可以在此找到批量有用的资源，这些资源肯定会帮助我们构建出色的React应用程序！</p>
<h3 id="proton-native">21. Proton Native</h3>
<p><a href="https://github.com/kusti8/proton-native">Proton Native</a>为咱们提供了一个React环境来构建跨平台的本机桌面应用程序。</p>
<p>它是<a href="https://electronjs.org/">Electron</a>的替代产品，具有一些简洁的功能，包括：</p>
<ul>
<li>与React Native语法相同。</li>
<li>适用于现有的React库，例如 Redux。</li>
<li>兼容所有正常的 Node.js 包。</li>
</ul>
<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href="https://www.fundebug.com/?utm_source=xiaozhi">Fundebug</a>。</strong></p>
<h3 id="关于fundebug">关于Fundebug</h3>
<p><a href="https://www.fundebug.com/">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了20亿+错误事件，付费客户有阳光保险、核桃编程、荔枝FM、掌门1对1、微脉、青团社等众多品牌企业。欢迎大家<a href="https://www.fundebug.com/team/create">免费试用</a>！</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>