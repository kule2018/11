<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修BeautyWe.js 一套专注于微信小程序的开发范式' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>BeautyWe.js 一套专注于微信小程序的开发范式</center></div><div class='banquan'>原文出处:本文由博客园博主Fundebug提供。<br/>
原文连接:https://www.cnblogs.com/fundebug/p/miniprogram-beautywe.html</div><br>
    <p><strong>摘要：</strong> 小程序框架...</p>
<ul>
<li>作者：JerryC</li>
<li>原文：<a href="https://segmentfault.com/a/1190000019432720">BeautyWe.js 一套专注于微信小程序的开发范式</a></li>
</ul>
<p><strong><a href="https://www.fundebug.com/">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式0.png" /></p>
<blockquote>
<p>官网：<a href="http://beautywejs.com/">beautywejs.com</a><br />
Repo: <a href="https://github.com/beautywe/beautywe">beautywe</a></p>
</blockquote>
<h3 id="一个简单的介绍">一个简单的介绍</h3>
<p><strong>BeautyWe.js 是什么？</strong></p>
<p>它是一套专注于微信小程序的企业级开发范式，它的愿景是：</p>
<blockquote>
<p>让企业级的微信小程序项目中的代码，更加简单、漂亮。</p>
</blockquote>
<p><strong>为什么要这样命名呢？</strong></p>
<blockquote>
<p>Write <strong>beautiful</strong> code for <strong>we</strong>chat mini program by the <strong>beautiful</strong> <strong>we</strong>!</p>
</blockquote>
<p>「We」 既是我们的 <strong>We</strong>，也是微信的 <strong>We</strong>，Both beautiful！</p>
<p><strong>那么它有什么卖点呢？</strong></p>
<ol>
<li>专注于微信小程序环境，写原汁原味的微信小程序代码。</li>
<li>由于只专注于微信小程序，它的源码也很简单。</li>
<li>插件化的编程方式，让复杂逻辑更容易封装。</li>
<li>再加上一些配套设施：
<ol>
<li>一些官方插件。</li>
<li>一套开箱即用，包含了工程化、项目规范以及微信小程序环境独特问题解决方案的框架。</li>
<li>一个CLI工具，帮你快速创建应用，页面，组件等。</li>
</ol></li>
</ol>
<p><strong>它由以下几部分组成：</strong></p>
<ul>
<li><strong>一个插件化的核心</strong> - <a href="https://github.com/beautywe/beautywe">BeautyWe Core</a><br />
对 App、Page 进行抽象和包装，保持传统微信小程序开发姿势，同时开放部分原生能力，让其具有「可插件化」的能力。</li>
<li><strong>一些官方插件</strong> — <a href="https://www.npmjs.com/search?q=keywords%3Abeautywe-plugin">BeautyWe Plugins</a><br />
得益于 Core 的「可插件化」特性，封装复杂逻辑，实现可插拔。官方对于常见的需求提供了一些插件：如增强存储、发布/订阅、状态机、Logger、缓存策略等。</li>
<li><strong>一套开箱即用的项目框架</strong> - <a href="https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/contents/framework/introduce">BeautyWe Framework</a><br />
描述了一种项目的组织形式，开箱即用，集成了 <code>BeautyWe Core</code> ，并且提供了如：全局窗口、开发规范、多环境开发、全局配置、NPM 等解决方案。</li>
<li><strong>一个CLI工具</strong> - <a href="https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/remote/cli">BeautyWe Cli</a><br />
提供快速创建应用、页面、插件，以及项目构建功能的命令行工具。并且还支持自定义的创建模板。</li>
</ul>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>下载</p>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式1.png" /></p>
<p>用 BeautyWe 包装你的应用</p>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式2.png" /></p>
<p>之后，你就能使用 BeautyWe Plugin 提供的能力了。</p>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式3.png" /></p>
<h3 id="开放原生apppage支持插件化">开放原生App/Page，支持插件化</h3>
<p><code>new BtApp({...})</code> 的执行结果是对原生的应用进行包装，其中包含了「插件化」的处理，然后返回一个新的实例，这个实例适配原生的 <code>App()</code> 方法。</p>
<p>下面来讲讲「插件化」到底做了什么事情。</p>
<p>首先，插件化开放了原生 App 的四种能力：</p>
<ol>
<li><strong>Data 域</strong><br />
把插件的 Data 域合并到原生 App 的 Data 域中，这一块很容易理解。</li>
<li><strong>原生钩子函数</strong><br />
使原生钩子函数（如 <code>onShow</code>, <code>onLoad</code>）可插件化。让原生App与多个插件可以同时监听同一个钩子函数。如何工作的，下面会细说。</li>
<li><strong>事件钩子函数</strong><br />
使事件钩子函数（与 view 层交互的钩子函数），尽管在实现上有一些差异，但是实现原理跟「原生钩子函数」一样的。</li>
<li><strong>自定义方法</strong><br />
让插件能够给使用者提供 API。为了保证插件提供的 API 足够的优雅，支持当调用插件 API 的时候（如 event 插件 <code>this.event.on(...)</code>)，API 方法内部仍然能通过 <code>this</code> 获取到原生实例。</li>
</ol>
<h4 id="钩子函数的插件化">钩子函数的插件化</h4>
<p>原生钩子函数，事件钩子函数我们统一称为「钩子函数」。</p>
<p>对于每一个钩子函数，内部是维护一个以 Series Promise 方式执行的执行队列。</p>
<p>以 <code>onShow</code> 为例，将会以这样的形式执行：</p>
<blockquote>
<p>native.onShow → pluginA.onShow → pluginB.onShow → ...</p>
</blockquote>
<p><strong>下面深入一下插件化的原理</strong>：</p>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式4.png" /></p>
<p>工作原理是这样的：</p>
<ol>
<li>经过 <code>new BtApp(...)</code> 包装，所有的钩子函数，都会有一个独立的执行队列，</li>
<li>首先会把原生的各个钩子函数 <code>push</code> 到对应的队列中。然后每 <code>use</code> 插件的时候，都会分解插件的钩子函数，往对应的队列 <code>push</code>。</li>
<li>当 <code>Native App</code>（原生）触发某个钩子的时候，<code>BtApp</code> 会以 Promise Series 的形式按循序执行对应队列里面的函数。</li>
<li>特殊的，<code>onLaunch</code> 和 <code>onLoad</code> 的执行队列中，会在队列顶部插入一个初始化的任务（<code>initialize</code>），它会以同步的方式按循序执行 <code>Initialize Queue</code> 里面的函数。这正是插件生命周期函数中的 <code>plugin.initialize</code>。</li>
</ol>
<p>这种设计能提供以下功能：</p>
<ol>
<li>可插件化。<br />
只需要往对应钩子函数的事件队列中插入任务。</li>
<li>支持异步。<br />
由于是以 Promise Series 方式运行的，其中一个任务返回一个 Promise，下一个任务会等待这个任务完成再开始。如果发生错误，会流转到原生的 <code>onError()</code> 中。</li>
<li>解决了微信小程序 <code>app.js</code> 中 <code>getApp() === undefinded</code>问题。<br />
造成这个问题，本质是因为 <code>App()</code> 的时候，原生实例未创建。但是由于 Promise 在 event loop 中是一个微任务，被注册在下一次循环。所以 Promise 执行的时候 <code>App()</code> 早已经完成了。</li>
</ol>
<h3 id="一些官方插件">一些官方插件</h3>
<p>BeautyWe 官方提供了一系列的插件：</p>
<ol>
<li>增强存储: Storage</li>
<li>数据列表：List Page</li>
<li>缓存策略：Cache</li>
<li>日志：Logger</li>
<li>事件发布/订阅：Event</li>
<li>状态机：Status</li>
</ol>
<p>它们的使用很简单，哪里需要插哪里。<br />
由于篇幅的原因，下面挑几个比较有趣的来讲讲，更多的可以看看官方文档：<a href="http://beautywejs.com/">BeautyWe</a></p>
<h4 id="增强存储-storage">增强存储 Storage</h4>
<p>该功能由 <a href="https://github.com/beautywe/plugin-storage">@beautywe/plugin-storage</a> 提供。</p>
<p>由于微信小程序原生的数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。</p>
<p>所以该插件在 <code>wx.getStorage/setStorage</code> 的基础上，提供了两种扩展能力：</p>
<ol>
<li>过期控制</li>
<li>版本隔离</li>
</ol>
<p><strong>一些简单的例子</strong></p>
<p>安装</p>
<pre><code><code>import { BtApp } from &#39;@beautywe/core&#39;;
import storage from &#39;@beautywe/plugin-storage&#39;;

const app = new BtApp();
app.use(storage());</code></pre>
<p>过期控制</p>
<pre><code><code>// 7天后过期
app.storage.set(&#39;name&#39;, &#39;jc&#39;, { expire: 7 })；</code></pre>
<p>版本隔离</p>
<pre><code><code>app.use({ appVersion: &#39;0.0.1&#39; });
app.set(&#39;name&#39;, &#39;jc&#39;);

// 返回 jc
app.get(&#39;name&#39;);

// 当版本更新后
app.use({ appVersion: &#39;0.0.2&#39; });

// 返回 undefined;
app.get(&#39;name&#39;);</code></pre>
<p>更多的查看 <a href="https://github.com/beautywe/plugin-storage">@beautywe/plugin-storage 官方文档</a></p>
<h4 id="数据列表-list-page">数据列表 List Page</h4>
<p>对于十分常见的数据列表分页的业务场景，<code>@beautywe/plugin-listpage</code> 提供了一套打包方案：</p>
<ol>
<li>满足常用「数据列表分页」的业务场景</li>
<li>支持分页</li>
<li>支持多个数据列表</li>
<li>自动捕捉下拉重载：<code>onPullDownRefresh</code></li>
<li>自动捕捉上拉加载：<code>onReachBottom</code></li>
<li>自带请求锁，防止帕金森氏手抖用户</li>
<li>简单优雅的 API</li>
</ol>
<p>一个简单的例子：</p>
<pre><code><code>import BeautyWe from &#39;@beautywe/core&#39;;
import listpage from &#39;@beautywe/plugin-listpage&#39;;

const page = new BeautyWe.BtPage();

// 使用 listpage 插件
page.use(listpage({
    lists: [{
        name: &#39;goods&#39;,  // 数据名
        pageSize: 20,   // 每页多少条数据，默认 10

        // 每一页的数据源，没次加载页面时，会调用函数，然后取返回的数据。
        fetchPageData({ pageNo, pageSize }) {
        
            // 获取数据
            return API.getGoodsList({ pageNo, pageSize })
            
                // 有时候，需要对服务器的数据进行处理，dataCooker 是你定义的函数。
                .then((rawData) =&gt; dataCooker(rawData));
        },
    }],
    enabledPullDownRefresh: true,    // 开启下拉重载， 默认 false
    enabledReachBottom: true,    // 开启上拉加载， 默认 false
}));

// goods 数据会被加载到，goods 为上面定义的 name
// this.data.listPage.goods = {
//     data: [...],     // 视图层，通过该字段来获取具体的数据
//     hasMore: true,   // 视图层，通过该字段来识别是否有下一页
//     currentPage: 1,  // 视图层，通过该字段来识别当前第几页
//     totalPage: undefined,
// }</code></pre>
<p>只需要告诉 <code>listpage</code> 如何获取数据，它会自动处理「下拉重载」、「上拉翻页」的操作，然后把数据更新到 <code>this.data.listPage.goods</code> 下。</p>
<p>View 层只需要描述数据怎么展示：</p>
<pre><code><code>&lt;view class=&quot;good&quot; wx:for=&quot;listPage.goods.data&quot;&gt;
    ...
&lt;/view&gt;
&lt;view class=&quot;no-more&quot; wx:if=&quot;listPage.goods.hasMore === false&quot;&gt;
    没有更多了
&lt;/view&gt;</code></pre>
<p><code>listpage</code> 还支持多数据列表等其他更多配置，详情看：<a href="https://github.com/beautywe/plugin-listpage">@beautywe/plugin-listpage</a></p>
<h4 id="缓存策略-cache">缓存策略 Cache</h4>
<p><code>@beautywe/plugin-cache</code> 提供了一个微信小程序端缓存策略，其底层由 <a href="https://github.com/JerryC8080/super-cache">super-cache</a> 提供支持。</p>
<h5 id="特性">特性</h5>
<ol>
<li>提供一套「服务端接口耗时慢，但加载性能要求高」场景的解决方案</li>
<li>满足最基本的缓存需求，读取（get）和保存（set）</li>
<li>支持针对缓存进行逻辑代理</li>
<li>灵活可配置的数据存储方式</li>
</ol>
<h5 id="how-it-work">How it work</h5>
<p>一般的请求数据的形式是，页面加载的时候，从服务端获取数据，然后等待数据返回之后，进行页面渲染：</p>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式5.png" /></p>
<p>但这种模式，会受到服务端接口耗时，网络环境等因素影响到加载性能。</p>
<p>对于加载性能要求高的页面（如首页），一般的 Web 开发我们有很多解决方案（如服务端渲染，服务端缓存，SSR 等）。<br />
但是也有一些环境不能使用这种技术（如微信小程序）。</p>
<p>Super Cache 提供了一个中间数据缓存的解决方案：</p>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式6.png" /></p>
<p>思路：</p>
<ol>
<li>当你需要获取一个数据的时候，如果有缓存，先把旧的数据给你。</li>
<li>然后再从服务端获取新的数据，刷新缓存。</li>
<li>如果一开始没有缓存，则请求服务端数据，再把数据返回。</li>
<li>下一次请求缓存，从第一步开始。</li>
</ol>
<p>这种解决方案，舍弃了一点数据的实时性（非第一次请求，只能获取上一次最新数据），大大提高了前端的加载性能。<br />
适合的场景：</p>
<ol>
<li>数据实时性要求不高。</li>
<li>服务端接口耗时长。</li>
</ol>
<h5 id="使用">使用</h5>
<pre><code><code>import { BtApp } from &#39;@beautywe/core&#39;;
import cache from &#39;@beautywe/plugin-cache&#39;;

const app = new BtApp();
app.use(cache({
    adapters: [{
        key: &#39;name&#39;,
        data() {
            return API.fetch(&#39;xxx/name&#39;);
        }
    }]
}));</code></pre>
<p>假设 <code>API.fetch('xxx/name')</code> 是请求服务器接口，返回数据：<code>data_from_server</code></p>
<p>那么：</p>
<pre><code><code>app.cache.get(&#39;name&#39;).then((value) =&gt; {
    // value: &#39;data_from_server&#39;  
});</code></pre>
<p>更多的配置，详情看：<a href="https://github.com/beautywe/plugin-cache">@beautywe/plugin-cache</a></p>
<h4 id="日志-logger">日志 Logger</h4>
<p>由 <code>@beautywe/logger-plugin</code> 提供的一个轻量的日志处理方案，它支持：</p>
<ol>
<li>可控的 log level</li>
<li>自定义前缀</li>
<li>日志统一处理</li>
</ol>
<h5 id="使用-1">使用</h5>
<pre><code><code>import { BtApp } from &#39;@beautywe/core&#39;;
import logger from &#39;@beautywe/plugin-logger&#39;;

const page = new BtApp();

page.use(logger({
    // options
}));</code></pre>
<p><strong>API</strong></p>
<pre><code><code>page.logger.info(&#39;this is info&#39;);
page.logger.warn(&#39;this is warn&#39;);
page.logger.error(&#39;this is error&#39;);
page.logger.debug(&#39;this is debug&#39;);

// 输出
// [info] this is info
// [warn] this is warn
// [error] this is error
// [debug] this is debug</code></pre>
<p><strong>Level control</strong></p>
<p>可通过配置来控制哪些 level 该打印：</p>
<pre><code><code>page.use(logger({
    level: &#39;warn&#39;,
}));</code></pre>
<p>那么 <code>warn</code> 以上的 log （<code>info</code>, <code>debug</code>）就不会被打印，这种满足于开发和生成环境对 log 的不同需求。</p>
<p>level 等级如下：</p>
<pre><code><code>Logger.LEVEL = {
    error: 1,
    warn: 2,
    info: 3,
    debug: 4,
};</code></pre>
<p>更多的配置，详情看：<a href="https://github.com/beautywe/plugin-logger">@beautywe/plugin-logger</a></p>
<h3 id="beautywe-framework">BeautyWe Framework</h3>
<p><code>@beautywe/core</code> 和 <code>@beautywe/plugin-...</code> 给小程序提供了：</p>
<ol>
<li>开放原生，支持插件化 —— by core</li>
<li>各种插件 —— by plugins</li>
</ol>
<p>但是，还有很多的开发中实际还会遇到的痛点，是上面两个解决不到的。<br />
如项目的组织、规范、工程化、配置、多环境等等</p>
<p>这些就是，「BeautyWe Framework」要解决的范畴。</p>
<p>它作为一套开箱即用的项目框架，提供了这些功能：</p>
<ul>
<li>集成 BeautyWe Core</li>
<li>NPM 支持</li>
<li>全局窗口</li>
<li>全局 Page，Component</li>
<li>全局配置文件</li>
<li>多环境开发</li>
<li>Example Pages</li>
<li>正常项目需要的标配：ES2015+,sass,uglify,watch 等</li>
<li>以及我们认为良好的项目规范（eslint，commit log，目录结构等）</li>
</ul>
<p>也是由于篇幅原因，挑几个有趣的来讲讲，更多的可以看看官方文档：<a href="http://beautywejs.com/">BeautyWe</a></p>
<h4 id="快速创建">快速创建</h4>
<p>首先安装 <code>@beautywe/cli</code></p>
<pre class="bash"><code>$ npm i @beautywe/cli -g</code></pre>
<h5 id="创建应用">创建应用</h5>
<pre class="bas"><code>$ beautywe new app

&gt; appName: my-app
&gt; version: 0.0.1
&gt; appid: 123456
&gt; 这样可以么:
&gt; {
&gt;    &quot;appName&quot;: &quot;my-app&quot;,
&gt;    &quot;version&quot;: &quot;0.0.1&quot;,
&gt;    &quot;appid&quot;: &quot;123456&quot;
&gt; }</code></pre>
<p>回答几个问题之后，项目就生成了：</p>
<pre class="bash"><code>my-app
├── gulpfile.js
├── package.json
└── src
    ├── app.js
    ├── app.json
    ├── app.scss
    ├── assets
    ├── components
    ├── config
    ├── examples
    ├── libs
    ├── npm
    ├── pages
    └── project.config.json</code></pre>
<h5 id="创建页面组件插件">创建页面、组件、插件</h5>
<p><strong>页面</strong></p>
<ol>
<li>主包页面：<code>beautywe new page &lt;path|name&gt;</code></li>
<li>分包页面：<code>beautywe new page --subpkg &lt;subPackageName&gt; &lt;path|name&gt;</code></li>
</ol>
<p><strong>组件</strong></p>
<ol>
<li><code>beautywe new component &lt;name&gt;</code></li>
</ol>
<p><strong>插件</strong></p>
<ol>
<li><code>beautywe new plugin &lt;name&gt;</code></li>
</ol>
<h5 id="自定义模板">自定义模板</h5>
<p>在 <code>./.templates</code> 目录中，存放着快速创建命令的创建模板：</p>
<pre class="bash"><code>$ tree .templates

.templates
├── component
│   ├── index.js
│   ├── index.json
│   ├── index.scss
│   └── index.wxml
├── page
│   ├── index.js
│   ├── index.json
│   ├── index.scss
│   └── index.wxml
└── plugin
    └── index.js</code></pre>
<p>可以修改里面的模板，来满足项目级别的自定义模板创建。</p>
<h4 id="全局窗口">全局窗口</h4>
<p>我们都知道微信小程序是「单窗口」的交互平台，一个页面对应一个窗口。<br />
而在业务开发中，往往会有诸如这种述求：</p>
<ol>
<li>自定义的 toast 样式</li>
<li>页面底部 copyright</li>
<li>全局的 loading 样式</li>
<li>全局的悬浮控件</li>
</ol>
<p>......</p>
<p>稍微不优雅的实现可以是分别做成独立的组件，然后每一个页面都引入进来。<br />
这种做法，我们会有很多的重复代码，并且每次新建页面，都要引入一遍，后期维护也会很繁琐。</p>
<p>而「全局窗口」的概念是：<strong>希望所有页面之上有一块地方，全局性的逻辑和交互，可以往里面搁。</strong></p>
<h5 id="global-view-组件">global-view 组件</h5>
<p>这是一个自定义组件，源码在 <code>/src/components/global-view</code></p>
<p>每个页面的 wxml 只需要在顶层包一层：</p>
<pre class="html"><code>&lt;global-view id=&quot;global-view&quot;&gt;
    ...
&lt;/global-view&gt;</code></pre>
<p>需要全局实现的交互、样式、组件，只需要维护这个组件就足够了。</p>
<h4 id="全局配置文件">全局配置文件</h4>
<p>在 <code>src/config/</code> 目录中，可以存放各种全局的配置文件，并且支持以 Node.js 的方式运行。（得益于 <a href="https://segmentfault.com/contents/framework/concept/nodejs-power.md">Node.js Power 特性</a>）。</p>
<p>如 <code>src/config/logger.js</code>:</p>
<pre><code><code>const env = process.env.RUN_ENV || &#39;dev&#39;;

const logger = Object.assign({
    prefix: &#39;BeautyWe&#39;,
    level: &#39;debug&#39;,
}, {
    // 开发环境的配置
    dev: {
        level: &#39;debug&#39;,
    },
    // 测试环境的配置
    test: {
        level: &#39;info&#39;,
    },
    // 线上环境的配置
    prod: {
        level: &#39;warn&#39;,
    },
}[env] || {});

module.exports.logger = logger;</code></pre>
<p>然后我们可以这样读取到 config 内容：</p>
<pre><code><code>import { logger } from &#39;/config/index&#39;;

// logger.level 会根据环境不同而不同。</code></pre>
<p>Beautywe Framework 默认会把 config 集成到 <code>getApp()</code> 的示例中：</p>
<pre><code><code>getApp().config;</code></pre>
<h4 id="多环境开发">多环境开发</h4>
<p>BeautyWe Framework 支持多环境开发，其中预设了三套策略：</p>
<ul>
<li>dev</li>
<li>test</li>
<li>prod</li>
</ul>
<p>我们可以通过命令来运行这三个构建策略：</p>
<pre class="bash"><code>beautywe run dev
beautywe run test
beautywe run prod</code></pre>
<h4 id="三套环境的差异">三套环境的差异</h4>
<p>Beautywe Framework 源码默认在两方面使用了多环境：</p>
<ul>
<li>构建任务（<code>gulpfile.js/env/...</code>）</li>
<li>全局配置（<code>src/config/...</code>）</li>
</ul>
<h5 id="构建任务的差异">构建任务的差异</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">构建任务</th>
<th style="text-align: left;">说明</th>
<th style="text-align: left;">dev</th>
<th style="text-align: left;">test</th>
<th style="text-align: left;">prod</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">clean</td>
<td style="text-align: left;">清除dist文件</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
</tr>
<tr class="even">
<td style="text-align: left;">copy</td>
<td style="text-align: left;">复制资源文件</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scripts</td>
<td style="text-align: left;">编译JS文件</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
</tr>
<tr class="even">
<td style="text-align: left;">sass</td>
<td style="text-align: left;">编译scss文件</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
</tr>
<tr class="odd">
<td style="text-align: left;">npm</td>
<td style="text-align: left;">编译npm文件</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
</tr>
<tr class="even">
<td style="text-align: left;">nodejs-power</td>
<td style="text-align: left;">编译Node.js文件</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;">√</td>
</tr>
<tr class="odd">
<td style="text-align: left;">watch</td>
<td style="text-align: left;">监听文件修改</td>
<td style="text-align: left;">√</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">scripts-min</td>
<td style="text-align: left;">压缩JS文件</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">√</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sass-min</td>
<td style="text-align: left;">压缩scss文件</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">√</td>
</tr>
<tr class="even">
<td style="text-align: left;">npm-min</td>
<td style="text-align: left;">压缩npm文件</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">√</td>
</tr>
<tr class="odd">
<td style="text-align: left;">image-min</td>
<td style="text-align: left;">压缩图片文件</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">√</td>
</tr>
<tr class="even">
<td style="text-align: left;">clean-example</td>
<td style="text-align: left;">清除示例页面</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">√</td>
</tr>
</tbody>
</table>
<h5 id="node.js-power">Node.js Power</h5>
<p>Beautywe Framework 的代码有两种运行环境：</p>
<ol>
<li>Node.js 运行环境，如构建任务等。</li>
<li>微信小程序运行环境，如打包到 <code>dist</code> 文件夹的代码。</li>
</ol>
<p><strong>运行过程</strong></p>
<blockquote>
<p>Node.js Power 本质是一种静态编译的实现。<br />
把某个文件在 Node.js 环境运行的结果，输出到微信小程序运行环境中，以此来满足特定的需求。</p>
</blockquote>
<p>Node.js Power 会把项目中 <code>src</code> 目录下类似 <code>xxx.nodepower.js</code> 命名的文件，以 Node.js 来运行，<br />
然后把运行的结果，以「字面量对象」的形式写到 <code>dist</code> 目录下对应的同名文件 <code>xxx.nodepower.js</code> 文件去。</p>
<p>以 <code>src/config/index.nodepower.js</code> 为例：</p>
<pre><code><code>const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

const files = fs.readdirSync(path.join(__dirname));

const result = {};

files
    .filter(name =&gt; name !== &#39;index.js&#39;)
    .forEach((name) =&gt; {
        Object.assign(result, require(path.join(__dirname, `./${name}`)));
    });

module.exports = result;</code></pre>
<p>该文件，经过 Node.js Power 构建之后:</p>
<p><code>dist/config/index.nodepower.js</code>:</p>
<pre><code><code>module.exports = {
    &quot;appInfo&quot;: {
        &quot;version&quot;: &quot;0.0.1&quot;,
        &quot;env&quot;: &quot;test&quot;,
        &quot;appid&quot;: &quot;wx85fc0d03fb0b224d&quot;,
        &quot;name&quot;: &quot;beautywe-framework-test-app&quot;
    },
    &quot;logger&quot;: {
        &quot;prefix&quot;: &quot;BeautyWe&quot;,
        &quot;level&quot;: &quot;info&quot;
    }
};</code></pre>
<p>这就满足了，随意往 <code>src/config/</code> 目录中扩展配置文件，都能被自动打包。</p>
<p>Node.js Power 已经被集成到多环境开发的 dev, test, prod 中去。</p>
<p>当然，你可以手动运行这个构建任务：</p>
<pre class="bash"><code>$ gulp nodejs-power</code></pre>
<h5 id="npm">NPM</h5>
<p>BeautyWe Framework 实现支持 npm 的原理很简单，总结一句话：</p>
<blockquote>
<p>使用 webpack 打包 <code>src/npm/index.js</code> ，以 commonjs 格式输出到 <code>dist/npm/index.js</code></p>
</blockquote>
<p><img src="./images/BeautyWe.js 一套专注于微信小程序的开发范式7.png" /></p>
<p>这样做的好处：</p>
<ol>
<li>实现简单。</li>
<li>让 npm 包能集中管理，每次引入依赖，都好好的想一下，避免泛滥（尤其在多人开发中）。</li>
<li>使用 <code>ll dist/npm/index.js</code> 命令能快速看到项目中的 npm 包使占了多少容量。</li>
</ol>
<h4 id="新增-npm-依赖">新增 npm 依赖</h4>
<p>在 <code>src/npm/index.js</code> 文件中，进行 export：</p>
<pre><code><code>export { default as beautywe } from &#39;@beautywe/core&#39;;</code></pre>
<p>然后在其他文件 import：</p>
<pre><code><code>import { beautywe } from &#39;./npm/index&#39;;</code></pre>
<h3 id="更多">更多</h3>
<p>总的来说，BeautyWe 是一套微信小程序的开发范式。</p>
<p><code>core</code> 和 <code>plugins</code> 扩展原生，提供复杂逻辑的封装和插拔式使用。</p>
<p>而 <code>framework</code> 则负责提供一整套针对于微信小程序的企业级项目解决方案，开箱即用。</p>
<p>其中还有更多的内容，欢迎浏览官网：<a href="http://beautywejs.com/">beautywejs.com</a></p>
<h3 id="关于fundebug">关于Fundebug</h3>
<p><a href="https://www.fundebug.com/">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有阳光保险、核桃编程、荔枝FM、掌门1对1、微脉、青团社等众多品牌企业。欢迎大家免费试用！</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>