<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修DOM学习笔记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>DOM学习笔记</center></div><div class='banquan'>原文出处:本文由博客园博主♪(o∀o)っ提供。<br/>
原文连接:https://www.cnblogs.com/woheni/p/11417572.html</div><br>
    <p><span style="font-size: 16px;"><strong>DOM简介：</strong></span></p>
<p>1、DOM：Document&nbsp; Object&nbsp; Model（简称文档对象模型），是专门用于操作网页内容API一套标准！网页内容：字符、图片等各种资源</p>
<p>2、核心DOM：操作一切结构化文档的API标准！特点：强大，万能；缺点：操作繁琐。</p>
<p>3、HTML&nbsp; DOM：专门操作HTML网页的API标准--针对核心DOM中部分API进行了简化！优点：操作相对简化；缺点：非万能。</p>
<p>4、对比：实际开发中HTML&nbsp; DOM使用频率相对较高，只有当HTML&nbsp; DOM无法实现某些功能时才会使用核心DOM。</p>
<p>5、DOM树：网页中一切内容都在内存中以树状结构存储，每项内容都在这个树上有一个节点。每个DOM树都有一个根节点：document节点。</p>
<p>6、节点对象：DOM上每一个节点，都是一个节点对象，提供了操作节点的API。</p>
<p><strong><span style="font-size: 16px;">节点对象的属性：</span></strong></p>
<p>1、nodeType：保存着节点的类型名！--不能明确获知节点名称</p>
<p>2、nodeName：保存节点的名称！--区分不同元素</p>
<p>3、nodeValue：保存元素的值！</p>
<p>正式操作DOM：增删改查！　　操作流程：获取能够操作的元素--目标元素--绑定事件--获取需要操作的元素--事件具体操作</p>
<p><span style="font-size: 16px;"><strong>查找/获取：</strong></span></p>
<p>html中不需要获取直接使问的元素：</p>
<p>　　document.documentElement　　==&gt;html</p>
<p>　　document.head　　==&gt;head</p>
<p>　　document.body　　==&gt;body</p>
<p>1、按照节点之间的层级关系：如果已经获取到一个元素，想找其周围元素</p>
<p>　　1&gt;父子级：</p>
<p>　　&nbsp; &nbsp; &nbsp;child.parentNode：获取父节点--返回父节点</p>
<p>　　　&nbsp; parent.childNodes：获取字节的--可以返回多个</p>
<p>　　　&nbsp; parent.firstchild：获取父节点中第一个字节点</p>
<p>　　　&nbsp; parent.lastchild：获取父节点中最后一个字节点</p>
<p>　　2&gt;兄弟级：</p>
<p>　　　 elem.nextsibling：获取下一个兄弟节点</p>
<p>　　　&nbsp;elem.previoussibling：获取上一个兄弟节点</p>
<p>　　问题：容易受到空字符影响！</p>
<p>&nbsp;2、解决方案：元素树：只包含元素的树状结构。元素树并非新的一个树，只是DOM树结构的一部分</p>
<p>　　1&gt;父子级：</p>
<p>　　　 child.parentElement：获取父节元素--返回父级元素</p>
<p>　　　 parent.chidren：获取子元素--可以返回多个</p>
<p>　　　 parent.firstElementchild：获取父元素中第一个子元素</p>
<p>　　　 parent.lastElementchild：获取父元素中最后一个子元素</p>
<p>　　2&gt;兄弟级：</p>
<p>　　　 elem.nextElementSibling：获取下一个兄弟元素</p>
<p>　　　 elem.previousElementSibling：获取上一个兄弟元素</p>
<p><strong>遍历节点数/元素树</strong></p>
<p><strong>方式1：递归</strong></p>
<p>步骤：定义一个方法，查找一个父节点下面所有的子节点--对遍历到的每个字节，再执行与父节点相同的方法。</p>
<p>步骤：定义一个方法，传入一个节点对象，获取并遍历每一个子节点</p>
<p>function iterator(elem){</p>
<p>　　var children=elem.childNodes;</p>
<p>　　for (var i=0;i&lt;children.length;i++co) {</p>
<p>　　　　console.log("当前节点类型是："+elem[i].nodeType);</p>
<p>　　　　console.log("当前节点名称是："+elem[i].nodeName);</p>
<p>　　}</p>
<p>}</p>
<p>注意：递归的使用效率很低，不介意使用！</p>
<p><strong>方式2：使用节点迭代对象</strong></p>
<p>步骤1、创建一个节点迭代对象：var iteartor=document.createNodeIterator(parent,NodeFilter.SHOW_ALL,null,false);</p>
<p>步骤2、反复调用iterator的nextNode()</p>
<p>作用：返回当前遍历到的节点；自动跑到下一个节点；自动返回null退出。</p>
<p><strong>类数组对象</strong>：长得像数组，但不是数组</p>
<p><strong>动态集合：</strong>不实际存储值，每次访问都会重新去查找DOM树！</p>
<p>问题： 每次循环判断时都会去查找DOM树，浪费性能</p>
<p>处理：在判断之前，事先保存值。</p>
<p><span style="font-size: 16px;"><strong>操作DOM的步骤：</strong></span></p>
<p>1、获取目标元素</p>
<p>2、绑定事件：再获取的元素对象上使用</p>
<p>　　elem.on事件名=function () {</p>
<p>　　　　3、获取需要操作的元素</p>
<p>　　　　4、操作元素</p>
<p>}</p>
<p><span style="font-size: 16px;"><strong>查找元素的内容</strong></span></p>
<p>1、按照父子级和兄弟关系查找节点/元素</p>
<p>2、按照HTML特性查找</p>
<p>　　1&gt;根据元素的IDs属性查找：var elem=document.getElementById("ID值");　</p>
<p>　　　　注意：只能通过document调用；只能返回一个元素!</p>
<p>　　2&gt;根据元素的标记名查找：var elems=parent.getElementByTagName("标记名");</p>
<p>　　　　注意：返回一个类数组的动态集合；可以通过任意父节元素调用；查找不限层级！</p>
<p>　　3&gt;根据元素的name属性查找：var elems=document.getElementsByName("name属性值");</p>
<p>　　　　注意：返回一个类数组的动态集合；只能用document调用！</p>
<p>　　4&gt;根据元素的class属性查找：var elems=parent.getElementsByClassName("class值");</p>
<p>　　　　注意：返回一个类数组的动态集合；可以通过任意父级元素调用；查找不限层级；只要元素包含指定的class取值即可！</p>
<p>3、根据css选择器查找元素--重要</p>
<p>　　1&gt;查找一个元素：var elem=parent.querySelector("选择器");</p>
<p>　　2&gt;查找多个元素：var elems=parent.querySelectorAll("选择器");</p>
<p>注意：</p>
<p>1、以上两个API返回的不是动态集合，即使反复访问也不会反复查找DOM。</p>
<p>2、在低版本的浏览器中，不支持此类API。</p>
<p>总结：</p>
<p>1、已经获取了一个元素，想查找附近的元素--通过元素之间的关系查找</p>
<p>2、如果只知道一个条件，想获取元素--通过html特性查找</p>
<p>3、如果条件比较复杂--通过选择器查找</p>
<p><span style="font-size: 16px;"><strong>修改元素的内容</strong></span></p>
<p>1、.innerHTML：获取/修改元素中内容区域的内容</p>
<p>内容区域：从起始标记到结束标记之间的区域</p>
<p>取值：elem.innerHTML　　//获取元素elem的内容区域的内容</p>
<p>赋值：elem.innerHTML="新值";</p>
<p>注意：此API赋值的内容，浏览器会当作html代码解析！</p>
<p>2、.textContent：获取/修改元素elem的内容标记内的文本</p>
<p>取值：elem.textContent</p>
<p>赋值：elem.textContent="新值";</p>
<p>注意：此API赋值的内容，浏览器不会解析特殊字符，就是普通文本</p>
<p>3、.value：获取表单元素的value属性值</p>
<p>获取：var style1=elem.style.属性名；</p>
<p>修改：elem.style.属性名=值；</p>
<p>套路：可以将需要的样式设置在一个类中，通过修改class属性引入这个类。</p>
<p>　　elem.className="类名";</p>
<p><span style="font-size: 16px;"><strong>DOM操作属性</strong></span></p>
<p>1、标准属性：所有元素都支持的属性（id，name，class，title，style......）,HTML标准中指定的属性----w3c</p>
<p>2、核心DOM中的API：</p>
<p>　　1&gt;获取一个元素指定的属性：elem.getAttribute("属性名");</p>
<p>　　2&gt;修改一个元素指定属性的值：elem.setAttribute("属性名"，"新值");</p>
<p>　　3&gt;判断一个元素是否具有指定属性：elem.hasAttribute("属性名");</p>
<p>　　4&gt;移除一个元素指定的属性：elem.removeAttribute("属性名");</p>
<p>　　　注意：不仅将属性值删除，属性名也会删除。</p>
<p><strong><span style="font-size: 16px;">HTML DOM操作属性</span></strong></p>
<p>在HTML DOM中，已经将元素支持的标准属性封装在家元素对象中，可以通过 . 之间访问！</p>
<p>1、获取属性：elem.属性名；</p>
<p>2、修改/添加：elem.属性名="值";</p>
<p>3、判断：elem.属性名！=="";</p>
<p>4、删除：elem.属性名="";</p>
<p><span style="font-size: 16px;"><strong>操作页面的元素</strong></span></p>
<p>添加一个元素：</p>
<p>1&gt;创建一个元素：var elem=document.createElement("新元素");</p>
<p>2&gt;添加必要的属性和内容：elem.属性名1=值；elem.属性名2=值；elem.innerHTML="百度一下";</p>
<p>3&gt;将创建的新元素追加到DOM树中指定的父节点下！</p>
<p>　　1、在父元素的末尾追加新元素：parent.appendChild(elem);</p>
<p>　　2、中间插入：将新元素插入到兄弟元素之间：parent.insertBefore(elem，兄弟元素);</p>
<p>　　3、替换：parent.replace(elem，被替换的元素);</p>
<p><span style="font-size: 16px;"><strong>DOM操作元素</strong></span></p>
<p>如果进行了DOM操作元素，网页将重新layout。如果频繁的操作DOM，会造成性能浪费。</p>
<p>解决方法：如果需要向父节点中追加多个字节点，可以先将需要添加的子元素先保存在一个虚拟的临时父节点下。最后一次性将所有字节点追加到DOM中真实父节点下！</p>
<p>　　步骤1：创建多个子节点：var zhy1=document.createElement("a");var zhy2=document.createElement("b");</p>
<p>　　步骤2：创建虚拟父节点：var frag=document.createElementFragment();</p>
<p>　　步骤3：将子节点追加到虚拟父节点：frag.appendChild(zhy1);frag.appendChild(zhy2);</p>
<p>　　步骤4：最后将虚拟父节点追加到真正的父节点中：parent.appendChild(frag);</p>
<p>注意：将临时节点追加到DOM中，临时的片段frag会被释放，真正追加到DOM的只有那些子元素！</p>
<p><span style="font-size: 16px;"><strong>HTML DOM简化操作</strong></span></p>
<p>&nbsp;在操作常见的HTML元素时，HTML DOM提供了一些简化操作。包括了img，select，option，table/行分组/tr/td，from</p>
<p>1、img：var img=new Image();</p>
<p>2、select：value；selectdIndex；option；length</p>
<p>　　解析：value：获取被选中的选项的value值；selectedIndex：获取当前被选中的选择的下标；option：获取内部所有的option元素集合；length：获取option所得集合的长度。</p>
<p>3、option：var opt=new Option();</p>
<p>4、table：外层的table管着行分组（thead，tbody，tfoot）；</p>
<p>5、创建行分组：已经获取到table元素，可以直接调用table创建行分组元素</p>
<p>　　var thead=table.createTHead();</p>
<p>　　var tbody=table.createTBody();</p>
<p>　　var tfoot=table.createTFoot();</p>
<p>6、删除行分组：调用table删除内部的行分组，注意只能删表头和表尾。</p>
<p>　　table.deleteTHead();</p>
<p>　　table.deleteTFoot();</p>
<p>7、获取表格中的行分组：可以有多个表主体。</p>
<p>　　table.tHead;</p>
<p>　　table.tBodies;</p>
<p>　　table.tFoot;</p>
<p>8、行分组控制行</p>
<p>　　创建行：行分组　insertRow(i);</p>
<p>　　删除行：行分组.deleteRow(i);</p>
<p>　　获取行：行分组.Rows;</p>
<p>9、行分组控制列</p>
<p>　　创建列：tr.insertCell(i);</p>
<p>　　删除列：tr.deleteCell(i);</p>
<p>　　获取列们：tr.Cells;</p>
<p>10、from：获取页面上的from元素：</p>
<p>　　document.from；获取页面元素中的表单元素</p>
<p>　　document.forms[i/id]；根据表单的序号，或者id值获取对应表单！</p>
<p>　　from.elements；获取表单中所有的表单元素！</p>
<p>　　返回一个类数组对象，具有length和下标！</p>
<p><strong><span style="font-size: 14pt;">花了半天的时间总结的DOM笔记，不足之处请多多指教！完结！</span></strong></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>