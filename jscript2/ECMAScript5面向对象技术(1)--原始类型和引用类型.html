<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ECMAScript5面向对象技术(1)--原始类型和引用类型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ECMAScript5面向对象技术(1)--原始类型和引用类型</center></div><div class='banquan'>原文出处:本文由博客园博主Maxwell0811提供。<br/>
原文连接:https://www.cnblogs.com/maxwell0811/p/11189528.html</div><br>
    <h1 id="概述">概述</h1>
<blockquote>
<ul>
<li><p>大多数开发者在使用Java或C#等基于类的语言的过程中学会了面向对象编程。由于JavaScript没有对类的正式支持，这些开发者在学习JavaScript时往往会迷失方向；</p></li>
<li><p><strong>JavaScript不需要在开头就定义好各种类，你可以在写代码的过程中根据需要创建数据结</strong>；</p></li>
<li><p><strong>由于JavaScript缺少类，也就缺少用于对类进行分组的包</strong>；</p></li>
<li><p>JavaScript把对象作为语言的中心，几乎所有JavaScript的数据要么是一个对象要么从对象中获取；</p></li>
<li><p>在JavaScript中也被视为对象，这使得它们成为JavaScript的一等公民；</p></li>
<li><p>用和理解对象是理解整个Javascript的关键，在学习之前，首先要学习鉴别和使用两种JavaScript基本数据类型：<strong><em>原始类型和引用类型</em></strong>。</p></li>
</ul>
</blockquote>
<h1 id="什么是类型">什么是类型</h1>
<blockquote>
<ul>
<li><p>JavaScript虽然没有类的概念，但依然存在两种类型：<strong>原始类型和引用类型</strong>；</p></li>
<li><p><strong>原始类型</strong>保存为简单数据值；</p></li>
<li><p><strong>引用类型</strong>保存为对象，其本质是指向内存位置的引用；</p></li>
<li><p>其他编程语言使用栈存储原始类型，用堆存储引用类型，JavaScript完全不同：它使用一个<strong>变量对象</strong>追踪变量的生存期；</p></li>
<li><p><strong>原始值被直接保存在变量对象内，引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置</strong>。</p></li>
</ul>
</blockquote>
<h1 id="原始类型">原始类型</h1>
<blockquote>
<p>JavaScript共有5种原始类型：</p>
<ul>
<li><code>boolean</code> 布尔，值为true或false</li>
<li><code>number</code> 数字，值为任何整型或浮点数值<br />
</li>
<li><code>string</code> 字符串，值为单引号或双引号括出的单个字符或连续字符</li>
<li><code>null</code> 空类型</li>
<li><code>undefined</code> 未定义</li>
</ul>
<p>JavaScript和许多其他语言一样，原始类型的变量直接保存原始值。当你将原始值赋给一个变量时，该值将复制到变量中。也就是说，如果你使一个变量等于另一个时，每个变量有它自己的一份数据拷贝。</p>
<pre><code><code>var c1 = &quot;red&quot;;
var c2 = c1;</code></pre>
<p><img src="./images/ECMAScript5面向对象技术(1)--原始类型和引用类型0.png" /></p>
<p>每个含有原始值的变量使用自己的存储空间，一个变量的改变不会影响到其他变量。</p>
<pre><code><code>var c1 = &quot;red&quot;;
var c2 = c1;

console.log(c1); //&quot;red&quot;
console.log(c2); //&quot;red&quot;

c1 = &quot;blue&quot;;

console.log(c1); //&quot;blue&quot;
console.log(c2); //&quot;red&quot;</code></pre>
<h2 id="鉴别原始类型">鉴别原始类型</h2>
<p>鉴别原始类型的最佳方法是使用typeof操作符。</p>
<pre><code><code>console.log(typeof &quot;Hello&quot;);  //&quot;string&quot;
console.log(typeof 100);      //&quot;number&quot;
console.log(typeof 10.5);     //&quot;number&quot;
console.log(typeof true);     //&quot;boolean&quot;
console.log(typeof undefined);    //&quot;undefined&quot;
console.log(typeof null)      //&quot;object&quot;</code></pre>
<p>当运行<code>typeof null</code>时，结果是object。这实际上是一个错误，判断一个值是否为空类型的最佳方法是直接和null比较。</p>
<pre><code><code>console.log(value === null); //true or false</code></pre>
<h2 id="原始方法">原始方法</h2>
<ul>
<li><strong><em>虽然string，number，boolean是原始类型，但是它们也拥有方法；</em></strong></li>
<li><strong><em>尽管原始类型拥有方法，但它们不是对象；</em></strong></li>
<li><strong><em>JavaScript使它们看上去像对象一样，以此来提供语言上的一致性体验。</em></strong></li>
</ul>
<pre><code><code>var name = &quot;Tom&quot;;
var firsetLetter = name.chrAt(0); //get first character
var lowercaseName = name.toLowerCase(); //convert to lowercase</code></pre>
</blockquote>
<h1 id="引用类型">引用类型</h1>
<blockquote>
<ul>
<li>引用类型是指JavaScript中的对象，同时也是在JavaScript中能找到的最接近类的东西；</li>
<li>引用值是引用类型的实例，也是对象的同义词；</li>
<li>对象是属性的无序列表；</li>
<li>属性包含键和值；</li>
<li>如果一个属性的值是函数，它就被称为方法；</li>
<li>在使用对象前，必须先创建他们。</li>
</ul>
<h2 id="创建对象">创建对象</h2>
<ul>
<li><p>JavaScript有好几种方式可以创建对象，或者说实例化对象；</p></li>
<li><p>第一种是使用<code>new</code>操作符和构造函数；</p></li>
<li><p>构造函数是通过<code>new</code>操作符来创建对象的函数，一般首字母大写，下列代码实例化一个<strong>通用对象</strong>；</p></li>
</ul>
<pre><code><code>var object = new Object(); //实例化一个通用对象</code></pre>
<ul>
<li><p>引用类型不在变量中直接保存对象，所以上面例子中object变量实际上并不包含对象的实例，而是一个指向内存中实际对象所在位置的指针（或者说引用）；</p></li>
<li><p>当将一个对象赋值给变量时，实际是赋值给这个变量一个指针。这意味着，将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的同一个对象。</p></li>
</ul>
<h2 id="对象引用解除">对象引用解除</h2>
<p>不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。<strong><em>解除引用的最佳手段是将对象变量置为null。</em></strong></p>
<pre><code><code>var obj = new Object();
obj = null; // 解除引用</code></pre>
<h2 id="添加删除属性">添加删除属性</h2>
<p>在JavaScript中，可以在对象中随时添加和删除其属性。</p>
<pre><code><code>var obj1 = new Object();
var obj2 = obj1;

obj1.myProperty = &quot;aaa&quot;;
console.log(obj2.myProperty); //&quot;aaa&quot;</code></pre>
<p>上面的例子演示了JavaScript一个独特的方面：可以随时修改对象，即使并没有在开始时定义它们。同时，后续会讲到如何阻止此类修改。</p>
</blockquote>
<h1 id="内建类型实例化">内建类型实例化</h1>
<blockquote>
<p>我们已经见过如何用<code>new Object()</code>创建和使用通用对象。Object类型只是JavaScript提供的少量内建类型之一。其他内建类型各有它们的特殊用途，可在任何时候被实例化。</p>
<ul>
<li><code>Array</code> 数组类型，以数字为索引的一组值的有序列表<br />
</li>
<li><code>Date</code> 日期和时间类型</li>
<li><code>Error</code> 运行期错误类型</li>
<li><code>Function</code> 函数类型</li>
<li><code>Object</code> 通用对象类型</li>
<li><code>RegExp</code> 正则表达式类型</li>
</ul>
<p>可以用<code>new</code>来实例化每一个内建引用类型。</p>
<h2 id="字面形式">字面形式</h2>
<p>内建引用类型有字面形式。字面形式允许你在不需要使用<code>new</code>操作符和构造函数显式创建对象的情况下生成引用值（<strong>言外之意就是：除了使用<code>new</code>构造函数创建对象还有一种字面形式的方式创建对象</strong>）。</p>
<h2 id="对象和数组字面形式">对象和数组字面形式</h2>
<ul>
<li><p>要用<strong>对象</strong>字面形式创建对象，可以在大括号内定义一个新对象及其属性；</p></li>
<li><p>属性的组成包括一个标识符或字符串、一个冒号及一个值；</p></li>
<li><p>多个属性之间用逗号分隔；</p></li>
</ul>
<pre><code><code>var book = {
 name:&quot;JavaScript教程&quot;,
 year:&quot;2019&quot;,
 price:34.5
}</code></pre>
<ul>
<li>属性名字也可以用字符串表示，特别是当你希望名字中包含空格或其他特殊字符时；</li>
</ul>
<pre><code><code>var book = {
 &quot;name&quot;:&quot;JavaScript教程&quot;,
 &quot;year&quot;:&quot;2019&quot;,
 &quot;price&quot;:34.5
}</code></pre>
<p>上面两个例子的等价写法</p>
<pre><code><code>var book = new Object();
book.name = &quot;JavaScript教程&quot;;
book.year = &quot;2019&quot;;
book.price = 34.5;</code></pre>
<ul>
<li>定义数组的字面形式是在中括号内用逗号区分任意数量的值。</li>
</ul>
<pre><code><code>var colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
console.log(colors[0]); //&#39;red&#39;</code></pre>
<p>等价于</p>
<pre><code><code>var colors = new Array(&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;);
console.log(colors[0]);</code></pre>
<h2 id="函数字面形式">函数字面形式</h2>
<ul>
<li><p>通常都要用函数的字面量来定义函数；</p></li>
<li><p>考虑到可维护性、易读性和调试上的巨大挑战，通常不会有人使用函数的构造函数。</p></li>
</ul>
<pre><code><code>function fun(value) {
 return value;
}

//is same as
var fun = new Function(&quot;value&quot;, &quot;return value;&quot;);</code></pre>
</blockquote>
<h1 id="访问属性">访问属性</h1>
<blockquote>
<ul>
<li><p>属性是对象中保存的名字和值的配对；</p></li>
<li><p><code>.</code>是JavaScript中访问属性的最通用做法；</p>
<pre><code><code> var arr = [];
 arr.push(1000);</code></pre></li>
<li><p>也可以使用中括号访问JavaScript属性。</p>
<pre><code><code> var arr = [];
 arr[&quot;push&quot;](1000);</code></pre></li>
</ul>
</blockquote>
<h1 id="鉴别引用类型">鉴别引用类型</h1>
<blockquote>
<ul>
<li><p>函数使用<code>typeof</code>操作符时，返回值是<code>function</code>;</p></li>
<li><p>非函数的引用<code>typeof</code>操作符时，返回值是<code>object</code>；</p></li>
<li><p>为了更方便的鉴别引用类型，使用<code>instanceof</code>操作符；</p>
<blockquote>
<p><code>对象的引用 instanceof 构造函数</code></p>
<p>对象是构造函数所指定的类型的一个实例，<code>instanceof</code>返回<code>true</code>;</p>
<p>否则返回<code>false</code>。</p>
</blockquote></li>
</ul>
<pre><code><code>var items = [];
var object = {};

function fun(val) {
      return val;
}

console.log(items instanceof Array);  //true
console.log(object instanceof Object);    //true
console.log(fun instanceof Function); //true</code></pre>
<ul>
<li><code>instanceof</code>操作符可鉴别继承类型，这意味着所有对象都是Object的实例，因为所有引用类型都继承自Object。</li>
</ul>
<pre><code><code>var items = [];
var object = {};
  
function fun(val) {
   return val;
}
  
console.log(items instanceof Object); //true
console.log(object instanceof Object);    //true
console.log(fun instanceof Object);   //true</code></pre>
<p>​ 每种引用类型的对象都被正确鉴别为Object的实例。</p>
</blockquote>
<h1 id="鉴别数组">鉴别数组</h1>
<blockquote>
<p>除了<code>instanceof</code>可以鉴别数组，ECMAScript5引入了<code>Array.isArray()</code>来明确鉴别一个值是否为Array的实例。</p>
</blockquote>
<h1 id="原始封装类型">原始封装类型</h1>
<blockquote>
<ul>
<li>原始封装类型共有3种（<code>String</code>、<code>Number</code>、<code>Boolean</code>），这三种是引用类型;</li>
<li>这些引用类型使得原始类型用起来和对象一样方便（类似于Java中的包装类）；</li>
<li>当读取字符串、数字或布尔值时，原始封装类型将被<strong>自动创建</strong>；</li>
</ul>
<pre><code><code>var name = &quot;Tom&quot;;
var firstChar = name.charAt(0);
console.log(firstChar);</code></pre>
<p>​​ 等价于</p>
<pre><code><code>var name = &quot;Tom&quot;;
var temp = new String(name);
var firstChar = temp.charAt(0);
temp = null;
console.log(firstChar);</code></pre>
<ul>
<li>手动创建的原始封装类型在其他地方很容易让人误解，在大多数情况下都只会导致错误。多数情况下，应避免使用原始封装类型。</li>
</ul>
</blockquote>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>