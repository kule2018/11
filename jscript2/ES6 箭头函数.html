<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ES6 箭头函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ES6 箭头函数</center></div><div class='banquan'>原文出处:本文由博客园博主张最棒提供。<br/>
原文连接:https://www.cnblogs.com/jiaobaba/p/11847838.html</div><br>
    <p><img src="./images/ES6 箭头函数0.png" alt="" />&nbsp;<img src="./images/ES6 箭头函数1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋; font-size: 18px;">&nbsp;非箭头函数与箭头函数的写法</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">//非箭头函数写法，函数声明<br />function sum(a, b) {
    return a + b;
}<br />//非箭头函数写法，函数表达式
var sum = function(a,b){
    return a+b;
}<br />//箭头函数写法 把箭头函数赋给一个变量，省略function，（）括号里面是参数，当参数是一个时,（）括号可省略<br /></span>let sum = (a, b) =&gt; {</pre>
<div>
<div>　　&nbsp; return a + b;</div>
<div>&nbsp;}</div>
</div>
</div>
<p><span style="font-family: 仿宋; font-size: 18px;">省略不写return ，仍有返回值，可返回数组，对象，函数。。。</span></p>
<p><span style="font-family: 仿宋; font-size: 18px;">写法：去掉大括号，直接把要返回的值写到箭头的后面，但当返回对象是，{name:'zwq'}会被当成一个箭头函数的{}，所以，当返回对象时，可用表达式包裹上。</span></p>
<div class="cnblogs_code">
<pre><code>let sum = (a, b) =&gt;  a + b;   //返回 a+b</pre>
<div>　let fn = (a, b) =&gt; ({ a: a, b: b });</div>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋; font-size: 18px;">使用箭头函数简化代码，如下代码</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">function sum(x) {
    return function (y) {
        return function (z) {
            return x + y + z;
        }
    }
}
var sum1 = sum(1);
var sum2 = sum(2);
console.log(sum2(3));</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋; font-size: 18px;">可以写成：箭头函数可以省略return ，并把大括号去掉，参数是一个的时候也可以去掉。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">let sum = x =&gt; y =&gt; z =&gt;  x + y +</span> z

console.log(sum(1)(2)(3));</pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋; font-size: 18px;">参数不能重复命名</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">function sum(a,a){
    console.log(a);    //不报错
}
let sum  = (a,a) =&gt;{
    console.log(a);    //报错
}</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">箭头函数不能new，并且没有原型</span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">let Person = () =&gt; {
    this.a = 10;
}
new Person();   <span style="color: #ff0000;">// Uncaught TypeError: Person is not a constructor</span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">箭头函数的arguments和this的值是外围最近一层非箭头函数的arguments和this值。是词法作用域下，也就是说是你写代码时你眼睛直观看到的。即使这个函数执行时被保存到外部。</span></span></p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">如下代码箭头函数外部没有非箭头函数，所以没有arguments。</span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">let a = (x,y) =&gt;{
    console.log(arguments);  //<span style="color: #ff0000;">Uncaught ReferenceError: arguments is not defined</span>
}
a(3,4);</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">当前箭头函数外面套着非箭头函数，不管执行时函数是否保存到外部，只是当前肉眼看到的词法作用域，当前里面的箭头函数外面套着非箭头函数，所以可以拿到外部非箭头函数的arguments.</span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">function fn(a,b){
    return (x,y) =&gt;{
        console.log(arguments,x,y);
    }
}
fn(3,4)(5,6);    //[3,4] 5 6</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">例如有这样的需求。我们定义一个函数fn()并且在fn里面定义了其他函数,在这个函数里面需要接受fn函数的参数，当传入参数不固定时，我们接受arguments，但是每个函数的arguments都是自己函数的参数的arguments，我们需要外部函数的arguments只能用一个变量先保存起来。</span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">function fn(){
   // var a = arguments;
    return function(){<br />　　　　　console.log(a);   //[3,4]
        console.log(arguments)  //一个空的arguments
    }
}
fn(3,4)();</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">这是箭头函数的特点，箭头函数的arguments只能由外部非箭头函数的arguments决定</span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">function fn(){
    return () =&gt;{
        console.log(arguments);
    }
}
fn(3,4)();   //[3,4]   </span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">this指向问题</span></span></p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">普通函数的this，谁调用它，他就指向谁。 如下打印的是对象里的innerObj；</span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">var  a = 'outObj';   
var  obj = {
    a:'innerObj',
    fn:function(){ 
        console.log(this.a);   //innerObj
    }
}
obj.fn();</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋;"><span style="font-size: 18px;">箭头函数的this跟arguments一样是外围离自己最近一层的非箭头函数，当箭头函数外面没有非箭头函数时，this指向window</span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">var  a = 'outObj';   //注意 变量声明不能用let。</span>如果用let a 的话会打印undefined，因为当前this指向全局，但通过let定义的属性不会定义成window属性</pre>
<pre><code><em><span style="color: #000000;">let obj = {
    a:'innerObj',
    fn:()=&gt;{ 
        console.log(this.a);   //  outObj因为this和arguments的值取决于外面最近一层的非箭头函数，而当前的箭头函数外面没有箭头函数所以this绑定在全局上。
    }
}
obj.fn();<br /><br />如果想打印对象obj里面的属性需要在箭头函数外面套一个非箭头函数<br /></span></em></pre>
<div>
<div>　　let obj = {</div>
<div>　　　　a:'innerObj',</div>
<div>　　　　fn(){</div>
<div>　　　　　　let sum = () =&gt;{</div>
<div>　　　　　　　　console.log(this.a);&nbsp; &nbsp;//innerObj</div>
<div>　　　　　　}</div>
<div>　　　　　　sum()</div>
<div>　　　　}</div>
<div>　　}</div>
</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">将变量返回到外部也是一样<br />let obj = {
    a:'innerObj',
    fn(){
        let sum = () =&gt;{
            console.log(this.a);   //innerObj
        }
        return sum;
    }
}
let outerSum = obj.fn();</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋; font-size: 18px;">当用普通函数是使用settimeout，由于没有对象调用settimeout里面的函数，因此他指向的window。利用保存外部函数this，或者用call改变this指向来改变this。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">let obj = {
    ms:'abx',
    fn(){
            var self = this;
        　　 setTimeout(function(){
           　　  console.log(this.ms);   
             　　console.log(self.ms);   或者改变this指向  
       　　 },500)
    }
}
obj.fn();</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 仿宋; font-size: 18px;">使用箭头函数解决this指向问题</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">let obj = {
    ms:'abc',
    fn(){
        setTimeout(() =&gt; {
            console.log(this.ms);  //abc
        }, 500);
    }
}
obj.fn();</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>