<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ES6之箭头函数深入理解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ES6之箭头函数深入理解</center></div><div class='banquan'>原文出处:本文由博客园博主盗将行提供。<br/>
原文连接:https://www.cnblogs.com/wangjie-nf/p/10939704.html</div><br>
    <h3><span style="font-size: 18px; font-family: 'Microsoft YaHei';">相对于普通函数的区别</span></h3>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">新的书写方式&nbsp;</span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">this 的改变</span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">不能当构造函数</span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">没有 prototype 属性</span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px;"><span style="font-family: 'Microsoft YaHei';">没有 arguments 对象</span></span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<h3><span style="font-size: 18px; font-family: 'Microsoft YaHei';">新的书写方式</span></h3>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">书写方式很简单！直接看下图，</span></p>
<div style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">常规方式写一个函数</span></div>
<div style="margin-left: 30px;">
<div class="cnblogs_code">
<pre><code><span style="font-size: 13px;">const fun = <span style="color: #0000ff;">function</span><span style="color: #000000;">(number){
    </span><span style="color: #0000ff;">return</span> number * 2<span style="color: #000000;">
}</span></span></pre>
</div>
</div>
<div style="margin-left: 30px;">&nbsp;</div>
<div style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">使用箭头函数</span></span>
<div class="cnblogs_code">
<pre><code><span style="font-size: 13px;">const fun = (number) =&gt;<span style="color: #000000;"> {
    </span><span style="color: #0000ff;">return</span> number * 2<span style="color: #000000;">
}</span></span></pre>
</div>
</div>
<div style="margin-left: 30px;">&nbsp;</div>
<div style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">如果只有一个参数，还可以省略前面的小括号</span></div>
<div style="margin-left: 30px;">
<div class="cnblogs_code">
<pre><code><span style="font-size: 13px;">const fun = number =&gt;<span style="color: #000000;"> {
    </span><span style="color: #0000ff;">return</span> number * 2<span style="color: #000000;">
}</span></span></pre>
</div>
</div>
<div style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">&nbsp;</span></div>
<div style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">如果只有一条执行语句，甚至可以省略后面的大括号，而且可以也不能写 return</span></span>
<div class="cnblogs_code">
<pre><code><span style="font-size: 13px;">const fun = number =&gt; number * 2 </span></pre>
</div>
</div>
<div style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">&nbsp;</span></div>
<div style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">也可以写成立即执行函数</span></span>
<div class="cnblogs_code">
<pre><code><span style="font-size: 13px;">const fun = (() =&gt; 3 * 2)()  <span style="color: #008000;">//</span><span style="color: #008000;"> 6</span></span></pre>
</div>
</div>
<div style="margin-left: 30px;">
<p><span style="font-size: 15px; font-family: 'Microsoft YaHei';">&nbsp;</span></p>
</div>
<div>
<h3><span style="font-size: 18px; font-family: 'Microsoft YaHei';">this的改变</span></h3>
<p style="margin-left: 30px;"><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>执行上下文</strong></span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">讨论箭头函数的 this 之前，不得不再熟悉一下 <span style="color: #ff6600;">执行上下文</span>（Execution Context）,因为 this 指针(this value) 就存储在执行上下文中。</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">执行上下文保存着函数执行所需的重要信息，其中有三个属性：<span style="color: #ff6600;">变量对象</span>(variable object)，<span style="color: #ff6600;">作用域链</span>(scope chain)，<span style="color: #ff6600;">this指针</span>(this value)，它们影响着变量的解析、变量作用域、函数 this 的指向。<span style="color: #000000;">执行上下文分为 <span style="color: #ff6600;">全局执行上下文</span> 和 <span style="color: #ff6600;">函数执行上下文</span>。</span></span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">全局代码开始执行前，会以 window 为目标产生一个全局执行上下文， 开始对代码预编译，这时候 this 指向的就是 window，接着开始执行全局代码。</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">当函数代码开始执行前，会以函数为目标产生一个函数执行上下文，开始对该函数预编译，这时候 this 的指向要分几种情况（下面讨论），接着开始执行函数代码，函数代码执行完后函数执行上下文就被会删除。多个函数会产生多个执行上下文。</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">上面说到函数预编译的 this 分下面四种情况：</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">第一种： 函数自主调用 如 fun() 或者是 普通的立即执行函数（区别于箭头函数方式的立即执行函数）， <span style="color: #ff6600;">this 指向 window</span>；</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">第二种： 函数被调用，当函数被某个对象调用时，函数产生的执行上下文中的 <span style="color: #ff6600;">this 指向 该对象</span>；</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">第三种： 通过 call() apply() bind() 方法改变 this，<span style="color: #ff6600;">this 指向被传入的 第一个参数</span>；</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">第四种： 在构造函数中，<span style="color: #ff6600;">this 指向被创建的 实例</span></span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">由于箭头函数是不能通过 call() apply() bind() 方法改变 this，也不能当做构造函数，所以接下来只演示第一和第二种情况的代码</span></p>
<div class="cnblogs_code" style="margin-left: 30px;">
<pre><code><span style="font-size: 13px;"><span style="color: #0000ff;">var</span> a =<span style="color: #000000;"> {
    origin: </span>'a'<span style="color: #000000;">,
    b: {
        origin: </span>'b'<span style="color: #000000;">,
        show: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
　　　       </span><span style="color: #0000ff;">var</span> origin = 'show'<span style="color: #000000;">;
            console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.origin);
　      }
    }
}
</span><span style="color: #0000ff;">var</span> origin = 'window'<span style="color: #000000;">
a.b.show();      </span><span style="color: #008000;">//</span><span style="color: #008000;"> 因为 b 对象调用了 show 函数，所以 show 函数的执行上下文中的 this 指针指向 b 对象</span>
<span style="color: #0000ff;">var</span> fun = a.b.show;     <span style="color: #008000;">//</span><span style="color: #008000;"> 注意这里是将 show 函数赋值给fun，相当于 var fun = function(){console.log(this)}</span>
fun();      <span style="color: #008000;">//</span><span style="color: #008000;"> 因为 fun 是自主调用，所以 this 指针指向 window，自然就打印 window 对象了</span></span></pre>
</div>
<div>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">可能有人会有这个疑惑：a.b.show() 中，a 调用了 b，是不是 b 的 this 指向 a 了？</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">前面也说到了，this 储存在执行上下文中，<span style="color: #000000;">而只有 全局 和 函数 才会产生执行上下文</span>，在执行上下文里记录着 this，而 b 是全局中 a 对象里面的一个对象，不存在谁调用它，它的 this 就是谁的说法。</span></p>
<p style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">接下来理解箭头函数中的 this 就非常容易了。</span></p>
</div>
<p style="margin-left: 30px;"><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>箭头函数中的 this</strong></span></p>
<div style="margin-left: 30px;"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">首先，<span style="color: #ff6600;">箭头函数不会创建自己的 this，它只会从自己的作用域链上找父级执行上下文的 this，</span>而不是谁调用它，它的 this 就是谁。所以箭头函数中的 this，取决于你上层执行上下文的 this 。</span></div>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">下例中，</span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">obj 分别调用了 show1 和 show2 两个方法，所以show1 和 show2 中的 this 都是指向 obj，</span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">show1 中，&nbsp;setTimeout 里面是箭头函数，从作用域链中找到 show1 中的 this，所以它的 this 就是 obj 对象；</span></p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">show2 中，setTimeout 里面的函数换成普通函数，函数自主调用，所以他的 this 就是 window 对象</span></p>
<div class="cnblogs_code" style="margin-left: 30px;">
<pre><code><span style="font-size: 13px;"><span style="color: #0000ff;">var</span> id = 0<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
    id: </span>1<span style="color: #000000;">,
    show1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        setTimeout(() </span>=&gt;<span style="color: #000000;"> {
            console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.id)
        }, </span>1000<span style="color: #000000;">)
    },

　　show2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
　　　　setTimeout(</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
　　　　　　console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.id)
　　　　}, </span>2000<span style="color: #000000;">)
　　}
}

obj.show1();    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 打印 1</span>
obj.show2();    <span style="color: #008000;">//</span><span style="color: #008000;"> 打印 0</span></span></pre>
</div>
<p style="margin-left: 30px;">&nbsp;</p>
<h3><span style="font-size: 18px; font-family: 'Microsoft YaHei';">不能当成构造函数</span></h3>
<div class="cnblogs_code">
<pre><code><span style="font-size: 13px;"><span style="color: #0000ff;">var</span> Foo = () =&gt;<span style="color: #000000;"> {};
</span><span style="color: #0000ff;">var</span> foo = <span style="color: #0000ff;">new</span> Foo(); <span style="color: #008000;">//</span><span style="color: #008000;"> TypeError: Foo is not a constructor</span></span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px; font-family: 'Microsoft YaHei';">没有 prototype 属性</span></h3>
<div class="cnblogs_code">
<pre><code><span style="font-size: 13px;"><span style="color: #0000ff;">var</span> Foo = () =&gt;<span style="color: #000000;"> {};
console.log(Foo.prototype); </span><span style="color: #008000;">//</span><span style="color: #008000;"> undefined</span></span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px; font-family: 'Microsoft YaHei';">没有 arguments 对象</span></h3>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">在大多数情况下，使用' ... ' 运算符是比使用 arguments&nbsp;对象的更好选择。</span></p>
<div class="cnblogs_code" style="margin-left: 30px;">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> foo(...arg) { 
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> arg; 
}
foo(</span>1, 2, 3, 4); <span style="color: #008000;">//</span><span style="color: #008000;"> 1</span></pre>
</div>
<div class="cnblogs_code" style="margin-left: 30px;">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> foo(...numbers) { 
    numbers.forEach((number)</span>=&gt;<span style="color: #000000;">{
        console.log(number);
    })
} 
foo(</span>1, 2, 3, 4);  <span style="color: #008000;">//</span><span style="color: #008000;"> 1 2 3 4</span></pre>
</div>
<p>&nbsp;</p>
<p style="margin-left: 30px;"><span style="font-size: 15px; font-family: 'Microsoft YaHei';">&nbsp;</span></p>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>