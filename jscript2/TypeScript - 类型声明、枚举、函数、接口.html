<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修TypeScript - 类型声明、枚举、函数、接口' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>TypeScript - 类型声明、枚举、函数、接口</center></div><div class='banquan'>原文出处:本文由博客园博主WahFung提供。<br/>
原文连接:https://www.cnblogs.com/chanwahfung/p/11939190.html</div><br>
    <h2 id="目录">目录</h2>
<h3 id="可定义的类型"> <a href="#1">可定义的类型</a></h3>
<h3 id="类型声明"> <a href="#2">类型声明</a></h3>
<h3 id="枚举"> <a href="#3">枚举</a></h3>
<h3 id="函数"> <a href="#4">函数</a></h3>
<h3 id="接口"> <a href="#5">接口</a></h3>
<h2 id="可定义的类型-1"><span id="1">可定义的类型</h2>
<blockquote>
<p>以下所写的并不代表typescript的数据类型，而是在使用过程中可以用作定义的类型</p>
</blockquote>
<ul>
<li>number : 数值类型；</li>
<li>string : 字符串类型；</li>
<li>boolean : 布尔类型；</li>
<li>Array : 数组类型；</li>
<li>Date : 日期；</li>
<li>RegExp : 正则；</li>
<li>Error : 错误类型；</li>
<li>any : 任意类型；</li>
<li>undefined : undefined；</li>
<li>null ：空类型；</li>
<li>Function : 函数；</li>
<li>Promise : Promise；</li>
<li><p>object : 对象类型；</p>
<blockquote>
<p>为一个变量定义object类型时，意味着变量的值可以为数组、函数、Date等，就像js所定义的object。当需要实现一个对象时，可以使用接口来定义。</p>
</blockquote></li>
<li><p>interface : 接口；</p>
<blockquote>
<p>该类型需要通过interface关键词来实现</p>
</blockquote></li>
<li><p>enum ：枚举类型；</p>
<blockquote>
<p>该类型需要通过enum关键词来实现</p>
</blockquote></li>
<li><p>void ：空类型；</p>
<blockquote>
<p>该类型规定函数返回值，代表无返回值</p>
</blockquote></li>
</ul>
<h2 id="类型声明-1"><span id="2">类型声明</h2>
<p><strong>1.单类型定义</strong></p>
<pre><code><code>let str:string = &#39;hello&#39;</code></pre>
<p><strong>2.复合类型定义</strong><br />
以下值类型可以为string或number</p>
<pre><code><code>let money:string|number = &#39;100&#39;  </code></pre>
<p><strong>3.数组定义</strong></p>
<pre><code><code>//第一种
let arr:number[] = [1,2,3]
//第二种  个人比较喜欢这种，Array关键词能够第一眼就知道是数组
let arr:Array&lt;string|number&gt; = [1,&#39;1&#39;]</code></pre>
<p>Readonly关键字 数组只读</p>
<pre class="javascript"><code>let arr:ReadonlyArray&lt;string&gt; = [&#39;1&#39;]
//arr[0] = &#39;2&#39;  error
//arr.push(&#39;2&#39;)  error
//arr.length = 10  error
//let arr1 = arr  error
//arr = [&#39;2&#39;]  ok</code></pre>
<p><strong>4.自定义类型</strong><br />
当一些复杂类型需要多次使用，可以通过type来自定义类型，便于复用</p>
<pre><code><code>type GetMoney = ()=&gt;string|number
let getMoney:GetMoney = function(){
  return &#39;1000&#39;
}</code></pre>
<h2 id="枚举-1"><span id="3">枚举</h2>
<p>使用枚举我们可以定义一些带名字的常量</p>
<p><strong>1.字符串枚举</strong></p>
<pre><code><code>enum SEX{
  man = &#39;男&#39;,
  woman = &#39;女&#39;,
  unknown = &#39;未知&#39;
}
let arr:Array&lt;SEX&gt; = [SEX.man]</code></pre>
<p><strong>2.数字枚举</strong></p>
<pre><code><code>//不使用初始化器
enum Direction {
    Up,    //0
    Down,  //1
    Left,  //2
    Right, //3
}</code></pre>
<pre><code><code>//使用初始化器
enum Direction {
    Up = 1,  //1
    Down,  //2
    Left,  //3
    Right, //4
}</code></pre>
<p><strong>3.反向映射</strong><br />
正向映射（ name -&gt; value） 反向映射（ value -&gt; name）<br />
数字枚举成员还具有反向映射， 要注意的是不会为字符串枚举成员生成反向映射</p>
<pre><code><code>enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // &quot;A&quot;</code></pre>
<p>TypeScript可能会将这段代码编译为下面的JavaScript：</p>
<pre class="javascript"><code>var Enum;
(function (Enum) {
    Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;
})(Enum || (Enum = {}));
var a = Enum.A;
var nameOfA = Enum[a]; // &quot;A&quot;</code></pre>
<p>简单说下以上JavaScript代码发生了什么：</p>
<ol>
<li>自执行函数为Enum添加属性，</li>
<li>Enum[&quot;A&quot;] = 0赋值后返回0作为索引，</li>
<li>发生第二次赋值Enum[0] = 'A'</li>
<li>此时的Enum内部为 {&quot;A&quot;:0, 0:&quot;A&quot;}</li>
</ol>
<h2 id="函数-1"><span id="4">函数</h2>
<p><strong>1.默认参数 可选参数</strong></p>
<pre class="javascript"><code>//返回值为字符串数组
function foo(msg:string, msg1:string=&#39;world&#39;):Array&lt;string&gt; {
  return [msg,msg1]
}
say(&#39;hello&#39;)</code></pre>
<p><strong>2.剩余参数</strong></p>
<pre class="javascript"><code>function foo1(...arr:Array&lt;string&gt;):void {
  arr.forEach(item=&gt;console.log(item))
}
say1(&#39;1&#39;,&#39;2&#39;)</code></pre>
<p><strong>3.回调函数</strong></p>
<pre class="javascript"><code>function foo3(cb:()=&gt;void) {
  cb()
}</code></pre>
<p><strong>4.表达式函数</strong></p>
<pre class="tjavascript"><code>let foo4:(num:string)=&gt;void = function(){}</code></pre>
<p><strong>5.Promise</strong></p>
<pre class="javascript"><code>//第一种 为resolve定义类型
function asyncFn():Promise&lt;string&gt;{
    let p = new Promise((resolve:(val:string)=&gt;void)=&gt;{
        resolve(&#39;result&#39;)
    })
    return p
}
//第二种 声明返回值的泛型
function asyncFn():Promise&lt;string&gt;{
    let p = new Promise&lt;string&gt;((resolve)=&gt;{
        resolve(&#39;result&#39;)
    })
    return p
}</code></pre>
<h2 id="接口interface"><span id="5">接口(interface)</h2>
<p>接口的作用是对值所具有的结构进行类型检查，为这些结构定义规定，让你的代码按照规定去执行。</p>
<p><strong>1.对象</strong></p>
<pre><code><code>interface People{
  readonly name: string;
  height: number;
  like?: string;
}
let worker:People = {name:&#39;Joe&#39;,height:180}</code></pre>
<blockquote>
<p>?: 可选属性<br />
readonly 属性只读</p>
</blockquote>
<p><strong>2.索引签名</strong><br />
添加任意数量的额外属性</p>
<pre><code><code>interface People{
    readonly name: string;
    height: number;
    [propName: string]: any;
}
let worker:People = {
    name:&#39;Joe&#39;,
    height:180,
    sex:&#39;man&#39;,
    eat:function(){}
}</code></pre>
<p><strong>3.继承</strong><br />
接口和类一样，可以使用继承，这样可以分割更多的模块，便于我们灵活的组合使用</p>
<pre><code><code>interface People{
    say(msg:string):string
}
interface Man extends People{
    readonly name:string
}
let coder:Man = {
    name:&#39;Wahfung&#39;,
    say(msg){
        return &#39;say:&#39;msg
    }
}</code></pre>
<p>多继承</p>
<pre><code><code>interface Man extends People,SuperMan{
    readonly name:string
}</code></pre>
<p><strong>4.定义函数</strong></p>
<pre><code><code>interface SayHandler {
  (people:string,msg:string):string
}
//参数名无需与接口的一致，甚至无需为参数规定类型，接口会自动进行判断
let sayMsg:SayHandler = function(p, m) {
  let result = p+&#39;:&#39;+m
  return result
}
sayMsg(&#39;Joe&#39;,&#39;hello&#39;)</code></pre>
<p><strong>5.为函数规定参数</strong></p>
<pre><code><code>interface Car {
  color: string;
  brand?: string;
}
function CreateCar(config:Car):object{
    let price = 1000
    if(config.brand===&#39;BMW&#39;){
        price = 2000
    }
    return {color:config.color,price}
}
CreateCar({color:&#39;red&#39;})</code></pre>
<p>使用es6解构参数重写👇</p>
<pre class="javascript"><code>function CreateCar({color,brand}:Car):object{
    let price = 1000
    if(brand===&#39;BMW&#39;){
        price = 2000
    }
    return {color,price}
}</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>