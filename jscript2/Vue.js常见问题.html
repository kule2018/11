<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Vue.js常见问题' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Vue.js常见问题</center></div><div class='banquan'>原文出处:本文由博客园博主雨夜汁汁提供。<br/>
原文连接:https://www.cnblogs.com/yuyezhizhi/p/10910581.html</div><br>
    <p style="text-align: left;"><strong>v-show与v-if的区别</strong></p>
<p style="text-align: left;">1.v-show只是css级别的display属性none和block之间的切换。而v-if&nbsp;是&ldquo;真正&rdquo;的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建</p>
<p style="text-align: left;">2.v-show一般用在操作比较频繁的地方，v-if用在运行时条件很少改变的地方。</p>
<p style="text-align: left;">3.v-if="false"时，内部组件不会渲染，可以利用这个合理渲染重要的内容。或者和v-else，v-else-if一起使用。</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><strong>绑<span>定class的数组用法</span></strong></p>
<p style="text-align: left;">一般绑定class对象的用法如下</p>
<p style="text-align: left;"><span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">v-bind:class=<span class="hljs-string">"{ active: <span>isActive</span> }"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;</span></span></span></span></span></span></p>
<p style="text-align: left;">当isActive为true时，class="active"</p>
<p>你可以在对象中传入更多属性来动态切换多个 class,v-bind:class可以和普通的class共存</p>
<p>&lt;<span class="hljs-name">div&nbsp;</span></p>
<p><span class="hljs-name">class=&rdquo;static&ldquo;</span></p>
<p><span class="hljs-name"><span class="hljs-attr">v-bind:class=<span class="hljs-string">"{ active:&nbsp;isActive,text-danger:hasError }"&gt;</span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;</span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">data{</span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">isActive:true,</span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">hasError:false</span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">}</span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">那渲染结果为&lt;div class="static active"&gt;&lt;/div&gt;</span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">数组的用法</span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">&lt;<span class="hljs-name">div&nbsp;<span class="hljs-attr">v-bind:class=<span class="hljs-string">"[ activeClass,errorClass ]"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">data{</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">activeClass:'active',</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">errorClass:'text-danger'</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">}</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">渲染为</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">&lt;div class="active text-danger"&gt;</span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">想根据条件切换数组中的class</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">可以用三元表达式：</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">&lt;div v-bind:class=[isActive?activeClass:'',errorClass]&gt;</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">这样会始终添加errorClass，只有当isActive为true时添加activeClass</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">在数组语法中也可以使用对象语法：</span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name">&lt;div v-bind:class=[{active:isActive},errorClass]&gt;</span></span></span></span></span></span></span></span></span></span></p>
<pre><code></pre>
<p style="text-align: left;"><strong>计算属性和watch的区别</strong></p>
<p style="text-align: left;">计算属性是自动监听，依赖值的变化，从而动态返回内容。</p>
<p style="text-align: left;">如果我们还需要动态值，那就用计算属性；需要知道值改变之后执行的逻辑，就用watch</p>
<p style="text-align: left;">补充：</p>
<p style="text-align: left;">1.computed是一个对象的时候，有get和set两个选项。</p>
<p style="text-align: left;">2.methods是一个方法，可以接受参数，computed可以缓存。</p>
<p style="text-align: left;">3.computed可以依赖其他的computed，甚至是其他组件的data。</p>
<p style="text-align: left;">4.watch是一个对象的时候，有handler（执行的函数），deep（是否深度），immediate（是否立即执行）等常用选项。</p>
<p style="text-align: left;"><strong>事件修饰符</strong></p>
<p style="text-align: left;">&lt;!--ctrl按下时触发，即使Alt或Shift被一同按下也会触发--&gt;</p>
<p style="text-align: left;">&lt;button @click.ctrl="onClick"&gt;B&lt;/button&gt;</p>
<p style="text-align: left;">&lt;!-- 有且只有ctrl被按下时触发--&gt;</p>
<p style="text-align: left;">&lt;button @click.ctrl.exact="onClick"&gt;B&lt;/button&gt;</p>
<p style="text-align: left;">&lt;!-- 没有任何修饰符被按下时触发--&gt;</p>
<p style="text-align: left;">&lt;button @click.exact="onClick"&gt;B&lt;/button&gt;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><span class="hljs-comment">&lt;!-- 阻止单击事件继续传播 --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a <span class="hljs-attr">v-on:click.stop=<span class="hljs-string">"doThis"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a&gt;</span></span></span></span></span></span></span></p>
<p style="text-align: left;"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment">&lt;!-- 提交事件不再重载页面 --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">form <span class="hljs-attr">v-on:submit.prevent=<span class="hljs-string">"onSubmit"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">form&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><span class="hljs-comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; <span class="hljs-comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">v-on:click.capture=<span class="hljs-string">"doThis"&gt;...<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;</span></span></span></span></span></span></span></span></p>
<p style="text-align: left;"><span class="hljs-comment"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; <span class="hljs-comment">&lt;!-- 即事件不是从内部元素触发的 --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">v-on:click.self=<span class="hljs-string">"doThat"&gt;...<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><span class="hljs-comment">&lt;!-- 点击事件将只会触发一次 --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a <span class="hljs-attr">v-on:click.once=<span class="hljs-string">"doThis"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a&gt;</span></span></span></span></span></span></span></p>
<p style="text-align: left;"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt; <span class="hljs-comment">&lt;!-- 而不会等待 `onScroll` 完成 --&gt; <span class="hljs-comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">v-on:scroll.passive=<span class="hljs-string">"onScroll"&gt;...<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;</span></span></span></span></span></span></span></span></span></span></p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><strong>组件中的data为什么是函数</strong></p>
<p style="text-align: left;">因为组件使用来复用的，JS里对象是引用关系，这样作用域没有隔离</p>
<p style="text-align: left;">而new Vue的实例是不会被复用的，因此不存在引用对象的问题。</p>
<p style="text-align: left;"><strong>Keep-alive内置组件</strong></p>
<p style="text-align: left;"><strong><br /></strong>Props：</p>
<p style="text-align: left;">1.include 字符串或正则表达式，匹配的组件会被缓存</p>
<p style="text-align: left;">2.exclude 与上面相反</p>
<p style="text-align: left;">3.max。数字，最大可以缓存多少组件实例。</p>
<p style="text-align: left;">用法：</p>
<p style="text-align: left;">&lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们，和&lt;transition&gt;一样，它是一个抽象组件，不会渲染出一个DOM元素，也不会出现在父组件链中。</p>
<p style="text-align: left;">当组件在&lt;keep-alive&gt;内被切换，它的activated和 deactivate&nbsp;这两个生命周期钩子函数将会被对应执行。</p>
<p>主要用于保留组件状态或避免重新渲染。</p>
<p><span class="hljs-comment">&lt;!-- 基本 --&gt;</span></p>
<p><span class="hljs-comment"> <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive&gt; <span class="hljs-tag">&lt;<span class="hljs-name">component <span class="hljs-attr">:is=<span class="hljs-string">"view"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">component&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive&gt;</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> <span class="hljs-comment">&lt;!-- 多个条件判断的子组件 --&gt;</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"> <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive&gt; <span class="hljs-tag">&lt;<span class="hljs-name">comp-a <span class="hljs-attr">v-if=<span class="hljs-string">"a &gt; 1"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">comp-a&gt; <span class="hljs-tag">&lt;<span class="hljs-name">comp-b <span class="hljs-attr">v-else&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">comp-b&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> <span class="hljs-comment">&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt; </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag">&lt;<span class="hljs-name">transition&gt; <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive&gt; <span class="hljs-tag">&lt;<span class="hljs-name">component <span class="hljs-attr">:is=<span class="hljs-string">"view"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">component&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">transition&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><strong>注意</strong>：&lt;<span class="hljs-name">keep-alive&gt;</span>是用在其一个直属的子组件被开关的情形。如果你在其中有v-for则不会工作。如果有上述的多个条件性的子元素，&lt;<span class="hljs-name">keep-alive&gt;</span>要求同时只有一个子元素被渲染。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><strong>Vuex中mutations和actions的区别</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">actions可以执行异步，actions调用mutations，而mutations来修改store。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-comment"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-attr"><span class="hljs-string"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Render函数</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p>
<p>类型：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>
<p>详细：字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个&nbsp;<code>createElement</code>&nbsp;方法作为第一个参数用来创建&nbsp;<code>VNode</code>。如果组件是一个函数组件，渲染函数还会接收一个额外的&nbsp;<code>context</code>&nbsp;参数，为没有实例的函数组件提供上下文信息。</p>
<p><strong>怎么理解单向数据流</strong></p>
<p>父组件时通过prop把数据传递到子组件的，但是这个prop只能由父组件修改，子组件修改会报错。子组件想修改时，只能通过$emit派发一个自定义事件，父组件接到后，由父组件修改。</p>
<p><strong>生命周期</strong></p>
<p>主要有8个阶段</p>
<p>①beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<p>②created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code>&nbsp;属性目前不可见。</p>
<p>③beforeMount：在挂载开始之前被调用：相关的&nbsp;<code>render</code>&nbsp;函数首次被调用。该钩子在服务器端渲染期间不被调用。</p>
<p>④mounted：<code>el</code>&nbsp;被新创建的&nbsp;<code>vm.$el</code>&nbsp;替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当&nbsp;<code>mounted</code>&nbsp;被调用时&nbsp;<code>vm.$el</code>&nbsp;也在文档内。</p>
<p>注意&nbsp;<code>mounted</code>&nbsp;不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用&nbsp;vm.$nextTick&nbsp;替换掉&nbsp;<code>mounted</code>：mounted: <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) { <span class="hljs-keyword">this.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) { <span class="hljs-comment">// Code that will run only after the <span class="hljs-comment">// entire view has been rendered }) }&nbsp;该钩子在服务器端渲染期间不被调用。</span></span></span></span></span></span></span></span></span></p>
<p>⑤beforeUpdate：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p>
<p>⑥updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或&nbsp;watcher&nbsp;取而代之。</p>
<p>注意&nbsp;<code>updated</code>&nbsp;不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用&nbsp;vm.$nextTick&nbsp;替换掉&nbsp;<code>updated</code>：updated: <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) { <span class="hljs-keyword">this.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) { <span class="hljs-comment">// Code that will run only after the <span class="hljs-comment">// entire view has been re-rendered }) }</span></span></span></span></span></span></span></span></span>该钩子在服务器端渲染期间不被调用。</p>
<p>⑦beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。</p>
<p>⑧Destoryed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>
<p><strong>组件间的通信</strong></p>
<p>1.父向子传递数据是通过props，子向父通过events（emits）</p>
<p>2.通过父链子链也可以(parent/$children)</p>
<p>3.ref也可以访问组件实例，provide/inject API</p>
<p>4.兄弟通信通过Bus和Vuex</p>
<p>5.跨级通信通过Bus和Vuex 和provide/inject API</p>
<p><strong>路由的跳转方式</strong></p>
<p>1.通过&lt;router-link to="home"&gt;,router-linker标签渲染为&lt;a&gt;标签，在template中的跳转都是用这种。</p>
<p>2.另一种是边城式导航，也就是通过JS跳转，比如router.push('/home')。</p>
<p><strong>Vue.js 2.x 双向绑定原理</strong></p>
<p>核心的API是通过Object.defineProperty()来劫持各个属性的setter/getter,在数据变动时发布消息给订阅者，触发相应的监听回调，这就是为什么不支持IE8的原因。</p>
<p><strong>MVVM与MVC有什么区别</strong></p>
<p>MVVM模式是由经典的软件架构MVC衍生来的。当View（视图层）变化时，会自动更新到ViewModel（视图模型）。反之亦然。View和ViewModel之间通过双向绑定（data-binding)建立联系，于MVC不同的是，他没有Controller层，而是演变为ViewModel。</p>
<p>ViewModel通过双向绑定数据把View层和Model层连接起来，而View和Model之间的同步工作是由Vue.js完成的，我们不需要手动操作DOM，只需要维护好数据状态。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>