<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Vue起飞前的准备' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Vue起飞前的准备</center></div><div class='banquan'>原文出处:本文由博客园博主与鹿逐秋提供。<br/>
原文连接:https://www.cnblogs.com/wangyueping/p/11437765.html</div><br>
    <h1 id="vue起飞前的准备">Vue起飞前的准备</h1>
<h1 id="一什么是ecmascript以及es6的诞生">一、什么是ECMAScript，以及es6的诞生？</h1>
<p>1997年 ECMAScript 1.0 诞生</p>
<p>1999年12月 ECMAScript 3.0诞生，它 是一个巨大的成功，在业界得到了广泛的支持，它奠定了JS的基本语法，被其后版本完全继承。直到今天，我们一开始学习JS，其实就是在学3.0版的语法</p>
<p>2000年的ECMAScript4.0是当下ES6的前身，但由于这个版本太过激烈，对ES3做了彻底升级，所以暂时被“和谐”了</p>
<p>2009年12月，ECMAScript5.0版正式发布。ECMA专家组预计ECMAScript的第五个版本会在2013年中期到2018年作为主流的开发标准。2011年6月，ES5.1版发布，并且成为ISO国际标准</p>
<p>2013年，ES6草案冻结，不再添加新的功能，新的功能将被放到ES7中；2015年6月，ES6正式通过，成为国际标准</p>
<p>好的，介绍es6的诞生，我们简单来学几个es6的语法，仅仅的只是为了后面咱们vue的课程做课前准备。如果感兴趣的同学可以查看</p>
<p><a href="http://es6.ruanyifeng.com/" class="uri">http://es6.ruanyifeng.com/</a></p>
<p><br></p>
<h2 id="es6语法let和const">es6语法：let和const</h2>
<p>es6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<p><img src="./images/Vue起飞前的准备0.png" /></p>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效</p>
<p>for循环相信大家都玩过。下面这种现象扭曲了我们块级作用域的思想！如果将var改成let就可以了！</p>
<p><img src="./images/Vue起飞前的准备1.png" /></p>
<p>再看一个例子：</p>
<pre><code><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6]();</code></pre>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10</p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6</p>
<pre><code><code>var a = [];
for (let i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6]();</code></pre>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算</p>
<p><br></p>
<h2 id="不存在变量提升">不存在变量提升</h2>
<p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code><code>// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;</code></pre>
<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<p><br></p>
<h2 id="不允许重复声明">不允许重复声明</h2>
<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code><code>// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}</code></pre>
<p>因此，不能在函数内部重新声明参数</p>
<pre><code><code>function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    var arg; // 不报错
  }
}</code></pre>
<p><br></p>
<h2 id="为什么需要块级作用域">为什么需要块级作用域？</h2>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<pre><code><code>var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = &#39;hello world&#39;;
  }
}

f(); // undefined</code></pre>
<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<pre><code><code>var s = &#39;hello&#39;;

for (var i = 0; i &lt; s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5</code></pre>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<p>const命令</p>
<p>基本语法</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code><code>const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.</code></pre>
<p>上面代码表明改变常量的值会报错</p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<pre><code><code>const foo;
// SyntaxError: Missing initializer in const declaration</code></pre>
<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错</p>
<p>const<code>的作用域与</code>let`命令相同：只在声明所在的块级作用域内有效。</p>
<pre><code><code>if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined</code></pre>
<p><br></p>
<h1 id="二模板字符串">二、模板字符串</h1>
<p>传统的JavaScript语言，输出模板通常是这样的写的。</p>
<pre><code><code>$(&#39;#result&#39;).append(
  &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;/b&gt; &#39; +
  &#39;items in your basket, &#39; +
  &#39;&lt;em&gt;&#39; + basket.onSale +
  &#39;&lt;/em&gt; are on sale!&#39;
);</code></pre>
<p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>
<pre><code><code>$(&#39;#result&#39;).append(`
  There are &lt;b&gt;${basket.count}&lt;/b&gt; items
   in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
  are on sale!
`);</code></pre>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p>
<pre><code><code>// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`</code></pre>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code><code>let greeting = `\`Yo\` World!`;</code></pre>
<p>输入结果：<code>Yo</code> World!</p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<pre><code><code>$(&#39;#list&#39;).html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`);</code></pre>
<p><br></p>
<h1 id="三箭头函数">三、箭头函数</h1>
<p>基本语法：</p>
<p>ES6允许使用“箭头”（=&gt;）定义函数</p>
<pre><code><code>var f = a = &gt; a

//等同于
var f = function(a){
   return a;  
}</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<pre><code><code>//无形参
var f = () =&gt; 5;
// 等同于
var f = function () { return 5 };

//多个形参
var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};</code></pre>
<p><br></p>
<p>使用箭头函数注意点：</p>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<pre><code><code>var name = &#39;张三&#39;；   
var person = {
       name:&#39;小马哥&#39;,
       age:18,　　
       fav:function(){        
           console.log(this)
           console.log(this.name)
       }
   }
person.fav();</code></pre>
<p>我们发现，打印的结果为</p>
<p><img src="./images/Vue起飞前的准备2.png" /></p>
<p>此时this指向的是使用它的对象，也就是person对象</p>
<pre><code><code> var person2 = {
    name:&#39;小马哥&#39;,
    age:18,
    fav: ()=&gt;{
         // 当前this指向了定义时所在的对象（window）
         console.log(this);
      }
    }

 person2.fav();</code></pre>
<p>打印的结果：window</p>
<p>使用箭头函数，它表示定义时所在的对象window。</p>
<p>再看一个例子吧！</p>
<pre><code><code>function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42</code></pre>
<p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以输出的是<code>42</code>。</p>
<p>（2）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<pre><code><code>var person3 = {
    name:&#39;小马哥&#39;,
    age:18,
    fav: ()=&gt;{
        console.log(argument);
    }
}

person3.fav(&#39;把妹&#39;,&#39;把爷&#39;);</code></pre>
<p>报出如下❎：</p>
<p><img src="./images/Vue起飞前的准备3.png" /></p>
<p><br></p>
<h1 id="四对象的单体模式">四、对象的单体模式</h1>
<p>为了解决箭头函数this指向的问题 推出来一种写法 对象的单体模式</p>
<pre><code><code>var person = {
    name:&#39;小马哥&#39;,
    age:12,
    fav(){
        console.log(this.name,this.age);
    }
}
person.fav();</code></pre>
<p><br></p>
<h1 id="五面向对象">五、面向对象</h1>
<h2 id="es6中的类">ES6中的类</h2>
<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。</p>
<pre><code><code>function Animal(name,age){
            this.name = name;
            this.age = age;

        }
Animal.prototype.showName = function(){
    console.log(this.name);
    console.log(this.age);
}

var a = new Animal(&#39;小黄&#39;,5);
a.showName();</code></pre>
<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>
<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样</p>
<pre><code><code>class Animal{
    
    // 构造器  当你创建实例之后 constructor()方法会立刻调用 通常这个方法初始化对象的属性
    constructor(name,age){
        this.name = name;
        this.age = age;
    }
    showName(){
        console.log(this.name);
    }
}
var a2 = new Animal(&#39;点点&#39;,3);</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5 的构造函数Animal，对应 ES6 的Animal类的构造方法。</p>
<p>Animal类除了构造方法，还定义了一个showName方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>
<pre><code><code>console.log(Animal2===Animal2.prototype.constructor);//true</code></pre>
<p>上面代码表示，类本身就指向了类的构造函数。</p>
<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>
<p><br></p>
<h2 id="constructor方法">constructor方法</h2>
<p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<pre><code><code>class Animal {
}

// 等同于
class Animal {
  constructor() {}
}</code></pre>
<p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor</code>方法。</p>
<p><br></p>
<h2 id="继承">继承</h2>
<pre><code><code>class Animal {
    constructor(name, gender) {
        this.name = name
        this.gender = gender
    }
}

# 继承父类在constructor方法中调用执行super()方法
class Cat extends Animal {
  constructor() {
    super();
  }
}</code></pre>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>