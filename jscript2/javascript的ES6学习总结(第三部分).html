<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修javascript的ES6学习总结(第三部分)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>javascript的ES6学习总结(第三部分)</center></div><div class='banquan'>原文出处:本文由博客园博主消逝的风i提供。<br/>
原文连接:https://www.cnblogs.com/abc-x/p/10799583.html</div><br>
    <h3>1.ES6中的面向对象的类</h3>
<h4><strong>1.1、定义类</strong></h4>
<p>在ES5中，我们写一个类，通常是这么写的</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age){
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * es5中的模拟面向对象的类的方法 写法1
Person.prototype.showName = function(){
    return "名字为："+this.name;
}
Person.prototype.showAge = function(){
    return "年龄为："+this.age;
}</span><span style="color: #008000;">*/</span>

<span style="color: #008000;">/*</span><span style="color: #008000;">*
 * es5中的模拟面向对象的类的方法 写法2
 *
 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
Object.assign(Person.prototype,{
    showName(){
        </span><span style="color: #0000ff;">return</span> "名字为："+<span style="color: #0000ff;">this</span><span style="color: #000000;">.name;
    },
    showAge(){
        </span><span style="color: #0000ff;">return</span> "年龄为："+<span style="color: #0000ff;">this</span><span style="color: #000000;">.age;
    }
});
</span><span style="color: #0000ff;">var</span> p1 = <span style="color: #0000ff;">new</span> Person('tom',18<span style="color: #000000;">);
console.log(p1.showName());</span><span style="color: #008000;">//</span><span style="color: #008000;">名字为：tom</span>
console.log(p1.showAge());<span style="color: #008000;">//</span><span style="color: #008000;">年龄为：18</span></pre>
</div>
<p>在ES6中，我们可以这样写</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">ES6中的类(类名大小写都可以，推荐使用规范按照首字母大写)</span>
<span style="color: #000000;">class Person{
    constructor(name,age){</span><span style="color: #008000;">//</span><span style="color: #008000;">构造方法(函数)，每new一个新对象，自动执行</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> console.log(`构造函数执行了,${name},${age}`);//构造函数执行了,Lucy,18</span>
        <span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }
    showName(){
        </span><span style="color: #0000ff;">return</span> `名字为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`;
    }
    showAge(){
        </span><span style="color: #0000ff;">return</span> `年龄为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.age}`;
    }
}
let p1 </span>= <span style="color: #0000ff;">new</span> Person('Lucy',18<span style="color: #000000;">);
console.log(p1.showName(),p1.showAge());</span><span style="color: #008000;">//</span><span style="color: #008000;">名字为：Lucy 年龄为：18</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">ES6中的类(赋给一个变量或常量，类名大小写都可以，推荐使用规范首字母大写)</span>
const Person =<span style="color: #000000;">  class{
    constructor(name,age){</span><span style="color: #008000;">//</span><span style="color: #008000;">构造方法(函数)，每new一个新对象，自动执行</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> console.log(`构造函数执行了,${name},${age}`);//构造函数执行了,Lucy,18</span>
        <span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }
    showName(){
        </span><span style="color: #0000ff;">return</span> `名字为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`;
    }
    showAge(){
        </span><span style="color: #0000ff;">return</span> `年龄为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.age}`;
    }
}
let p1 </span>= <span style="color: #0000ff;">new</span> Person('Lucy',18<span style="color: #000000;">);
console.log(p1.showName(),p1.showAge());</span><span style="color: #008000;">//</span><span style="color: #008000;">名字为：Lucy 年龄为：18</span></pre>
</div>
<p><strong>注意：</strong></p>
<p><strong>（<strong>1</strong>）.ES6里面Class没有提升(例如ES5中的函数有提升到顶部的作用)</strong></p>
<p><strong>（<strong>2</strong>）.ES6中的this，首先来看一下ES5中矫正this的几个方法</strong></p>
<p>(2.1) fn.call(this指向谁,args1,args2...);</p>
<p>(2.2) fn.apply(this指向谁,[args1,args2...]);</p>
<p>(2.3) fn.bind();(React中经常会用到)</p>
<p>其中，(2.1) fn.call和(2.2) fn.apply都会在矫正this的时候，方法(函数)会调用一次</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">class Person{
    constructor(){
        </span><span style="color: #0000ff;">this</span>.name = 'jason'<span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.showName = <span style="color: #0000ff;">this</span>.showName.bind(<span style="color: #0000ff;">this</span><span style="color: #000000;">);<span style="color: #008000;">//<span style="font-size: 12px;">矫正this</span></span>
    }
    showName(){
        console.log(</span>'this:',<span style="color: #0000ff;">this</span>);<span style="color: #008000;">//</span><span style="color: #008000;">this: Person {name: "jason", showName: function}</span>
        <span style="color: #0000ff;">return</span> `名字为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`;
    }
}
let p1 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
let {showName} </span>=<span style="color: #000000;"> p1;
console.log(showName());</span><span style="color: #008000;">//</span><span style="color: #008000;">名字为：jason</span></pre>
</div>
<h4><strong>1.2、类里面的取值函数(getter)和存值函数(setter)：</strong></h4>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">class Person{
    constructor(name){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    get aaa(){
        </span><span style="color: #0000ff;">return</span> `获取aaa的名字,值为${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`;
    }
    set aaa(val){
        console.log(`设置aaa的名字，值为${val}`);
    }
}
let p1 </span>= <span style="color: #0000ff;">new</span> Person('jack'<span style="color: #000000;">);
console.log(p1.aaa);</span><span style="color: #008000;">//</span><span style="color: #008000;">获取aaa的名字,值为jack</span>
p1.aaa = 'luke';<span style="color: #008000;">//</span><span style="color: #008000;">设置aaa的名字，值为luke</span></pre>
</div>
<h4><strong>1.3、类里面的静态方法(就是类身上的方法)</strong></h4>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">class Person{
    constructor(){

    }
    showName(){
        </span><span style="color: #0000ff;">return</span> '这是showName方法'<span style="color: #000000;">;
    }
    static aaa(){
        </span><span style="color: #0000ff;">return</span> '这是静态方法'<span style="color: #000000;">;
    }
}
let p1 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
console.log(p1.showName());</span><span style="color: #008000;">//</span><span style="color: #008000;">这是showName方法</span>
console.log(Person.aaa());<span style="color: #008000;">//</span><span style="color: #008000;">这是静态方法</span></pre>
</div>
<h4>1.4、类里面的继承</h4>
<p>先来回顾一下ES6之前的继承写法</p>
<p>1.原型链继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">父类</span>
Animal.prototype.eat = <span style="color: #0000ff;">function</span><span style="color: #000000;">(food) {
    console.log(</span><span style="color: #0000ff;">this</span>.name + '正在吃' +<span style="color: #000000;"> food);            
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Animal(name) {
    </span><span style="color: #0000ff;">this</span>.color = ['green','red','blue'<span style="color: #000000;">];
    </span><span style="color: #0000ff;">this</span>.name = name || 'animal'<span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>.sleep = <span style="color: #0000ff;">function</span><span style="color: #000000;">() {
        console.log(</span><span style="color: #0000ff;">this</span>.name + "正在睡觉"<span style="color: #000000;">)
    }
}</span></pre>
</div>
<p><strong>原型链继承核心:&nbsp;将父类的实例作为子类的原型。</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">子类</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Cat(name) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name
    </span><span style="color: #0000ff;">this</span>.color = ['green','red','blue'];<span style="color: #008000;">//</span><span style="color: #008000;">引用类型值，，所有实例会共享这个属性。</span>
<span style="color: #000000;">}
Cat.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Animal();
</span><span style="color: #0000ff;">var</span> cat = <span style="color: #0000ff;">new</span> Cat('cat'<span style="color: #000000;">);
console.log(cat.name);
console.log(cat.eat(</span>'fish'<span style="color: #000000;">));
console.log(cat </span><span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Animal);
console.log(cat.sleep());</span></pre>
</div>
<p><strong>缺点：</strong></p>
<p>但是，<span style="color: #ff0000;">原型链式继承并没有实现代码的复用</span>，一些共同的属性：如name，在子类中还是得重新写一遍（即同一套代码还是得重新写）。</p>
<p>再者，cat继承了Animal实例的所有属性和方法，这些方法并不都是我们需要的，也就是过多的继承了没有用的属性。且如果原型中包含<span style="color: #ff0000;">引用类型值</span>，那么所有的实例会共享这个属性。</p>
<p>2.构造函数继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age,sex){
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Student(name,age,sex){
    Person.call(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">,name,age,sex);
    </span><span style="color: #0000ff;">this</span>.grade =<span style="color: #000000;"> grade;
}
let student </span>= <span style="color: #0000ff;">new</span> Student;</pre>
</div>
<p><strong>优点：</strong></p>
<ul>
<li>构造函数模式继承实现了代码的复用</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不能继承借用的构造函数的原型，只能借用构造函数本身的属性和方法</li>
<li>每次构造函数都要多走一个函数</li>
</ul>
<p>3.组合继承</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 父类</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name){
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
}
Person.prototype.showName </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">return</span> `名字是：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`
};
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 子类</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Student(name,age){
    Person.call(</span><span style="color: #0000ff;">this</span>,name);<span style="color: #008000;">//</span><span style="color: #008000;">继承属性,在创建实例时第二次调用Person</span>
    <span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
}
Student.prototype </span>= <span style="color: #0000ff;">new</span> Person();<span style="color: #008000;">//</span><span style="color: #008000;">继承方法,第一次调用Person</span>
Student.prototype.constructor =<span style="color: #000000;"> Student;<span style="color: #008000;">//矫正constructor</span>
Student.prototype.sayName </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">return</span> '年龄是：'+<span style="color: #0000ff;">this</span><span style="color: #000000;">.age;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用</span>
<span style="color: #0000ff;">var</span> stu1 = <span style="color: #0000ff;">new</span> Student('jack',20<span style="color: #000000;">);
console.log(stu1.name);</span><span style="color: #008000;">//</span><span style="color: #008000;">jack</span>
console.log(stu1.showName);<span style="color: #008000;">//</span><span style="color: #008000;">function (){return `名字是：${this.name}`}</span>
console.log(stu1.showName());<span style="color: #008000;">//</span><span style="color: #008000;">名字是：jack</span>
console.log(stu1.sayName());<span style="color: #008000;">//</span><span style="color: #008000;">年龄是：20</span></pre>
</div>
<p>缺点：</p>
<ul>
<li>父类构造函数被调用2次，子类实例的属性存在两份,一份在原型上，一份在实例属性上。造成内存的浪费。</li>
</ul>
<p>4.寄生组合式继承</p>
<p>寄生组合式继承是对组合继承的进一步优化。我们先看一下为什么要写这个语句。</p>
<div class="cnblogs_code">
<pre><code>SubType.prototype = new SuperType();</pre>
</div>
<p>我们无非是想让SubType继承SuperType的原型。但是我们为什么不直接写成这样呢？</p>
<div class="cnblogs_code">
<pre><code>SubType.prototype = SuperType.prototype</pre>
</div>
<p>这样写确实可以实现子类对象对父类对象原型的继承。但是这样写的话：所有<span style="color: #ff0000;">继承该父类的子类对象的原型都指向同一个</span>了。也就是说SubType不能有自己的原型了。这显然不是我们想要的。</p>
<p>既然不能直接继承，那可不可以间接继承SuperType.prototype呢。这就是最终的解决方案：<strong>寄生组合式继承</strong>。</p>
<p>我们让一个函数去指向SuperType.prototype，然后让SubType.prototype指向这个函数产生的对象不就可以了嘛。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> inherit(Target,Origin) {<span style="color: #008000;">//</span><span style="color: #008000;">实现寄生组合式继承的核心函数</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> F() {};
    F.prototype </span>= Origin.prototype; <span style="color: #008000;">//</span><span style="color: #008000;">F()的原型指向的是Origin</span>
    Target.prototype = <span style="color: #0000ff;">new</span> F(); <span style="color: #008000;">//</span><span style="color: #008000;">Target的原型指向的是F()</span>
    Target.prototype.constructor =<span style="color: #000000;"> Target; 
    SubType.prototype.__proto__ </span>==<span style="color: #000000;"> SuperType.prototype
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> SuperType(name) {
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">this</span>.colors = ['red','blue','pink'<span style="color: #000000;">];
}
SuperType.prototype.sayName </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">() {
    console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.name);
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> SubType(name,age) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">继承属性</span>
    SuperType.call(<span style="color: #0000ff;">this</span>,name);<span style="color: #008000;">//</span><span style="color: #008000;">在创建实例时第二次调用SuperType</span>
    <span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
}

inherit(SubType,SuperType);</span><span style="color: #008000;">//</span><span style="color: #008000;">实现寄生组合式继承</span></pre>
</div>
<p>我们再来看一下实现寄生组合式继承的核心函数。F函数其实是通用的，我们没必要每次进入inherit函数时都声明一遍。所以我们可以用闭包的形式来写：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> inherit = (<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #0000ff;">var</span> F = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {};
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> (Target , Origin) {
            F.prototype </span>= Origin.prototype;<span style="color: #008000;">//</span><span style="color: #008000;">F()的原型指向的是Origin</span>
            Target.prototype = <span style="color: #0000ff;">new</span> F();<span style="color: #008000;">//</span><span style="color: #008000;">Target的原型指向的是F()</span>
            Target.prototype.constructor =<span style="color: #000000;"> Target;
            Target.prototype.uber </span>=<span style="color: #000000;"> Origin.prototype;
            SubType.prototype.__proto__ </span>==<span style="color: #000000;"> SuperType.prototype
        }
    })()</span></pre>
</div>
<p>再来看看ES6继承的写法，相比前面就优雅了许多，代码量也会少很多！！！</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> ES6继承 </span><span style="color: #008000;">*/</span>
<span style="color: #008000;">//</span><span style="color: #008000;"> 父类</span>
<span style="color: #000000;">class Person{
    constructor(name){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    showName(){
        </span><span style="color: #0000ff;">return</span> `名字为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`;
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 子类</span>
<span style="color: #000000;">class Student extends Person{

}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用</span>
<span style="color: #0000ff;">var</span> stu1 = <span style="color: #0000ff;">new</span> Student('jack'<span style="color: #000000;">);
console.log(stu1.showName());</span><span style="color: #008000;">//</span><span style="color: #008000;">名字为：jack</span></pre>
</div>
<p>子类在自己的身上加方法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> ES6继承 </span><span style="color: #008000;">*/</span>
<span style="color: #008000;">//</span><span style="color: #008000;"> 父类</span>
<span style="color: #000000;">class Person{
    constructor(name){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    showName(){
        </span><span style="color: #0000ff;">return</span> `名字为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`;
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 子类</span>
<span style="color: #000000;">class Student extends Person{
    constructor(name,skill){
        super(name);</span><span style="color: #008000;">//</span><span style="color: #008000;">子类的构造函数必须有super(),相当于执行一次父级的构造函数</span>
        <span style="color: #0000ff;">this</span>.skill =<span style="color: #000000;"> skill;
    }
    showSkill(){
        </span><span style="color: #0000ff;">return</span> `他的名字是${<span style="color: #0000ff;">this</span>.name},他的特长是${<span style="color: #0000ff;">this</span><span style="color: #000000;">.skill}`;
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用</span>
<span style="color: #0000ff;">var</span> stu1 = <span style="color: #0000ff;">new</span> Student('jack','跳舞'<span style="color: #000000;">);
console.log(stu1.showSkill());</span><span style="color: #008000;">//</span><span style="color: #008000;">他的名字是jack,他的特长是跳舞</span></pre>
</div>
<p>如果子类的方法和父类的方法同名，然后想调用父类的方法，自己子类的方法也要执行，可以这么写</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> ES6继承 </span><span style="color: #008000;">*/</span>
<span style="color: #008000;">//</span><span style="color: #008000;"> 父类</span>
<span style="color: #000000;">class Person{
    constructor(name){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    showName(){
        console.log(</span>'父类的showName'<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> `名字为：${<span style="color: #0000ff;">this</span><span style="color: #000000;">.name}`;
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 子类</span>
<span style="color: #000000;">class Student extends Person{
    constructor(name,skill){
        super(name);</span><span style="color: #008000;">//</span><span style="color: #008000;">子类的构造函数必须有super(),相当于执行一次父级的构造函数</span>
        <span style="color: #0000ff;">this</span>.skill =<span style="color: #000000;"> skill;
    }
    showName(){
        super.showName();</span><span style="color: #008000;">//</span><span style="color: #008000;">执行父类的方法</span>
        <span style="color: #008000;">/*</span><span style="color: #008000;"> 这里写子类自己的要做的事 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        console.log(</span>'子类的showName'<span style="color: #000000;">);
    }
    showSkill(){
        </span><span style="color: #0000ff;">return</span> `他的名字是${<span style="color: #0000ff;">this</span>.name},他的特长是${<span style="color: #0000ff;">this</span><span style="color: #000000;">.skill}`;
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用</span>
<span style="color: #0000ff;">var</span> stu1 = <span style="color: #0000ff;">new</span> Student('jack','跳舞'<span style="color: #000000;">);
console.log(stu1.showName());</span><span style="color: #008000;">//</span><span style="color: #008000;">父类的showName  子类的showName</span></pre>
</div>
<h3>2.Symbol和Generator</h3>
<h4>2.1Symbol：ES6新增的一种数据类型</h4>
<p>定义方法：let Symbol = Symbol('aaa');</p>
<p><strong>注意：</strong></p>
<p>(1)Symbol不能当new来使用</p>
<p>(2)Symbol()返回是一个唯一值</p>
<p>(3)Symbol是一个单独数据类型，就叫symbol的基本类型</p>
<p>(4)如果Symbol作为key，用for in循环，出不来</p>
<div class="cnblogs_code">
<pre><code>let symbol = Symbol('Jack'<span style="color: #000000;">);
let json </span>=<span style="color: #000000;"> {
    a:</span>'apple'<span style="color: #000000;">,
    b:</span>'banana'<span style="color: #000000;">,
    [symbol]:</span>'aaa'<span style="color: #000000;">
}
console.log(json[symbol]);</span><span style="color: #008000;">//</span><span style="color: #008000;">aaa</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 遍历json</span>
<span style="color: #0000ff;">for</span>(let key <span style="color: #0000ff;">in</span><span style="color: #000000;"> json){
    console.log(key);</span><span style="color: #008000;">//</span><span style="color: #008000;">a b</span>
}</pre>
</div>
<h4>2.2Generator生成器函数：解决异步，深度嵌套的问题</h4>
<p>语法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> *<span style="color: #000000;"> show(){

}
</span><span style="color: #0000ff;">function</span>*<span style="color: #000000;"> show(){

}
</span><span style="color: #0000ff;">function</span> *<span style="color: #000000;">show(){

}</span></pre>
</div>
<p>定义&amp;调用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> * gen(){<span style="color: #008000;">//</span><span style="color: #008000;">在函数名前面使用*号定义一个</span>
    yield 'hello'<span style="color: #000000;">;
    yield </span>'javascript'<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> 'generator函数'<span style="color: #000000;">;
}
let g1 </span>=<span style="color: #000000;"> gen();
console.log(g1.next());</span><span style="color: #008000;">//</span><span style="color: #008000;">Object {value: "hello", done: false}</span>
console.log(g1.next());<span style="color: #008000;">//</span><span style="color: #008000;">Object {value: "javascript", done: false}</span>
console.log(g1.next());<span style="color: #008000;">//</span><span style="color: #008000;">Object {value: "generator函数", done: true}</span>
console.log(g1.next());<span style="color: #008000;">//</span><span style="color: #008000;">Object {value: undefined, done: true}</span></pre>
</div>
<p>遍历generator函数：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> * gen(){<span style="color: #008000;">//</span><span style="color: #008000;">在函数名前面使用*号定义一个</span>
    yield 'hello'<span style="color: #000000;">;
    yield </span>'javascript'<span style="color: #000000;">;
    yield </span>'world'<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> 'generator函数'<span style="color: #000000;">;
}
let g1 </span>=<span style="color: #000000;"> gen();
</span><span style="color: #008000;">/*</span><span style="color: #008000;">遍历generator函数(注意：return的东西不会被遍历出来)</span><span style="color: #008000;">*/</span>
<span style="color: #008000;">//</span><span style="color: #008000;"> 1.用for...of遍历</span>
<span style="color: #0000ff;">for</span><span style="color: #000000;">(let val of g1){
    console.log(val);</span><span style="color: #008000;">//</span><span style="color: #008000;">hello javascript world</span>
<span style="color: #000000;">}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 2.使用解构</span>
let [a,b,c,d] =<span style="color: #000000;"> gen();
console.log(a,b,c,d);</span><span style="color: #008000;">//</span><span style="color: #008000;">hello javascript world undefined</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 3.使用扩展(三个点)运算符</span>
let [f,...g] =<span style="color: #000000;"> gen();
console.log(f,g);</span><span style="color: #008000;">//</span><span style="color: #008000;">hello ["javascript", "world"]</span>
<span style="color: #000000;">
let [...newArr] </span>=<span style="color: #000000;"> gen();
console.log(newArr);</span><span style="color: #008000;">//</span><span style="color: #008000;">["hello", "javascript", "world"]</span><span style="color: #008000;">
//</span><span style="color: #008000;">4.使用Array.from函数</span>
console.log(Array.from(gen()));<span style="color: #008000;">//</span><span style="color: #008000;">["hello", "javascript", "world"]</span></pre>
</div>
<p>关于异步的解决方案：</p>
<p>(1)回调函数</p>
<p>(2)事件监听</p>
<p>(3)发布/订阅</p>
<p>(4)Promise对象</p>
<p>(5)Generator函数</p>
<p>(6)Async/Await</p>
<h3>3.async、await函数：解决异步问题</h3>
<p>定义：在函数前面加async，函数内部加await，后面的代码会等待前面的代码先执行</p>
<p>语法：</p>
<div class="cnblogs_code">
<pre><code>async <span style="color: #0000ff;">function</span> fn(){<span style="color: #008000;">//</span><span style="color: #008000;">表示异步，这个函数里面有异步的任务</span>
    let result=await;<span style="color: #008000;">//</span><span style="color: #008000;">表示后面结果需要等待   </span>
}</pre>
</div>
<p>使用(例如读取文件)：</p>
<p>(1)promise写法：</p>
<div class="cnblogs_code">
<pre><code>const fs = require('fs'<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 用fs封装一个promise</span>
const readFile = <span style="color: #0000ff;">function</span><span style="color: #000000;">(fileName){
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve,reject)=&gt;<span style="color: #000000;">{
        fs.readFile(fileName,(err,data)</span>=&gt;<span style="color: #000000;">{
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(err) reject(err);
            resolve(data);
        })
    })
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> promise</span>
readFile('data/1.txt').then(res=&gt;<span style="color: #000000;">{
    console.log(res.toString());
    </span><span style="color: #0000ff;">return</span> readFile('data/2.txt'<span style="color: #000000;">);
}).then(res</span>=&gt;<span style="color: #000000;">{
    console.log(res.toString());
});</span></pre>
</div>
<p>(2)generator写法：</p>
<div class="cnblogs_code">
<pre><code>const fs = require('fs'<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 用fs封装一个promise</span>
const readFile = <span style="color: #0000ff;">function</span><span style="color: #000000;">(fileName){
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve,reject)=&gt;<span style="color: #000000;">{
        fs.readFile(fileName,(err,data)</span>=&gt;<span style="color: #000000;">{
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(err) reject(err);
            resolve(data);
        })
    })
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> generator</span>
<span style="color: #0000ff;">function</span> *<span style="color: #000000;"> gen(){
    yield readFile(</span>'data/1.txt'<span style="color: #000000;">);
    yield readFile(</span>'data/2.txt'<span style="color: #000000;">);
}
let g1 </span>=<span style="color: #000000;"> gen();
g1.next().value.then(res</span>=&gt;<span style="color: #000000;">{
    console.log(res.toString());
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> g1.next().value;
}).then(res</span>=&gt;<span style="color: #000000;">{
    console.log(res.toString());
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> g1.next().value;
});</span></pre>
</div>
<p>(3)async、await写法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 用async、await做一个文件读取</span>
const fs = require('fs'<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 用fs封装一个promise</span>
const readFile = <span style="color: #0000ff;">function</span><span style="color: #000000;">(fileName){
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((resolve,reject)=&gt;<span style="color: #000000;">{
        fs.readFile(fileName,(err,data)</span>=&gt;<span style="color: #000000;">{
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(err) reject(err);
            resolve(data);
        })
    })
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> async</span>
async <span style="color: #0000ff;">function</span> fn(){<span style="color: #008000;">//</span><span style="color: #008000;">表示异步，函数内有异步任务</span>
    let f1 = await readFile('data/1.txt');<span style="color: #008000;">//</span><span style="color: #008000;">表示后面的结果需要等待</span>
<span style="color: #000000;">    console.log(f1.toString());
    let f2 </span>= await readFile('data/2.txt'<span style="color: #000000;">);
    console.log(f2.toString());
}
fn();</span></pre>
</div>
<p><strong>async、await特点：</strong></p>
<p>1.await只能放在async函数中</p>
<p>2.相比generator语法更强</p>
<p>3.await后面可以是promise对象，也可以是数字、字符串、布尔类型</p>
<p>4.async函数返回的是一个promise对象</p>
<p>5.只要await语句后面Promise状态变为reject，那么整个async函数会中断执行</p>
<p><strong>如何解决async函数中抛出错误，影响后续代码执行？</strong></p>
<p>1.使用try{}catch(e){}语法</p>
<div class="cnblogs_code">
<pre><code>async <span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
        await Promise.reject(</span>'出现问题了'<span style="color: #000000;">);
    }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(e){

    }
    let a </span>= await Promise.resolve('successs'<span style="color: #000000;">);
    console.log(a);
}
fn().then(res</span>=&gt;<span style="color: #000000;">{
    console.log(res);
}).</span><span style="color: #0000ff;">catch</span>(err=&gt;<span style="color: #000000;">{
    console.log(err);
});
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 结果</span><span style="color: #008000;">
//</span><span style="color: #008000;"> success undefined</span></pre>
</div>
<p>2.promise本身的catch</p>
<div class="cnblogs_code">
<pre><code>async <span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){
    let [a,b] </span>=<span style="color: #000000;"> await Promise.all([
        readFile(</span>'data/1.txt'<span style="color: #000000;">),
        readFile(</span>'data/2.txt'<span style="color: #000000;">)
    ]);
    console.log(a.toString());
    console.log(b.toString());
}
fn();</span></pre>
</div>
<h3>4.Set和WeakSet</h3>
<h4>4.1、Set数据结构：类似数组，但里面不能有<span style="color: #ff0000;">重复值。<span style="color: #000000;">new Set([]),存储数组<br /></span></span></h4>
<p>用法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Set数据结构</span>
let setArr = <span style="color: #0000ff;">new</span> Set(['a','b','a'<span style="color: #000000;">]);
console.log(setArr);</span><span style="color: #008000;">//</span><span style="color: #008000;">Set(2) {"a", "b"}</span></pre>
</div>
<p>方法：</p>
<p>(1)add()方法：向Set数据结构中添加元素</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Set数据结构--add()方法：向数组中添加元素</span>
let setArr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Set();
setArr.add(</span>'aaa'<span style="color: #000000;">);
setArr.add(</span>'bbb'<span style="color: #000000;">);
setArr.add(</span>'aaa'<span style="color: #000000;">);
console.log(setArr);</span><span style="color: #008000;">//</span><span style="color: #008000;">Set(2) {"aaa", "bbb"}</span><span style="color: #008000;">
//</span><span style="color: #008000;"> add()方法链式添加</span>
let setArr = <span style="color: #0000ff;">new</span> Set().add('aaa').add('bbb').add('aaa'<span style="color: #000000;">);
console.log(setArr);</span><span style="color: #008000;">//</span><span style="color: #008000;">Set(2) {"aaa", "bbb", "ccc"}</span></pre>
</div>
<p>(2)delete()方法：删除Set数据结构中的某一项</p>
<div class="cnblogs_code">
<pre><code>let setArr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Set();
setArr.add(</span>'aaa'<span style="color: #000000;">);
setArr.add(</span>'bbb'<span style="color: #000000;">);
setArr.add(</span>'ccc'<span style="color: #000000;">);
console.log(setArr);</span><span style="color: #008000;">//</span><span style="color: #008000;">Set(2) {"aaa", "bbb","ccc"}</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Set数据结构--delete()方法：删除Set数据结构中的某一项</span>
setArr.<span style="color: #0000ff;">delete</span>('bbb'<span style="color: #000000;">);
console.log(setArr);</span><span style="color: #008000;">//</span><span style="color: #008000;">Set(2) {"aaa", "ccc"}</span></pre>
</div>
<p>(3)clear()方法：删除Set数据结构中的所有项</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Set数据结构--add()方法：向Set数据结构中添加元素</span>
let setArr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Set();
setArr.add(</span>'aaa'<span style="color: #000000;">);
setArr.add(</span>'bbb'<span style="color: #000000;">);
setArr.add(</span>'ccc'<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> Set数据结构--clear()方法：删除Set数据结构中的所有项</span>
<span style="color: #000000;">setArr.clear();
console.log(setArr);</span><span style="color: #008000;">//</span><span style="color: #008000;">Set(0) {}</span></pre>
</div>
<p>(4)has()方法：检测Set数据结构中的是否某一项,返回布尔值</p>
<div class="cnblogs_code">
<pre><code>let setArr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Set();
setArr.add(</span>'aaa'<span style="color: #000000;">);
setArr.add(</span>'bbb'<span style="color: #000000;">);
setArr.add(</span>'ccc'<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> Set数据结构--has()方法：检测Set数据结构中的是否某一项,返回布尔值</span>
console.log(setArr.has('bbba'));<span style="color: #008000;">//</span><span style="color: #008000;">false</span></pre>
</div>
<p>(5)size属性：查看Set数据结构有多少个元素</p>
<div class="cnblogs_code">
<pre><code>let setArr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Set();
setArr.add(</span>'aaa'<span style="color: #000000;">);
setArr.add(</span>'bbb'<span style="color: #000000;">);
setArr.add(</span>'ccc'<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> Set数据结构--size属性：查看Set数据结构有多少个元素</span>
console.log(setArr.size);<span style="color: #008000;">//</span><span style="color: #008000;">3</span></pre>
</div>
<p>(6)循环Set数据结构(注：<span style="color: #000000;">Set数据结构的key和value是相同的</span>)</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">for</span>(let val of setArr){<span style="color: #008000;">//</span><span style="color: #008000;">默认循环的是values()</span>
    console.log(val);<span style="color: #008000;">//</span><span style="color: #008000;">aaa bbb ccc</span>
<span style="color: #000000;">}
console.log(</span>'-------'<span style="color: #000000;">);
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(let val of setArr.keys()){
    console.log(val);</span><span style="color: #008000;">//</span><span style="color: #008000;">aaa bbb ccc</span>
<span style="color: #000000;">}
console.log(</span>'-------'<span style="color: #000000;">);
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(let val of setArr.values()){
    console.log(val);</span><span style="color: #008000;">//</span><span style="color: #008000;">aaa bbb ccc</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(let item of setArr.entries()){
    console.log(item);</span><span style="color: #008000;">//</span><span style="color: #008000;">["aaa", "aaa"] ["bbb", "bbb"] ["ccc", "ccc"]</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(let [k,v] of setArr.entries()){
    console.log(k,v);</span><span style="color: #008000;">//</span><span style="color: #008000;">aaa aaa bbb bbb ccc ccc</span>
<span style="color: #000000;">}
setArr.forEach((val,index)</span>=&gt;<span style="color: #000000;">{
    console.log(val,index);</span><span style="color: #008000;">//</span><span style="color: #008000;">aaa aaa bbb bbb ccc ccc</span>
});</pre>
</div>
<p>利用Set做数组的去重：</p>
<p>方法1</p>
<div class="cnblogs_code">
<pre><code>let arr = [1,2,3,4,5,6,3,4,5,3,2<span style="color: #000000;">];
let newArr </span>= [...<span style="color: #0000ff;">new</span> Set(arr)];<span style="color: #008000;">//</span><span style="color: #008000;">这里数组去重返回的是一个数组的浅拷贝</span>
arr.push(9,8,7,7,8<span style="color: #000000;">);
console.log(arr);</span><span style="color: #008000;">//</span><span style="color: #008000;">[1, 2, 3, 4, 5, 6, 3, 4, 5, 3, 2, 9, 8, 7, 7, 8]</span>
console.log(newArr);<span style="color: #008000;">//</span><span style="color: #008000;">[1, 2, 3, 4, 5, 6]</span></pre>
</div>
<p>方法2</p>
<div class="cnblogs_code">
<pre><code>let arr2 = [1,2,3,4,5,6,3,4,5,3,2<span style="color: #000000;">];
let newArr2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Set();
arr2.map(x</span>=&gt;<span style="color: #000000;">newArr2.add(x));
let resArr2 </span>=<span style="color: #000000;"> [...newArr2];
console.log(resArr2);[</span>1, 2, 3, 4, 5, 6]</pre>
</div>
<h4>4.2、WeakSet数据结构：类似数组对象，但里面不能有<span style="color: #ff0000;">重复值</span>。new WeakSet({}),存储对象</h4>
<p><strong><span style="color: #ff0000;">注意：</span></strong></p>
<p><strong><span style="color: #ff0000;">1.WeakSet初始化定义时，不能在里面存值。</span></strong></p>
<p><strong><span style="color: #ff0000;">2.WeakSet里面的add()方法只能存json对象，如果存字符串、数字等会报错！</span></strong></p>
<p>定义：</p>
<div class="cnblogs_code">
<pre><code>let set = <span style="color: #0000ff;">new</span> WeakSet();<span style="color: #008000;">//</span><span style="color: #008000;">WeakSet初始化定义时，不能在里面存值。</span>
let json =<span style="color: #000000;"> {
    a:</span>1<span style="color: #000000;">,
    b:</span>2<span style="color: #000000;">
};
let json2 </span>=<span style="color: #000000;"> {
    a:</span>'asp'<span style="color: #000000;">,
    b:</span>2<span style="color: #000000;">
};
set.add(json);
set.add(json2);</span><span style="color: #008000;">//</span><span style="color: #008000;">add()方法只能存json对象，如果存字符串、数字等会报错！</span>
<span style="color: #008000;">//set.add(true);</span><span style="color: #008000;">//</span><span style="color: #008000;">Invalid value used in weak set</span>
console.log(set);<span style="color: #008000;">//</span><span style="color: #008000;">WeakSet {Object {a: "asp", b: 2}, Object {a: 1, b: 2}}</span></pre>
</div>
<p>方法：Set数据结构提供的方法除了size属性和clear()方法没有，别的都有。(例如：add()、has()、delete())</p>
<h3>5.Map和WeakMap</h3>
<h4>5.1Map数据结构：类似json，但是json的键(key)只能是字符串，而map的key可以是任意类型</h4>
<p>使用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Map使用</span>
let map = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Map();
map.set(key,value);</span></pre>
</div>
<p>方法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Map使用</span>
let map = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Map();
let json </span>=<span style="color: #000000;"> {
    a:</span>1<span style="color: #000000;">,
    b:</span>2<span style="color: #000000;">
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> map.set(key,value);//设置一个值</span>
<span style="color: #000000;">
map.set(</span>'abc','123'<span style="color: #000000;">);
map.set(json,</span>'aaa'<span style="color: #000000;">);
map.set(</span>'a'<span style="color: #000000;">,json);
console.log(map);</span><span style="color: #008000;">//</span><span style="color: #008000;">Map(3) {"abc" =&gt; "123", Object {a: 1, b: 2} =&gt; "aaa", "a" =&gt; Object {a: 1, b: 2}}</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> map.get(key);//获取一个值</span>
<span style="color: #000000;">
console.log(map.get(json));</span><span style="color: #008000;">//</span><span style="color: #008000;">aaa</span>
console.log(map.get('a'));<span style="color: #008000;">//</span><span style="color: #008000;">Object {a: 1, b: 2}</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> map.delete(key);//删除某一项</span>
<span style="color: #000000;">
map.</span><span style="color: #0000ff;">delete</span>('abc'<span style="color: #000000;">);
console.log(map);</span><span style="color: #008000;">//</span><span style="color: #008000;">Map(2) { Object {a: 1, b: 2} =&gt; "aaa", "a" =&gt; Object {a: 1, b: 2}}</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> map.has(key);//查找某一项,返回布尔值</span>
<span style="color: #000000;">
console.log(map.has(</span>'abc'));<span style="color: #008000;">//</span><span style="color: #008000;">false</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> map.clear();//删除所有项</span>
<span style="color: #000000;">
map.clear();
console.log(map);</span><span style="color: #008000;">//</span><span style="color: #008000;">Map(0) {}</span></pre>
</div>
<p>循环map数据结构：</p>
<div class="cnblogs_code">
<pre><code>let map = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Map();
let json </span>=<span style="color: #000000;"> {
    a:</span>1<span style="color: #000000;">,
    b:</span>2<span style="color: #000000;">
}
map.set(</span>'abc','123'<span style="color: #000000;">);
map.set(json,</span>'aaa'<span style="color: #000000;">);
map.set(</span>'a'<span style="color: #000000;">,json);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 循环map</span>
<span style="color: #0000ff;">for</span>(let [key,value] of map){<span style="color: #008000;">//</span><span style="color: #008000;">默认entries</span>
<span style="color: #000000;">    console.log(key,value);
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">abc 123
    Object {a: 1, b: 2} "aaa"
    Object {a: 1, b: 2}</span><span style="color: #008000;">*/</span><span style="color: #000000;">
}
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(let key of map.keys()){}
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(let value of map.values()){}
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(let [key,value] of map.entries()){}
map.forEach((value,key)</span>=&gt;<span style="color: #000000;">{
    console.log(key,value);
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">abc 123
    Object {a: 1, b: 2} "aaa"
    Object {a: 1, b: 2}</span><span style="color: #008000;">*/</span><span style="color: #000000;">
});</span></pre>
</div>
<h4>5.1WeakMap数据结构：类似json，但是json的键(key)只能是字符串，而WeakMap的key只能是对象</h4>
<p>使用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> WeakMap使用</span>
let wmap = <span style="color: #0000ff;">new</span><span style="color: #000000;"> WeakMap();
let json </span>=<span style="color: #000000;"> {
    a:</span>1<span style="color: #000000;">,
    b:</span>2<span style="color: #000000;">
}
wmap.set(json,</span>'123'<span style="color: #000000;">);
console.log(wmap);</span><span style="color: #008000;">//</span><span style="color: #008000;">WeakMap {Object {a: 1, b: 2} =&gt; "123"}</span></pre>
</div>
<p><strong>总结：</strong></p>
<p><strong>1.Set &nbsp;里面是数组，不能重复，没有key(下标)，没有get方法</strong></p>
<p><strong>2.Map 对json功能增强，key可以是任意类型值</strong></p>
<h3>6.数字变化和Math新增的东西</h3>
<h4>6.1数字变化(数值变化)</h4>
<p>1.进制：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 二进制：(binary)</span>
let a =<span style="color: #000000;"> 0b010101;
console.log(a);</span><span style="color: #008000;">//</span><span style="color: #008000;">21</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 八进制：(Octal)</span>
let b =<span style="color: #000000;"> 0o652;
console.log(b);</span><span style="color: #008000;">//</span><span style="color: #008000;">426</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 十六进制：(Hexadecimal)</span>
let c = 0xabc<span style="color: #000000;">;
console.log(c);</span><span style="color: #008000;">//</span><span style="color: #008000;">2748</span></pre>
</div>
<p>2.数值判断</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 数字变化</span>
let a = 12<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;"> Number.isNaN：判断是否为NaN</span>
console.log(Number.isNaN(a));<span style="color: #008000;">//</span><span style="color: #008000;">false</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Number.isFinite：判断是否是数字</span>
let b = 'aaa'<span style="color: #000000;">;
console.log(Number.isFinite(b));</span><span style="color: #008000;">//</span><span style="color: #008000;">fasle</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Number.isInteger：判断是否是整数</span>
let c = 12.12<span style="color: #000000;">;
console.log(Number.isInteger(c));</span><span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(Number.isInteger(a));<span style="color: #008000;">//</span><span style="color: #008000;">true</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Number.parseInt()：将一个数据转换成整数</span>
console.log(Number.parseInt(2.5<span style="color: #000000;">));
</span><span style="color: #008000;">//</span><span style="color: #008000;"> Number.parseFloat()：将一个数据转换成浮点数</span>
console.log(Number.parseFloat("13.5526"));<span style="color: #008000;">//</span><span style="color: #008000;">13.5526</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Number.isSafeInteger()：判断是否是安全整数</span><span style="color: #008000;">
/*</span><span style="color: #008000;"> 安全整数：-(2^53-1)到(2^53-1) </span><span style="color: #008000;">*/</span><span style="color: #000000;">
console.log(Number.isSafeInteger(</span>-(2**53)));<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(Number.isSafeInteger(-(2**53-1)));<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(Number.isSafeInteger((2**53)));<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(Number.isSafeInteger((2**53-1)));<span style="color: #008000;">//</span><span style="color: #008000;">true</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Number.MAX_SAFE_INTEGER：最大安全整数</span>
console.log(Number.MAX_SAFE_INTEGER);<span style="color: #008000;">//</span><span style="color: #008000;">9007199254740991</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Number.MIN_SAFE_INTEGER：最小安全整数</span>
console.log(Number.MIN_SAFE_INTEGER);<span style="color: #008000;">//</span><span style="color: #008000;">-9007199254740991</span></pre>
</div>
<h4>6.2Math新增的东西</h4>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Math新增的东西</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Math.trunc()：截取数字整数部分</span>
console.log(Math.trunc(4.6));<span style="color: #008000;">//</span><span style="color: #008000;">4</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Math.sign()：判断一个数是正数、负数、0</span>
console.log(Math.sign(-5));<span style="color: #008000;">//</span><span style="color: #008000;">-1</span>
console.log(Math.sign(5));<span style="color: #008000;">//</span><span style="color: #008000;">1</span>
console.log(Math.sign(0));<span style="color: #008000;">//</span><span style="color: #008000;">0</span>
console.log(Math.sign(-0));<span style="color: #008000;">//</span><span style="color: #008000;">-0</span>
console.log(Math.sign('abc'));<span style="color: #008000;">//</span><span style="color: #008000;">NaN</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Math.cbrt()：计算一个数的立方根</span>
console.log(Math.cbrt(27));<span style="color: #008000;">//</span><span style="color: #008000;">3</span><span style="color: #008000;">
//</span><span style="color: #008000;"> ...等等</span></pre>
</div>
<h3>7.ES2018(ES9)新增的东西</h3>
<h4>7.1命名捕获(用于正则匹配)</h4>
<p>语法：(?&lt;名字&gt;)</p>
<p>以前写正则，要把捕获到的数据赋给变量，都是这么写的</p>
<div class="cnblogs_code">
<pre><code>let today = "2019-05-03"<span style="color: #000000;">;
let reg </span>= /(\d{4})-(\d{2})-(\d{2})/<span style="color: #000000;">;
let dateArr </span>=<span style="color: #000000;"> today.match(reg);
let [full,year,month,day,...more] </span>=<span style="color: #000000;"> dateArr;
console.log(year,month,day);</span><span style="color: #008000;">//</span><span style="color: #008000;">2019 05 03</span></pre>
</div>
<p>现在，我们可以这么写：</p>
<div class="cnblogs_code">
<pre><code>let today = "2019-05-03"<span style="color: #000000;">;
let reg </span>= /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/;<span style="color: #008000;">//</span><span style="color: #008000;">建议在Chrome浏览器下测试，别的浏览器可能会报错。</span>
let {year,month,day} =<span style="color: #000000;"> today.match(reg).groups;
console.log(year,month,day);</span><span style="color: #008000;">//</span><span style="color: #008000;">2019 05 03</span></pre>
</div>
<h4>7.2反向引用命名捕获</h4>
<p>1.反向引用以前写法：</p>
<p>(1)\1 \2(字符串写法) &nbsp; &nbsp;(2)$1 $2(str.replace()方法写法)</p>
<p>语法：\k&lt;名字&gt;</p>
<p>如果要匹配和前面组相同的多个，可以这么写</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 匹配："monday-monday"</span><span style="color: #008000;">
//</span><span style="color: #008000;"> let reg = /^(?&lt;m&gt;monday)-\k&lt;m&gt;$/;</span><span style="color: #008000;">
//</span><span style="color: #008000;"> let str = 'a-a';</span><span style="color: #008000;">
//</span><span style="color: #008000;"> let str2 = 'm-m';</span><span style="color: #008000;">
//</span><span style="color: #008000;"> let str3 = 'monday-monday';</span><span style="color: #008000;">
//</span><span style="color: #008000;"> console.log(reg.test(str));//false</span><span style="color: #008000;">
//</span><span style="color: #008000;"> console.log(reg.test(str2));//false</span><span style="color: #008000;">
//</span><span style="color: #008000;"> console.log(reg.test(str3));//true</span>

<span style="color: #008000;">//</span><span style="color: #008000;"> 匹配："monday-monday-monday"</span>
let reg = /^(?&lt;m&gt;monday)-\k&lt;m&gt;-\1$/;<span style="color: #008000;">//</span><span style="color: #008000;">或者let reg = /^(?&lt;m&gt;monday)-\k&lt;m&gt;-\k&lt;m&gt;$/;</span>
let str = 'a-a'<span style="color: #000000;">;
let str2 </span>= 'm-m'<span style="color: #000000;">;
let str3 </span>= 'monday-monday'<span style="color: #000000;">;
let str4 </span>= 'monday-monday-monday'<span style="color: #000000;">;
console.log(reg.test(str));</span><span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(reg.test(str2));<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(reg.test(str3));<span style="color: #008000;">//</span><span style="color: #008000;">false</span>
console.log(reg.test(str4));<span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p>2.替换：$&lt;名字&gt;</p>
<p>例如：正则转换日期格式：</p>
<div class="cnblogs_code">
<pre><code>let str = '2019-05-03'<span style="color: #000000;">;
let reg </span>= /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/<span style="color: #000000;">;

let str1 </span>= str.replace(reg,'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'<span style="color: #000000;">);
console.log(str);</span><span style="color: #008000;">//</span><span style="color: #008000;">2019-05-03</span>
console.log(str1);<span style="color: #008000;">//</span><span style="color: #008000;">03/05/2019</span></pre>
</div>
<p>结合回调函数：</p>
<div class="cnblogs_code">
<pre><code>let str = '2019-05-03'<span style="color: #000000;">;
let reg </span>= /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/<span style="color: #000000;">;

let str1 </span>= str.replace(reg,(...args)=&gt;<span style="color: #000000;">{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> console.log(args);</span>
    let {year,month,day} = args[args.length-1<span style="color: #000000;">];
    </span><span style="color: #0000ff;">return</span> `${day}/${month}/<span style="color: #000000;">${year}`;
});
console.log(str1);</span><span style="color: #008000;">//</span><span style="color: #008000;">03/05/2019</span></pre>
</div>
<h4>7.3dotAll模式(用s)来表示：匹配任意东西</h4>
<p>之前，如果用正则匹配任意东西，用&lsquo;.&rsquo;来匹配，但不包括\n，所以之前如果匹配\n之类的东西，是这么写的</p>
<div class="cnblogs_code">
<pre><code>let reg = /^\w+.\w+$/m;<span style="color: #008000;">//</span><span style="color: #008000;">注：在结尾处加m表示多行模式</span>
let str = 'turn-\noff'<span style="color: #000000;">;
console.log(reg.test(str));</span><span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p>但是如果匹配一些别的文字，比如换行符&rsquo;\n&lsquo;，会匹配失败</p>
<div class="cnblogs_code">
<pre><code>let reg = /^\w+.\w+$/<span style="color: #000000;">m;
let str </span>= 'turn\noff'<span style="color: #000000;">;
console.log(reg.test(str));</span><span style="color: #008000;">//</span><span style="color: #008000;">false</span></pre>
</div>
<p>现在可以用dotAll模式来匹配(结尾处加s即可)：</p>
<div class="cnblogs_code">
<pre><code>let reg = /^\w+.\w+$/s;<span style="color: #008000;">//</span><span style="color: #008000;">加s表示为dotAll模式</span>
let str = 'turn\noff'<span style="color: #000000;">;
console.log(reg.test(str));</span><span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<h4>7.3标签函数</h4>
<p>定义：和定义普通函数一样</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){

}</span></pre>
</div>
<p>调用：</p>
<div class="cnblogs_code">
<pre><code>fn();<span style="color: #008000;">//</span><span style="color: #008000;">这样调用就是普通函数</span>
fn`aaa`;<span style="color: #008000;">//</span><span style="color: #008000;">标签函数的调用</span></pre>
</div>
<p>Demo：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(args){
    </span><span style="color: #0000ff;">return</span> args[0].toUpperCase();<span style="color: #008000;">//</span><span style="color: #008000;">将第一个参数转为大写</span>
<span style="color: #000000;">}
console.log(fn`panda`);</span><span style="color: #008000;">//</span><span style="color: #008000;">调用标签函数</span></pre>
</div>
<h4>7.4Proxy代理(扩展或增强对象的一些功能)</h4>
<p>作用：比如vue中的拦截，预警、上报、扩展功能、统计、增强对象等等；proxy是设计模式的一种，叫做代理模式。</p>
<p>语法：new Proxy(target,handler)，target为被代理的对象，handler对代理的对象做什么操作</p>
<div class="cnblogs_code">
<pre><code>let obj = {<span style="color: #008000;">//</span><span style="color: #008000;">此对象不暴露给外部</span>
    name:'jack'<span style="color: #000000;">
};
let newObj </span>= <span style="color: #0000ff;">new</span> Proxy(obj,{<span style="color: #008000;">//</span><span style="color: #008000;">此对象是暴露给外部的obj</span>
<span style="color: #000000;">    get(target,property){
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> console.log(target,property);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> 在访问属性之前做一些操作</span>
<span style="color: #000000;">        console.log(`您访问了${property}属性`);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> target[property];
    }
}
);
console.log(newObj.name);</span><span style="color: #008000;">//</span><span style="color: #008000;">您访问了name属性 jack</span></pre>
</div>
<p><strong>proxy对象的get(target,property)：</strong>简单封装创建DOM元素的方法：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;"> 使用proxy对象简单封装创建DOM元素的方法 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
const DOM </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Proxy({},{
    get(target,property){
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> console.log(target,property);</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span>(attr=<span style="color: #000000;">{},...children){
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> console.log(attr,children);</span>
            let el =<span style="color: #000000;"> document.createElement(property);
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(key of Object.keys(attr)){
                el.setAttribute(key,attr[key]);
            }
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(child of Object.values(children)){
                </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">typeof</span> child == 'string'<span style="color: #000000;">){
                    child </span>=<span style="color: #000000;"> document.createTextNode(child);
                }
                el.appendChild(child);
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> el;
        }
    }
});
let oDiv </span>=<span style="color: #000000;"> DOM.div(
    {id:</span>'div1'},'我是div','哈哈哈'<span style="color: #000000;">,
    DOM.a({href:</span>'http://www.baidu.com'},'访问百度'<span style="color: #000000;">),
    DOM.ul({},
        DOM.li({},</span>'1111'<span style="color: #000000;">),
        DOM.li({},</span>'2222'<span style="color: #000000;">),
        DOM.li({},</span>'3333'<span style="color: #000000;">),
        DOM.li({},</span>'4444'<span style="color: #000000;">)
    )
);
window.onload </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    document.body.appendChild(oDiv);
}</span></pre>
</div>
<p><strong>proxy对象的set(target,prop,value)：检测设置年龄是否达到要求</strong></p>
<div class="cnblogs_code">
<pre><code>let obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Proxy({},{
    set(target,prop,value){
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> console.log(target,prop,value);</span>
        <span style="color: #0000ff;">if</span>(prop == 'age'<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">Number.isInteger(value)){
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> TypeError('年龄必须为整数'<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">if</span>(value&gt;200<span style="color: #000000;">){
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RangeError('年龄超标了，必须小于200岁'<span style="color: #000000;">);
            }
        }
        target[prop]</span>=<span style="color: #000000;">value;
    }
});
obj.a </span>= 123<span style="color: #000000;">;
obj.name </span>= 'pilot'<span style="color: #000000;">;
console.log(obj);
obj.age </span>= 201;</pre>
</div>
<p><strong>proxy对象的deleteProperty(target,property)：删除对象属性之前，显示提示信息</strong></p>
<div class="cnblogs_code">
<pre><code>let json =<span style="color: #000000;"> {
    a:</span>1<span style="color: #000000;">,
    b:</span>2<span style="color: #000000;">
}
let newJson </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Proxy(json,{
    deleteProperty(target,property){
        console.log(`您要删除${property}属性`);
        </span><span style="color: #0000ff;">delete</span><span style="color: #000000;"> target[property];
    }
});
</span><span style="color: #0000ff;">delete</span><span style="color: #000000;"> newJson.a;
console.log(newJson);</span></pre>
</div>
<p><strong><strong>proxy对象的has(target,property)：</strong></strong></p>
<div class="cnblogs_code">
<pre><code>let json =<span style="color: #000000;"> {
    a:</span>1<span style="color: #000000;">,
    b:</span>2<span style="color: #000000;">
}
let newJson </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Proxy(json,{
    has(target,property){
        console.log(`判断是否存在调用has方法`);
        </span><span style="color: #0000ff;">return</span> property <span style="color: #0000ff;">in</span><span style="color: #000000;"> target;
    }
});
console.log(</span>'a' <span style="color: #0000ff;">in</span> newJson);<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(newJson);</pre>
</div>
<p><strong>proxy对象的apply()：</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){
    </span><span style="color: #0000ff;">return</span> '我是一个函数'<span style="color: #000000;">;
}
let newFn </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Proxy(fn,{
    apply(){
        </span><span style="color: #0000ff;">return</span> '函数么?'<span style="color: #000000;">;
    }
});
console.log(newFn());</span></pre>
</div>
<p>apply结合reflect()来使用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> sum(a,b){
    </span><span style="color: #0000ff;">return</span> a+<span style="color: #000000;">b;
}
let newSum </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Proxy(sum,{
    apply(target,context,args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> console.log(target,context,args);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">console.log(...arguments);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> return Reflect.apply(...arguments);//8</span>
        <span style="color: #0000ff;">return</span> Reflect.apply(...arguments)**2;<span style="color: #008000;">//</span><span style="color: #008000;">64</span>
<span style="color: #000000;">    }
});
console.log(newSum(</span>3,5));</pre>
</div>
<h4>7.5Reflect反射：<strong>类似fn.call()、fn.apply()</strong></h4>
<p>定义：Reflect.apply(调用的函数,this指向,参数数组)</p>
<p>调用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> console.log(Math.ceil(5.2));//6</span>
let res = Reflect.apply(Math.ceil,<span style="color: #0000ff;">null</span>,[6.8<span style="color: #000000;">]);
console.log(res);</span><span style="color: #008000;">//</span><span style="color: #008000;">7</span></pre>
</div>
<p>检测对象的某一项属性是否存在：</p>
<div class="cnblogs_code">
<pre><code>console.log(Reflect.has(Object,'assign'));<span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p>删除对象的某一项属性：</p>
<div class="cnblogs_code">
<pre><code>let json = {a:1,b:2<span style="color: #000000;">};
Reflect.deleteProperty(json,</span>'a'<span style="color: #000000;">);
console.log(json);</span><span style="color: #008000;">//</span><span style="color: #008000;">{b: 2}</span></pre>
</div>
<p>---------------------END---------------------</p>
<p>到这也就全部都完了，ES6以及ESNext的一些东西，下面附上其他俩个部分的地址，感谢观看！</p>
<p><a title="javascript的ES6学习总结(第一部分)" href="https://www.cnblogs.com/abc-x/p/10663786.html" target="_blank">javascript的ES6学习总结(第一部分)</a></p>
<p><a title="javascript的ES6学习总结(第二部分)" href="https://www.cnblogs.com/abc-x/p/10744897.html" target="_blank">javascript的ES6学习总结(第二部分)</a></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>