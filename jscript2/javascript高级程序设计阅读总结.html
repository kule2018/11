<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修javascript高级程序设计阅读总结' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>javascript高级程序设计阅读总结</center></div><div class='banquan'>原文出处:本文由博客园博主smile_or提供。<br/>
原文连接:https://www.cnblogs.com/sgs123/p/10978680.html</div><br>
    <h2 id="章-引用类型">5章 引用类型</h2>
<h3 id="object类型">1、object类型</h3>
<ul>
<li>创建<br />
1、var obj ={} ---对象字面量<br />
2、var obj = new Object(); ---new操作符</li>
</ul>
<h3 id="array类型">2、Array类型</h3>
<ul>
<li>创建<br />
1、var arr = new Array();<br />
2、var arr = [];</li>
</ul>
<h4 id="检测数组">检测数组</h4>
<ul>
<li>instanceof</li>
<li>Array.isArray()</li>
</ul>
<h4 id="转换方法">转换方法</h4>
<ul>
<li>所有对象都具有 toLocaleString() 、 toString() 和 valueOf() 方法</li>
<li>join() ----数组转为字符串</li>
</ul>
<h4 id="栈方法队列方法">栈方法、队列方法</h4>
<ul>
<li>push() 和 pop() ---向后推入(返回值为长度) 和 弹出(返回值为弹出值)</li>
<li>unshift() 和 shift() ---向前推入(返回值为长度) 和 弹出(返回值为弹出值)</li>
</ul>
<h4 id="重排序方法">重排序方法</h4>
<ul>
<li>reverse() ---反转数组项的顺序</li>
<li>sort() ---按升序排列数组项</li>
</ul>
<pre><code><code>    //比较函数（数字排序）
    function compare1(value1, value2){
        return value2 - value1;
    }
    //对象按照对应的属性排序
    var arr =[{
        &#39;name&#39;: &#39;ccc&#39;,
        &#39;age&#39;: 12,
    },{
        &#39;name&#39;: &#39;bbb&#39;,
        &#39;age&#39;: 8,  
    },
    {
        &#39;name&#39;: &#39;aaa&#39;,
        &#39;age&#39;: 45,
    }]
    function compare(propertyName){
        return function(obj1,obj2){
            var value1 = obj1[propertyName];
            var value2 = obj2[propertyName];
            if(value1&lt;value2){
                return -1;
            }else if(value1&gt;value2){
                return 1;
            }else{
                return 0;
            }
        }
    }
    var resulte = arr.sort(compare(&#39;name&#39;));
    console.log(resulte)</code></pre>
<h4 id="操作方法">操作方法</h4>
<ul>
<li>concat()---基于当前数组中的所有项创建一个新数组（数组拼接）</li>
<li>slice()---接受一或两个参数，即要返回项的起始和结束位置(数组切割)</li>
<li>splice()
<ul>
<li>删除 需提供第一项的位置，第二项为删除的个数</li>
<li>插入 需提供第一项的位置，第二项为0，第三项为插入的内容</li>
<li>替换 需提供第一项的位置，第二项为需替换的个数，第三项为插入的内容</li>
</ul></li>
</ul>
<h4 id="位置方法">位置方法</h4>
<ul>
<li>indexOf() 和 lastIndexOf() ---这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引</li>
</ul>
<h4 id="迭代方法">迭代方法</h4>
<ul>
<li>every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。</li>
<li>some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 。<br />
</li>
<li>filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li>map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
</ul>
<h4 id="归并方法">归并方法</h4>
<ul>
<li>reduce() 和 reduceRight():这两个方法都会迭代数组的所有项，然后构建一个最终返回的值</li>
</ul>
<pre><code><code>    //reduceRight() 从右开始
    var values = [1,2,3,4,5];
    var sum = values.reduce(function(prev, cur, index, array){
    return prev + cur;
    });
    alert(sum); //15</code></pre>
<h3 id="date类型">3、Date类型</h3>
<ul>
<li>创建<br />
var date = new Date();</li>
<li>日期格式化方法：
<ul>
<li>toDateString() ——以特定于实现格式显示星期几、月、日和年；</li>
<li>toTimeString() ——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString() ——以特定于实现的格式完整的 UTC 日期。</li>
</ul></li>
<li>日期/时间组件方法：
<ul>
<li>getTime() 返回表示日期的毫秒数；与 valueOf() 方法返回的值相同</li>
<li>getFullYear() 取得4位数的年份（如2007而非仅07）</li>
<li>getMonth() 返回日期中的月份，其中0表示一月，11表示十二月</li>
<li>getDate() 返回日期月份中的天数（1到31）</li>
<li>getDay() 返回日期中星期的星期几（其中0表示星期日，6表示星期六）</li>
<li>getHours() 返回日期中的小时数（0到23）</li>
<li>getMinutes() 返回日期中的分钟数（0到59）</li>
<li>getSeconds() 返回日期中的秒数（0到59）</li>
<li>getMilliseconds() 返回日期中的毫秒数<br />
set表示设置</li>
</ul></li>
</ul>
<h3 id="regexp类型">4、RegExp类型</h3>
<ul>
<li>创建<br />
1.var expression = /pattern/flags;<br />
2.var expression2 = new RegExp(&quot;pattern&quot;,&quot;flags&quot;);</li>
<li>实例属性：
<ul>
<li>global ：布尔值，表示是否设置了 g 标志。</li>
<li>ignoreCase ：布尔值，表示是否设置了 i 标志。</li>
<li>lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</li>
<li>multiline ：布尔值，表示是否设置了 m 标志。</li>
<li>source ：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul></li>
<li>实例方法：
<ul>
<li>exec() 接受一个参数，即<br />
要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null 。</li>
<li>test() 它接受一个字符串参数。在模式与该参数匹配的情况下返回true ；否则，返回 false</li>
</ul></li>
<li>RegExp 构造函数属性
<ul>
<li>input 属性返回了原始字符串；</li>
<li>leftContext 属性返回了单词 short 之前的字符串，而 rightContext 属性则返回了 short<br />
之后的字符串；</li>
<li>lastMatch 属性返回最近一次与整个正则表达式匹配的字符串，即 short ；</li>
<li>lastParen 属性返回最近一次匹配的捕获组，即例子中的 s 。</li>
</ul></li>
</ul>
<h3 id="function类型">5、function类型</h3>
<ul>
<li>创建<br />
1、function fn(){}<br />
2、var fn = function(){};<br />
3、var fn = new Function(); //不推荐</li>
<li>做为值的函数</li>
</ul>
<pre><code><code>    //对象按照对应的属性排序
        var arr =[{
            &#39;name&#39;: &#39;ccc&#39;,
            &#39;age&#39;: 12,
        },{
            &#39;name&#39;: &#39;bbb&#39;,
            &#39;age&#39;: 8,  
        },
        {
            &#39;name&#39;: &#39;aaa&#39;,
            &#39;age&#39;: 45,
        }]
        function compare(propertyName){
            return function(obj1,obj2){
                var value1 = obj1[propertyName];
                var value2 = obj2[propertyName];
                if(value1&lt;value2){
                    return -1;
                }else if(value1&gt;value2){
                    return 1;
                }else{
                    return 0;
                }
            }
        }
        var resulte = arr.sort(compare(&#39;name&#39;));
        console.log(resulte)</code></pre>
<ul>
<li>函数内部属性
<ul>
<li>this对象<br />
</li>
<li>arguments对象 --&gt;arguments.callee代表函数指针</li>
<li>caller --&gt;调用当前函数的函数的引用(arguments.callee.caller)</li>
</ul>
<pre><code><code>  //定义阶乘
  //递归算法 arguments.callee(优先使用)) 等价于 factory 
  function factory(num){
      var resulte = 0;
      if(num&lt;=1){
          return 1;
      }else{
          return num * arguments.callee(num - 1);
      }

  }
  console.log(factory(4));</code></pre></li>
<li>函数的属性和方法
<ul>
<li>属性
<ul>
<li>length 表示函数希望接收的命名参数的个数</li>
<li>prototype 保存它们所有实例方法</li>
</ul></li>
<li>方法
<ul>
<li>apply() --&gt; 一个<br />
是在其中运行函数的作用域，另一个是参数数组(arguments 或者 数组)</li>
<li>call() --&gt; 另一个是参数需逐个列举出来</li>
<li>bind() --&gt; 这个方法会创建一个函数的实例，其 this 值会被绑<br />
定到传给 bind() 函数的值</li>
</ul></li>
</ul></li>
</ul>
<h3 id="基本包装类型">6、基本包装类型</h3>
<h4 id="boolean类型----建议不要使用">Boolean类型 -- 建议不要使用</h4>
<h4 id="number类型">Number类型</h4>
<ul>
<li>toFixed() -- 保留小数</li>
<li>toExponential() -- e 表示法</li>
<li>toPrecision() --以上两者结合</li>
</ul>
<h4 id="string类型">String类型</h4>
<ul>
<li>str.charAt(i) 等价于 str[i] -- 返回对应下标的字符</li>
<li>str.charCodeAt(i) --返回对应下标的字符编码</li>
<li>-----字符串操作方法-----</li>
<li>concat()</li>
<li>slice()、substr()、substring() --- 切割字符串方法，接收两个参数
<ul>
<li>第一个开始位置，第二个结束位置。只传一个参数默认到最后，substr第二个参数指返回字符的个数</li>
<li>如果有负数:slice()方法会将传入的负值与字符串的长度相加,----------------substr() 方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为 0,------------ substring() 方法会把所有负值参数都转换为 0</li>
</ul></li>
<li>-----字符串位置方法-----</li>
<li>indexOf() 、lastIndexOf() ---查找字符，返回下标，没找到返回-1
<ul>
<li>都可以接收第二个参数，表示从字符串中的哪个位置开始搜索</li>
</ul></li>
<li>trim() ---删除前置及后缀的所有空格<br />
</li>
<li>-----字符大小写转换方法-----</li>
<li>toLocaleUpperCase() 和 toUpperCase() ---转大写，前者针对地区</li>
<li>toLocaleLowerCase() 和 toLowerCase() ---转小写，前者针对地区</li>
<li>-----字符串的模式匹配方法-----</li>
<li>match() --- 只接收一个参数(正则表达式、regExp对象、字符串)，返回一个符合匹配的数组,支持g,没找到返回null</li>
<li>search() ---只接收一个参数(正则表达式、regExp对象、字符串)，返回一个第一次出现位置的下标，不支持g，没找到返回-1</li>
<li>replace() ---接收两个参数，第一个参数可以是一个 RegExp 对象或者一个字符串，第二个参数可以是一个字符串或者一个函数</li>
</ul>
<pre><code><code>    //$&amp; 匹配整个模式的子字符串
    //$&#39; 匹配的子字符串之前的子字符串
    //$` 匹配的子字符串之后的子字符串
    //$n 匹配第n个捕获组的子字符串，其中n等于0～9
    //$nn 匹配第nn个捕获组的子字符串，其中nn等于01～99
    var text = &quot;cat, bat, sat, fat&quot;;
    result = text.replace(/(.at)/g, &quot;word ($1)&quot;);
    alert(result); //word (cat), word (bat), word (sat), word (fat)</code></pre>
<ul>
<li>split() ---基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中,接受可选的第二个参数，用于指定数组的大小</li>
<li>localeCompare() ---比较两个字符串 ,参数之前，返回-1，参数之后返回1，等于返回0</li>
<li>romCharCode() ---接收一或多个字符编码，然后将它们转换成一个字符串</li>
</ul>
<pre><code><code>    alert(String.fromCharCode(104, 101, 108, 108, 111)); //&quot;hello&quot;</code></pre>
<h3 id="单体内置对象">7、单体内置对象</h3>
<h4 id="global-对象">Global 对象</h4>
<ul>
<li>URI编码方法</li>
<li>eval() 方法 ---可以执行放在字符串中的代码，简单理解就是去掉最外层的引号</li>
</ul>
<h4 id="math-对象">Math 对象</h4>
<ul>
<li>Math对象属性：<br />
<img src="./images/javascript高级程序设计阅读总结0.png" /></li>
<li>min() max()方法</li>
<li>舍入方法：ceil()--向上取整 、floor()--向下取整、round()--四舍五入</li>
<li>random() ---返回大于等于 0 小于 1 的一个随机数<br />
<code>javascript       //获得min~max之间随机数公式       Math.random()*(max - min) + min;</code></li>
<li>其他方法：<br />
<img src="./images/javascript高级程序设计阅读总结1.png" /></li>
</ul>
<h2 id="章-面向对象的程序设计">6 章 面向对象的程序设计</h2>
<h3 id="对象的属性">1、对象的属性</h3>
<h4 id="数据属性">数据属性</h4>
<ul>
<li>Configurable ：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特<br />
性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的<br />
这个特性默认值为 true 。</li>
<li>Enumerable ：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定<br />
义的属性，它们的这个特性默认值为 true 。</li>
<li>Writable ：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的<br />
这个特性默认值为 true 。</li>
<li>Value ：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，<br />
把新值保存在这个位置。这个特性的默认值为 undefined 。
<ul>
<li>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法</li>
<li>这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象</li>
</ul></li>
</ul>
<h4 id="访问器属性">访问器属性</h4>
<ul>
<li>Configurable ：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特<br />
性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为<br />
true 。</li>
<li>Enumerable ：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这<br />
个特性的默认值为 true 。</li>
<li>Get ：在读取属性时调用的函数。默认值为 undefined 。</li>
<li>Set ：在写入属性时调用的函数。默认值为 undefined 。
<ul>
<li>访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义</li>
</ul>
<pre><code><code>    var book = {
        _year: 2004,
        edition: 1
    };
    Object.defineProperty(book, &quot;year&quot;, {
        get: function(){
            return this._year;
        },
        set: function(newValue){
            if (newValue &gt; 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    });
    book.year = 2005;
    alert(book.edition); //2</code></pre></li>
</ul>
<h4 id="定义多个属性">定义多个属性</h4>
<ul>
<li>Object.defineProperties()
<ul>
<li>这个方法接收两个对象参数:要添加和修改其属性的对象和要添加或修改的属性一一对应</li>
</ul></li>
</ul>
<h4 id="读取属性的特性">读取属性的特性</h4>
<ul>
<li>Object.getOwnPropertyDescriptor()
<ul>
<li>这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称</li>
<li>返回值是一个对象</li>
</ul></li>
</ul>
<h3 id="创建对象">2、创建对象</h3>
<h4 id="工厂模式不要使用">工厂模式（不要使用）</h4>
<pre><code><code>    function createPerson(name,age){
        var obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.sayName = function(){
            alert(this.name);
        };
        return obj;
    }

    var person1 = createPerson(&#39;marry&#39;,39);
    var person2 = createPerson(&#39;jane&#39;,25);</code></pre>
<h4 id="构造函数模式">构造函数模式</h4>
<pre><code><code>    function Person(name,age){
        this.name = name;
        this.age = age;
        this.sayName = function(){
            alert(this.name);
        };
    }

    var person1 = new Person(&#39;marry&#39;,39);
    var person2 = new Person(&#39;jane&#39;,25);</code></pre>
<ul>
<li>构造函数名开头应该大写</li>
<li>使用new关键字(4步:创建--改指向--添加属性--返回)</li>
</ul>
<h4 id="原型模式">原型模式</h4>
<pre><code><code>    function Person(){
    }
    Person.prototype.name = &quot;Nicholas&quot;;
    Person.prototype.age = 29;
    Person.prototype.job = &quot;Software Engineer&quot;;
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person1 = new Person();
    person1.sayName(); //&quot;Nicholas&quot;
    var person2 = new Person();
    person2.sayName(); //&quot;Nicholas&quot;
    alert(person1.sayName == person2.sayName); //true</code></pre>
<h3 id="继承">3、继承</h3>
<h4 id="原型链">原型链</h4>
<ul>
<li>基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>问题：
<ul>
<li>包含引用类型值的原型属性会被所有实例共享</li>
<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li>
</ul>
<pre><code><code>  function SuperType() {
      this.property = true;
  }
  SuperType.prototype.getSuperValue = function () {
      return this.property;
  };

  function SubType(){
      this.subproperty = false;
  }
  SubType.prototype = new SuperType()
  // 使用字面量添加新方法，会导致上一行代码无效
  // SubType.prototype = {
  //     getSubValue:function(){
  //         return this.subproperty;
  //     },
  //     getSuperValue:function(){
  //         return false;
  //     }
  // }

  SubType.prototype.getSubValue = function(){
      return this.subproperty;
  }
  SubType.prototype.getSuperValue = function(){
      return false;
  }

  var instance = new SubType();
  console.log(instance)</code></pre></li>
</ul>
<h4 id="借用构造函数">借用构造函数</h4>
<pre><code><code>    function SupperType(name){
        this.name = name
    }
    function SubType(){
        //继承了 SuperType，同时还传递了参数
        SupperType.call(this,&#39;jane&#39;);
        //实例属性
        this.age = 29;
    }
    var instance = new SubType();
    alert(instance.name); //&#39;jane&#39;
    alert(instance.age); //29</code></pre>
<ul>
<li>优势：在子类型构造函数中向超类型构造函数中传递参数</li>
<li>问题：方法都定义在了构造函数中，函数不能复用，很少使用</li>
</ul>
<h4 id="组合继承">组合继承</h4>
<ul>
<li>原型链和借用构造函数的技术组合到一块</li>
<li>优势：没有问题</li>
</ul>
<pre><code><code>    function SuperType(name) {
        this.name = name;
        this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
    }
    SuperType.prototype.sayName = function () {
        alert(this.name);
    } 

    function SubType(name, age) {
        //继承属性
        SuperType.call(this, name);
        this.age = age;
    }
    //继承方法
    SubType.prototype = new SuperType(); 
    SubType.prototype.constructor = SubType;
    SubType.prototype.sayAge = function () {
        alert(this.age);
    };

    var instance1 = new SubType(&quot;Nicholas&quot;, 29);
    instance1.colors.push(&quot;black&quot;);
    var instance2 = new SubType(&quot;marry&quot;, 30);

    console.log(instance1)
    console.log(instance2)</code></pre>
<h4 id="原型式继承">原型式继承</h4>
<ul>
<li>问题：包含引用类型值的属性始终都会共享相应的值</li>
</ul>
<pre><code><code>    var person = {
        name: &quot;Nicholas&quot;,
        friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
    };
    var anotherPerson = Object.create(person, {
        name: {
            value: &quot;Greg&quot;
        }
    });
    alert(anotherPerson.name); //&quot;Greg&quot;</code></pre>
<h4 id="寄生式继承">寄生式继承</h4>
<ul>
<li>问题：由于不能做到函数复用而降低效率</li>
</ul>
<pre><code><code>    function createAnother(original) {
        var clone = new Object(original); //通过调用函数创建一个新对象
        clone.sayHi = function () { //以某种方式来增强这个对象
            alert(&quot;hi&quot;);
        };
        return clone; //返回这个对象
    }
    var person = {
        name: &quot;Nicholas&quot;,
        friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
    };
    var anotherPerson = createAnother(person);
    console.log(anotherPerson)</code></pre>
<h4 id="寄生组合式继承">寄生组合式继承</h4>
<ul>
<li>高效率体现在它只调用了一次 SuperType 构造函数</li>
<li>集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</li>
</ul>
<pre><code><code>    function inheritPrototype(subType, superType) {
        var prototype = new Object(superType.prototype);
        prototype.constructor = subType;
        subType.prototype = prototype;
    }

    function SuperType(name) {
        this.name = name;
        this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
    }
    SuperType.prototype.sayName = function () {
        alert(this.name);
    } 

    function SubType(name, age) {
        //继承属性
        SuperType.call(this, name);
        this.age = age;
    }
    inheritPrototype(SubType,SuperType);

    var instance1 = new SubType(&quot;Nicholas&quot;, 29);
    instance1.colors.push(&quot;black&quot;);
    var instance2 = new SubType(&quot;marry&quot;, 30);

    console.log(instance1)
    console.log(instance2)</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>