<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修jsp     JavaBean      el表达式' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>jsp     JavaBean      el表达式</center></div><div class='banquan'>原文出处:本文由博客园博主新兵蛋蛋程序员提供。<br/>
原文连接:https://www.cnblogs.com/0307lmy/p/11509993.html</div><br>
    <p>JSP三大指令<br />  一个jsp页面中，可以有0~N个指令的定义！</p>
<p>1. page --&gt; 最复杂：&lt;%@page language="java" info="xxx"...%&gt;<br />  * pageEncoding和contentType：<br />    &gt; pageEncoding：它指定当前jsp页面的编码，只要不说谎，就不会有乱码！在服务器要把jsp编译成.java时需要使用pageEncoding!<br />    &gt; contentType：它表示添加一个响应头：Content-Type！等同与response.setContentType("text/html;charset=utf-8");<br />    &gt; 如果两个属性只提供一个，那么另一个的默认值为设置那一个。<br />    &gt; 如果两个属性都没有设置，那么默认为iso8859-1<br />  * import：导包！可以出现多次<br />  * errorPage和isErrorPage<br />    &gt; errorPage：当前页面如果抛出异常，那么要转发到哪一个页面，由errorPage来指定<br />	* 路径：加上&ldquo;/&rdquo;表示项目路径 不加&ldquo;/&rdquo;表示当前页面所在路径<br />    &gt; isErrorPage：它指定当前页面是否为处理错误的页面！当该属性为true时，<br />	这个页面会设置状态码为500！而且这个页面可以使用9大内置对象中的exception!<br />  *   &lt;error-page&gt;<br />  	&lt;error-code&gt;404&lt;/error-code&gt;<br />  	&lt;location&gt;/error/errorPage.jsp&lt;/location&gt;<br />      &lt;/error-page&gt;<br />      &lt;error-page&gt;<br />        &lt;error-code&gt;500&lt;/error-code&gt;<br />        &lt;location&gt;/error/errorPage.jsp&lt;/location&gt;<br />      &lt;/error-page&gt;<br />      &lt;error-page&gt;<br />        &lt;exception-type&gt;java.lang.RuntimeException&lt;/exception-type&gt;<br />        &lt;location&gt;/index.jsp&lt;/location&gt;<br />      &lt;/error-page&gt;<br />   * autoFlush和buffer<br />     &gt; autoFlush：指定jsp的输出流缓冲区满时，是否自动刷新！默认为true，如果为false，那么在缓冲区满时抛出异常！<br />     &gt; buffer：指定缓冲区大小，默认为8kb，通常不需要修改！<br />   * isELIgnored：是否忽略el表达式，默认值为false，不忽略，即支持！<br />   * 基本没用：<br />     &gt; language：指定当前jsp编译后的语言类型，默认值为java。<br />     &gt; info：信息！<br />     &gt; isThreadSafe：当前的jsp是否支持并发访问！<br />     &gt; session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象！<br />     &gt; extends：让jsp生成的servlet去继承该属性指定的类！</p>
<p>2. include --&gt; 静态包含<br />  * 属性：file="路径"<br />  * 与RequestDispatcher的include()方法的功能相似！<br />  * &lt;%@include%&gt; 它是在jsp编译成java文件时完成的！他们共同生成一个java(就是一个servlet)文件，然后再生成一个class！<br />  * RequestDispatcher的include()是一个方法，包含和被包含的是两个servlet，即两个.class！他们只是把响应的内容在运行时合并了！<br />  * 作用：把页面分解了，使用包含的方式组合在一起，这样一个页面中不变的部分，就是一个独立jsp，而我们只需要处理变化的页面。<br />  * 可以放在任意位置<br />3. taglib --&gt; 导入标签库<br />  * 两个属性：<br />    &gt; prefix：指定标签库在本页面中的前缀！由我们自己来起名称！<br />    &gt; uri: 指定标签库的位置！<br />    &gt; &lt;%@taglib prefix="s" uri="/struts-tags"%&gt; 前缀的用法&lt;s:text&gt;<br />    &lt;%@taglib prefix="aaa" uri="/fmt-tags"%&gt; 前缀的用法&lt;aaa:text&gt;</p>
<p>=========================================</p>
<p>九个内置对象</p>
<p>* out --&gt; jsp的输出流，用来向客户端响应 JspWriter<br />* page --&gt; 当前jsp对象！　它的引用类型是Object，即真身中有如下代码：Object page = this;<br />* config --&gt; 它对应真身中的ServletConfig对象！<br />* pageContext --&gt; 一个顶9个！PageContext<br />* request --&gt; ServletEequest<br />* response --&gt; ServletResponse<br />* exception --&gt; Throwable<br />* session --&gt; HttpSession<br />* application --&gt; ServletContext</p>
<p>1. pageContext<br />  * 一个顶9个！<br />  * Servlet中有三大域，而JSP中有四大域，它就是最后一个域对象！<br />    &gt; ServletContext：整个应用程序<br />    &gt; session：整个会话(一个会话中只有一个用户)<br />    &gt; request：一个请求链！<br />    &gt; pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据！<br />      &gt; 域对象<br />      &gt; 代理其他域：pageContext.setAttribute("xxx", "XXX", PageContext.SESSION_SCOPE);<br />	pageContext.getAttribute("name",PageContext.SESSION_SCOPE)--&gt;表示要从session域中查找name属性的值<br />      &gt; 全域查找：pageContext.findAttribute("age");从小到大，依赖查找！<br />	//Application.setAttribute("age",20);<br />	//Session.setAttribute("age",30);<br />	//Request.setAtribute("age",40);<br />      &gt; 获取其他8个内置对象：</p>
<p>=========================================</p>
<p>JSP动作标签<br />　　这些jsp的动作标签，与html提供的标签有本质的区别。<br />　　* 动作标签是由tomcat(服务器)来解释执行！它与java代码一样，都是在服务器端执行的！<br />　　* html由浏览器来执行！<br />    * &lt;jsp:forward&gt;：转发！它与RequestDispatcher的forward方法是一样的，一个是在Servlet中使用，一个是在jsp中使用！<br />    * &lt;jsp:include&gt;：包含：它与RequestDispatcher的include方法是一样的，一个是在Servlet中使用，一个是在jsp中使用！<br />      &gt; &lt;%@include&gt;和&lt;jsp:include&gt;有什么不同！<br />	<br />	&lt;%@include&gt; 指令：是在编译的时候就要合并，并且只生成一个java文件和一个class文件<br />	&lt;jsp:include&gt;动作标签：是在访问的时候执行，是两个不同的java文件，和请求包含一样</p>
<p>    * &lt;jsp:param&gt;：它用来作为forward和include的子标签！用来给转发或包含的页面传递参数！</p>
<p>=========================================</p>
<p>JavaBean</p>
<p>javaBean的规范：<br />  1. 必须要有一个默认构造器<br />  2. 提供get/set方法，如果只有get方法，那么这个属性是只读属性！<br />  3. 属性：有get/set方法的成员，还可以没有成员，只有get/set方法。属性名称由get/set方法来决定！而不是成员名称！<br />  4. 方法名称满足一定的规范，那么它就是属性！boolean类型的属性，它的读方法可以是is开头，也可以是get开头！</p>
<p><br />内省：<br />  内省类 --&gt; Bean信息 --&gt; 属性描述符 --&gt; 属性的get/set对应的Method！ --- &gt; 可以反射了！</p>
<p>-----------------------</p>
<p>commons-beanutils，它是依赖内省完成！<br />  * 导包：<br />    &gt; commons-beanutils.jar<br />    &gt; commons-logging.jar</p>
<p>BeanUtils.getProperty(Object bean, String propertyName)<br />BeanUtils.setProperty(Object bean, String propertyName, String propertyValue)<br />BeanUtils.populate(Map map, Object bean)</p>
<p>CommontUtils.toBean(Map map, Class class)</p>
<p>-----------------------</p>
<p>jsp中与javaBean相关的标签！</p>
<p>* &lt;jsp:useBean&gt; --&gt; 创建或查询bean<br />  * &lt;jsp:useBean id="user1" class="cn.itcast.domain.User" scope="session"/&gt; 在session域中查找名为user1的bean，如果不存在，创建之<br />  * &lt;jsp:useBean id="user1" class="cn.itcast.domain.User" scope="session"/&gt;<br />* &lt;jsp:setProperty&gt;<br />  * &lt;jsp:setProperty property="username" name="user1" value="admin"/&gt; 设置名为user1的这个javabean的username属性值为admin<br />* &lt;jsp:getProperty&gt;<br />  * &lt;jsp:getProperty property="username" name="user1"/&gt; 获取名为user1的javabean的名为username属性值</p>
<p>=========================================</p>
<p>EL表达式</p>
<p>1. EL是JSP内置的表达式语言！<br />  * jsp2.0开始，不让再使用java脚本，而是使用el表达式和动态标签来替代java脚本！<br />  * EL替代的是&lt;%= ... %&gt;，也就是说，EL只能做输出！</p>
<p>2. EL表达式来读取四大域<br />  * 读取的数据：1、常量   2、表达式   3、域对象，请求参数，全局配置参数，cookie<br />  * ${xxx}，全域查找名为xxx的属性，如果不存在，输出空字符串，而不是null。<br />  * ${pageScope.xxx}、${requestScope.xxx}、${sessionScope.xxx}、${applicationScope.xxx}，指定域获取属性！</p>
<p>3. javaBean导航<br />  &lt;%<br />	Address address = new Address();<br />	address.setCity("北京");<br />	address.setStreet("西三旗");<br />	<br />	Employee emp = new Employee();<br />	emp.setName("李小四");<br />	emp.setSalary(123456);<br />	emp.setAddress(address);<br />	<br />	request.setAttribute("emp", emp);<br />  %&gt;</p>
<p>&lt;h3&gt;使用el获取request域的emp&lt;/h3&gt;<br />${requestScope.emp.address.street }&lt;!-- request.getAttribute("emp").getAddress().getStreet() --&gt;&lt;br/&gt;</p>
<p><br />4. EL可以输出的东西都在11个内置对象中！11个内置对象，其中10个是Map！pageContext不是map，它就是PageContext类型，1个项9个。<br />  11个内置对象（el）:pageScope、requestScope、sessionScope、applicationScope、param、<br />  paramValues、header、headerValues、initParam、cookie、pageContext<br />  * 我们已经学习了四个<br />  * param：对应参数，它是一个Map，其中key参数名，value是参数值，适用于单值的参数。<br />  * paramValues：对应参数，它是一个Map，其中key参数名，value是多个参数值，适用于多值的参数。<br />  * header：对应请求头，它是一个Map，其中key表示头名称，value是单个头值，适用于单值请求头<br />  * headerValues：对应请求头，它是一个Map，其中key表示头名称，value是多个头值，适用于多值请求头<br />  * initParam：获取&lt;context-param&gt;内的参数！<br />    &lt;context-param&gt;<br />  	&lt;param-name&gt;xxx&lt;/param-name&gt;<br />  	&lt;param-value&gt;XXX&lt;/param-value&gt;<br />  &lt;/context-param&gt;<br />  &lt;context-param&gt;<br />  	&lt;param-name&gt;yyy&lt;/param-name&gt;<br />  	&lt;param-value&gt;YYY&lt;/param-value&gt;<br />  &lt;/context-param&gt;</p>
<p>    ${initParam.xxx}</p>
<p>  * cookie：Map&lt;String,Cookie&gt;类型，其中key是cookie的name，value是cookie对象。 ${cookie.username.value}<br />  * pageContext：它是PageContext类型！${pageContext.request.contextPath}</p>
<p>=========================================</p>
<p>EL函数库（由JSTL提供的）<br />  * 导入标签库：&lt;%@ tablib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%&gt;<br />	String toUpperCase(String input)：把参数转换成大写<br />	String toLowerCase(String input)：把参数转换成小写<br />	int indexOf(String input, String substring)：从大串，输出小串的位置！<br />	boolean contains(String input, String substring)：查看大串中是否包含小串<br />	boolean containsIgnoreCase(String input, String substring)：忽略大小写的，是否包含<br />	boolean startsWith(String input, String substring)：是否以小串为前缀<br />	boolean endsWith(String input, String substring)：是否以小串为后缀<br />	String substring(String input, int beginIndex, int endIndex)：截取子串<br />	String substringAfter(String input, String substring)：获取大串中，小串所在位置后面的字符串<br />	substringBefore(String input, String substring)：获取大串中，小串所在位置前面的字符串<br />	String escapeXml(String input)：把input中&ldquo;&lt;&rdquo;、"&gt;"、"&amp;"、"'"、"""，进行转义<br />	String trim(String input)：去除前后空格<br />	String replace(String input, String substringBefore, String substringAfter)：替换<br />	String[] split(String input, String delimiters)：分割字符串，得到字符串数组<br />	int length(Object obj)：<br />	可以获 <br />	取字符串、数组、各种集合的长度！<br />	String join(String array[], String separator)：联合字符串数组！</p>
<p>=========================================</p>
<p>自定义函数库<br /> * 写一个java类，类中可以定义0~N个方法，但必须是static，而且有返回值的！<br /> * 在WEB-INF目录下创建一个tld文件<br />   &lt;function&gt;<br />    &lt;name&gt;fun&lt;/name&gt;<br />    &lt;function-class&gt;cn.itcast.fn.MyFunction&lt;/function-class&gt;<br />    &lt;function-signature&gt;java.lang.String fun()&lt;/function-signature&gt;<br />  &lt;/function&gt;</p>
<p> * 在jsp页面中导入标签库<br />   &lt;%@ taglib prefix="it" uri="/WEB-INF/tlds/itcast.tld" %&gt;<br /> * 在jsp页面中使用自定义的函数：${it:fun() }</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>