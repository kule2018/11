<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修js常见面试题' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>js常见面试题</center></div><div class='banquan'>原文出处:本文由博客园博主Andy-Biel提供。<br/>
原文连接:https://www.cnblogs.com/jia-bk-home/p/11304651.html</div><br>
    <div>
<div>
<h3>1. javascript的typeof返回哪些数据类型.</h3>
<p>答案：string,boolean,number,undefined,function,object</p>
<h3>2. 例举3种强制类型转换和2种隐式类型转换?</h3>
<p>答案：强制（parseInt,parseFloat,number）<br />
隐式（==  ===）</p>
<h3>3. split() join() 的区别</h3>
<p>答案：前者是将字符串切割成数组的形式，后者是将数组转换成字符串</p>
<h3>4. 数组方法pop() push() unshift() shift()</h3>
<p>答案：push()尾部添加 pop()尾部删除<br />
unshift()头部添加 shift()头部删除</p>
<h3>5. IE和标准下有哪些兼容性的写法</h3>
<p>答案：</p>
<pre><code><code><span class="hljs-keyword">var ev = ev || <span class="hljs-built_in">window.event
<span class="hljs-built_in">document.documentElement.clientWidth || <span class="hljs-built_in">document.body.clientWidth
Var target = ev.srcElement||ev.target
</span></span></span></span></code></pre>
<h3>6. ajax请求的时候get 和post方式的区别</h3>
<p>答案：<br />
一个在url后面 ，一个放在虚拟载体里面<br />
get有大小限制(只能提交少量参数)<br />
安全问题<br />
应用不同 ，请求数据和提交数据</p>
<h3>7. call和apply的区别</h3>
<p>答案：<br />
Object.call(this,obj1,obj2,obj3)<br />
Object.apply(this,arguments)</p>
<h3>8. ajax请求时，如何解析json数据</h3>
<p>答案：使用JSON.parse</p>
<h3>9. 事件委托是什么</h3>
<p>答案: 利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p>
<h3>10. 闭包是什么，有什么特性，对页面有什么影响</h3>
<p>答案：闭包就是能够读取其他函数内部变量的函数,使得函数不被GC回收，如果过多使用闭包，容易导致内存泄露</p>
<h3>11. 如何阻止事件冒泡</h3>
<p>答案：ie:阻止冒泡ev.cancelBubble = true;非IE ev.stopPropagation();</p>
<h3>12. 如何阻止默认事件</h3>
<p>答案：(1)return false；(2) ev.preventDefault();</p>
<h3>13. 添加 删除 替换 插入到某个接点的方法</h3>
<p>答案：</p>
<p>1）创建新节点<br />
createElement()   //创建一个具体的元素<br />
createTextNode()   //创建一个文本节点</p>
<p>2）添加、移除、替换、插入<br />
appendChild()      //添加<br />
removeChild()      //移除<br />
replaceChild()      //替换<br />
insertBefore()      //插入</p>
<p>3）查找<br />
getElementsByTagName()    //通过标签名称<br />
getElementsByName()     //通过元素的Name属性的值<br />
getElementById()        //通过元素Id，唯一性</p>
<h3>14. 解释jsonp的原理，以及为什么不是真正的ajax</h3>
<p>答案：动态创建script标签，回调函数<br />
Ajax是页面无刷新请求数据操作</p>
<h3>15. document load 和document ready的区别</h3>
<p>答案：document.onload 是在结构和样式,外部js以及图片加载完才执行js<br />
document.ready是dom树创建完成就执行的方法，原生种没有这个方法，jquery中有 $().ready(function)</p>
<h3>16. &rdquo;==&rdquo;和&ldquo;===&rdquo;的不同</h3>
<p>答案：前者会自动转换类型,再判断是否相等<br />
后者不会自动类型转换，直接去比较</p>
<h3>17. 函数声明与函数表达式的区别？</h3>
<p>在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。</p>
<h3>18. 对作用域上下文和this的理解，看下列代码：</h3>
<pre><code><code><span class="hljs-keyword">var User = {
 <span class="hljs-attr">count: <span class="hljs-number">1,
 <span class="hljs-attr">getCount: <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">) {
  <span class="hljs-keyword">return <span class="hljs-keyword">this.count;
 }
};
<span class="hljs-built_in">console.log(User.getCount()); <span class="hljs-comment">// what?
<span class="hljs-keyword">var func = User.getCount;
<span class="hljs-built_in">console.log(func()); <span class="hljs-comment">// what?
问两处<span class="hljs-built_in">console输出什么？为什么？
答案:是<span class="hljs-number">1和<span class="hljs-literal">undefined。
　　func是在<span class="hljs-built_in">window的上下文中被执行的，所以不会访问到count属性。
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>19. 看下面代码，给出输出结果。</h3>
<pre><code><code><span class="hljs-keyword">for(<span class="hljs-keyword">var i = <span class="hljs-number">1; i &lt;= <span class="hljs-number">3; i++){  <span class="hljs-comment">//建议使用let 可正常输出i的值
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){
      <span class="hljs-built_in">console.log(i);   
  },<span class="hljs-number">0); 
};
答案：<span class="hljs-number">4 <span class="hljs-number">4 <span class="hljs-number">4。
原因：Javascript事件处理器在线程空闲之前不会运行。
</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>20. 当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做?</h3>
<p>box.onlick= function(){}<br />
box.addEventListener("click",function(){},false);<br />
&lt;button onclick="xxx()"&gt;&lt;/button&gt;</p>
<h3>21. Javascript的事件流模型都有什么?</h3>
<p>&ldquo;事件冒泡&rdquo;：事件开始由最具体的元素接受，然后逐级向上传播</p>
<p>&ldquo;事件捕捉&rdquo;：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的</p>
<p>&ldquo;DOM事件流&rdquo;：三个阶段：事件捕捉，目标阶段，事件冒泡</p>
<h3>22. 看下列代码,输出什么?解释原因。</h3>
<pre><code><code><span class="hljs-keyword">var a = <span class="hljs-literal">null;
alert(<span class="hljs-keyword">typeof a);
答案：object
解释：<span class="hljs-literal">null是一个只有一个值的数据类型，这个值就是<span class="hljs-literal">null。表示一个空指针对象，所以用<span class="hljs-keyword">typeof检测会返回&rdquo;object&rdquo;。
</span></span></span></span></span></span></code></pre>
<h3>23. 判断字符串以字母开头，后面可以是数字，下划线，字母，长度为6-30</h3>
<pre><code><code><span class="hljs-keyword">var reg=<span class="hljs-regexp">/^[a-zA-Z]\w{5,29}$/;
</span></span></code></pre>
<h3>24. 回答以下代码，alert的值分别是多少？</h3>
<pre class="hljs xml"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script&gt;<span class="actionscript">
     <span class="hljs-keyword">var a = <span class="hljs-number">100;  
     <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">test<span class="hljs-params">(){  
        alert(a);  
     a = <span class="hljs-number">10;  <span class="hljs-comment">//去掉了var 就变成定义了全局变量了
        alert(a);  
}  
test();
alert(a);
<span class="hljs-tag">&lt;/<span class="hljs-name">script&gt;
正确答案是： 100， 10， 10
</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>25. javaScript的2种变量范围有什么不同？</h3>
<p>全局变量：当前页面内有效</p>
<p>局部变量：函数方法内有效</p>
<h3>26. null和undefined的区别？</h3>
<p>null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。</p>
<p>当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象</p>
<p>undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2）调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<p>null表示"没有对象"，即该处不应该有值。典型用法是：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<h3>27. new操作符具体干了什么呢?</h3>
<p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>
<p>2、属性和方法被加入到 this 引用的对象中。</p>
<p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<h3>28. js延迟加载的方式有哪些？</h3>
<p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js</p>
<h3>29. Flash、Ajax各自的优缺点，在使用中如何取舍？</h3>
<p>Flash ajax对比</p>
<p>(1)Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。</p>
<p>(2)ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</p>
<pre class="hljs undefined"><code>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
</code></pre>
<h3>30. 写一个获取非行间样式的函数</h3>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">getStyle(<span class="hljs-params">obj,attr) {
<span class="hljs-keyword">if(obj.currentStyle) {
<span class="hljs-keyword">return obj.currentStyle[attr];
}<span class="hljs-keyword">else{
getComputedStyle(obi,<span class="hljs-literal">false)[attr] 
}

}
</span></span></span></span></span></span></span></span></code></pre>
<h3>31. 希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h3>
<pre><code><code><span class="hljs-keyword">var inputs = <span class="hljs-built_in">document.getElementsByTagName(<span class="hljs-string">"input");<span class="hljs-comment">//获取所有的input标签对象
<span class="hljs-keyword">var checkboxArray = [];<span class="hljs-comment">//初始化空数组，用来存放checkbox对象。
<span class="hljs-keyword">for(<span class="hljs-keyword">var i=<span class="hljs-number">0;i&lt;inputs.length;i++){
  <span class="hljs-keyword">var obj = inputs[i];
  <span class="hljs-keyword">if(obj.type==<span class="hljs-string">'checkbox'){
     checkboxArray.push(obj);
  }
}
</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>32. 写一个function，清除字符串前后的空格。（兼容所有浏览器）</h3>
<pre><code><code><span class="hljs-built_in">String.prototype.trim= <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){

<span class="hljs-keyword">return <span class="hljs-keyword">this.replace(<span class="hljs-regexp">/^\s+/,<span class="hljs-string">"").replace(<span class="hljs-regexp">/\s+$/,<span class="hljs-string">"");

}
</span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>33. javascript语言特性中，有很多方面和我们接触的其他编程语言不太一样,请举例</h3>
<p>javascript语言实现继承机制的核心就是 1 (原型)，而不是Java语言那样的类式继承。Javascript解析引擎在读取一个Object的属性的值时，会沿着 2 (原型链)向上寻找，如果最终没有找到，则该属性值为 3 undefined；如果最终找到该属性的值，则返回结果。与这个过程不同的是，当javascript解析引擎执行&ldquo;给一个Object的某个属性赋值&rdquo;的时候，如果当前Object存在该属性，则改写该属性的值，如果当前的Object本身并不存在该属性，则赋值该属性的值。</p>
<h3>34. Cookie在客户机上是如何存储的</h3>
<p>Cookies就是服务器暂存放在你的电脑里的文本文件，好让服务器用来辨认你的计算机。当你在浏览网站的时候，Web服务器会先送一小小资料放在你的计算机上，Cookies 会帮你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookies资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。</p>
<h3>35. 如何获取javascript三个数中的最大值和最小值？</h3>
<p>Math.max(a,b,c);//最大值</p>
<p>Math.min(a,b,c)//最小值</p>
<h3>36. javascript是面向对象的，怎么体现javascript的继承关系？</h3>
<p>使用prototype原型来实现。</p>
<h3>37. .form中的input可以设置为readonly和disable，请问2者有什么区别？</h3>
<p>readonly不可编辑，但可以选择和复制；值可以传递到后台<br />
disabled不能编辑，不能复制，不能选择；值不可以传递到后台</p>
<h3>38. 列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。</h3>
<p>主要数据类型：string, boolean, number</p>
<p>复合数据类型：function, object</p>
<p>特殊类型：undefined，null</p>
<h3>39. 程序中捕获异常的方法？</h3>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">try{
 
}<span class="hljs-keyword">catch(e){
 
}<span class="hljs-keyword">finally{
 
}
</span></span></span></code></pre>
<h3>40. Ajax原理</h3>
<pre><code><code>(<span class="hljs-number">1)创建对象

<span class="hljs-keyword">var xhr = <span class="hljs-keyword">new XMLHttpRequest();

(<span class="hljs-number">2)打开请求

xhr.open(<span class="hljs-string">'GET', <span class="hljs-string">'example.txt', <span class="hljs-literal">true);

(<span class="hljs-number">3)发送请求

xhr.send(); 发送请求到服务器

(<span class="hljs-number">4)接收响应

xhr.onreadystatechange =<span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){}

(<span class="hljs-number">1)当readystate值从一个值变为另一个值时，都会触发readystatechange事件。

(<span class="hljs-number">2)当readystate==<span class="hljs-number">4时，表示已经接收到全部响应数据。

(<span class="hljs-number">3)当status ==<span class="hljs-number">200时，表示服务器成功返回页面和数据。

(<span class="hljs-number">4)如果(<span class="hljs-number">2)和(<span class="hljs-number">3)内容同时满足，则可以通过xhr.responseText，获得服务器返回的内容。
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>41. 解释什么是Json:</h3>
<p>(1)JSON 是一种轻量级的数据交换格式。</p>
<p>(2)JSON 独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言。</p>
<p>(3)JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null),数组，对象</p>
<h3>42. js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？</h3>
<p>alert<br />
confirm<br />
prompt</p>
<h3>43. 以下代码执行结果</h3>
<pre><code><code><span class="hljs-keyword">var uname = <span class="hljs-string">'jack'
<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">change(<span class="hljs-params">) {
    alert(uname) <span class="hljs-comment">// ?
    <span class="hljs-keyword">var uname = <span class="hljs-string">'lily'
    alert(uname)  <span class="hljs-comment">//?
}
change()
分别alert出 <span class="hljs-literal">undefined，lily，（变量声明提前问题）
</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>44. 浏览器的滚动距离：</h3>
<p>可视区域距离页面顶部的距离</p>
<p>scrollTop=document.documentElement.scrollTop||document.body.scrollTop</p>
<h3>45. 可视区的大小：</h3>
<p>(1)innerXXX（不兼容ie）</p>
<p>window.innerHeight 可视区高度，包含滚动条宽度</p>
<p>window.innerWidth 可视区宽度，包含滚动条宽度</p>
<p>(2)document.documentElement.clientXXX(兼容ie)</p>
<p>document.documentElement.clientWidth可视区宽度，不包含滚动条宽度</p>
<p>document.documentElement.clientHeight可视区高度，不包含滚动条宽度</p>
<h3>46. 节点的种类有几种，分别是什么？</h3>
<p>(1)元素节点：nodeType ===1;</p>
<p>(2)文本节点：nodeType ===3;</p>
<p>(3)属性节点：nodeType ===2;</p>
<h3>47. innerHTML和outerHTML的区别</h3>
<p>innerHTML(元素内包含的内容）</p>
<p>outerHTML(自己以及元素内的内容）</p>
<h3>48. offsetWidth offsetHeight和clientWidth clientHeight的区别</h3>
<p>(1)offsetWidth （content宽度+padding宽度+border宽度）</p>
<p>(2)offsetHeight（content高度+padding高度+border高度）</p>
<p>(3)clientWidth（content宽度+padding宽度）</p>
<p>(4)clientHeight（content高度+padding高度）</p>
<h3>49. 闭包的好处</h3>
<p>(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)</p>
<p>(2)避免全局变量的污染</p>
<p>(3)私有成员的存在</p>
<p>(4)安全性提高</p>
<h3>50. 冒泡排序算法</h3>
<pre class="hljs php"><code class="php">冒泡排序
<span class="hljs-keyword">var <span class="hljs-keyword">array = [<span class="hljs-number">5, <span class="hljs-number">4, <span class="hljs-number">3, <span class="hljs-number">2, <span class="hljs-number">1];
<span class="hljs-keyword">var temp = <span class="hljs-number">0;
<span class="hljs-keyword">for (<span class="hljs-keyword">var i = <span class="hljs-number">0; i &lt;<span class="hljs-keyword">array.length; i++){
<span class="hljs-keyword">for (<span class="hljs-keyword">var j = <span class="hljs-number">0; j &lt;<span class="hljs-keyword">array.length - i; j++){
<span class="hljs-keyword">if (<span class="hljs-keyword">array[j] &gt; <span class="hljs-keyword">array[j + <span class="hljs-number">1]){
temp = <span class="hljs-keyword">array[j + <span class="hljs-number">1];
<span class="hljs-keyword">array[j + <span class="hljs-number">1] = <span class="hljs-keyword">array[j];
<span class="hljs-keyword">array[j] = temp;
 }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>51、js 实现一个函数对javascript中json 对象进行克隆</h3>
<pre><code><code><span class="hljs-keyword">var oldObject =<span class="hljs-string">"sdf";
   <span class="hljs-keyword">var newObject = <span class="hljs-built_in">JSON.parse(<span class="hljs-built_in">JSON.stringify(oldObject));
   <span class="hljs-built_in">console.log(newObject);
或者
    <span class="hljs-keyword">var a = <span class="hljs-string">'dddd';
    <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">cp(<span class="hljs-params">a){<span class="hljs-keyword">return <span class="hljs-built_in">JSON.parse(<span class="hljs-built_in">JSON.stringify(a))}
    <span class="hljs-built_in">console.log(cp(a));
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>52、js 实现 ajax 请求或者submit请求时 锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）</h3>
<p>function(url, fn) {<br />
var obj = new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据<br />
obj.open('GET', url, true);<br />
obj.onreadystatechange = function() {<br />
if(obj.readyState == 4 &amp;&amp; obj.status == 200||obj.status == 304) {</p>
<pre class="hljs bash"><code class="bash">               loading.style.display = <span class="hljs-string">"none"

            } <span class="hljs-keyword">else {

               alert(<span class="hljs-string">"不能点击,哈哈哈!");

            }

   };
</span></span></span></code></pre>
<p>obj.send(null);<br />
}</p>
<h3>53、js 实现一个函数 获得url参数的值</h3>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">getQueryString(<span class="hljs-params">name) { 
  <span class="hljs-keyword">var reg = <span class="hljs-keyword">new <span class="hljs-built_in">RegExp(<span class="hljs-string">"(^|&amp;)" + name + <span class="hljs-string">"=([^&amp;]*)(&amp;|$)", <span class="hljs-string">"i"); 
  <span class="hljs-keyword">var r = <span class="hljs-built_in">window.location.search.substr(<span class="hljs-number">1).match(reg); 
  <span class="hljs-keyword">if (r != <span class="hljs-literal">null) <span class="hljs-keyword">return <span class="hljs-built_in">unescape(r[<span class="hljs-number">2]); <span class="hljs-keyword">return <span class="hljs-literal">null; 
} 
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>54、请用js计算1-10000中出现的0 的次数</h3>
<pre><code><code><span class="hljs-keyword">new <span class="hljs-built_in">Array(<span class="hljs-number">10000).fill(<span class="hljs-string">'').map(<span class="hljs-function">(<span class="hljs-params">_, index) =&gt; index + <span class="hljs-number">1).filter(<span class="hljs-function"><span class="hljs-params">item =&gt; /<span class="hljs-number">0/.test(item)).reduce(<span class="hljs-function">(<span class="hljs-params">count, item) =&gt; { <span class="hljs-keyword">return count + (<span class="hljs-built_in">String(item).match(<span class="hljs-regexp">/0/g) || []).length}, <span class="hljs-number">0)
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>55、写一个function，清除字符串前后的空格。（兼容所有浏览器）</h3>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">trim(<span class="hljs-params">str) {
    <span class="hljs-keyword">if (str &amp; <span class="hljs-keyword">typeof str === <span class="hljs-string">"string") {
        <span class="hljs-keyword">return str.replace(<span class="hljs-regexp">/(^s*)|(s*)$/g,<span class="hljs-string">""); <span class="hljs-comment">//去除前后空白符
    }
}
</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>56、降维数组</h3>
<pre><code><code><span class="hljs-keyword">var arr=[[<span class="hljs-number">1,<span class="hljs-number">2],[<span class="hljs-number">3,<span class="hljs-number">4]];
<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">Jw(<span class="hljs-params">obj){
     <span class="hljs-keyword">return <span class="hljs-built_in">Array.prototype.concat.apply([],obj);
}
Jw(arr);
</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>57、将url的查询参数解析成字典对象</h3>
<p>&middot;&middot;&middot;<br />
function getQueryObject(url) {<br />
url = url == null ? window.location.href : url;<br />
var search = url.substring(url.lastIndexOf("?") + 1);<br />
var obj = {};<br />
var reg = /([<sup>?&amp;=]+)=([</sup>?&amp;=]*)/g;<br />
search.replace(reg, function (rs, <img class="math-inline" src="./images/js常见面试题0.png" alt="1," />2) {<br />
var name = decodeURIComponent(<img class="math-inline" src="./images/js常见面试题1.png" alt="1); var val = decodeURIComponent(" />2);<br />
val = String(val);<br />
obj[name] = val;<br />
return rs;<br />
});<br />
return obj;<br />
}<br />
&middot;&middot;&middot;</p>
<h3>58、判断一个字符串中出现次数最多的字符，统计这个次数</h3>
<p>&middot;&middot;&middot;<br />
var str = 'asdfssaaasasasasaa';<br />
var json = {};</p>
<p>for (var i = 0; i &lt; str.length; i++) {<br />
if(!json[str.charAt(i)]){<br />
json[str.charAt(i)] = 1;<br />
}else{<br />
json[str.charAt(i)]++;<br />
}<br />
};<br />
var iMax = 0;<br />
var iIndex = '';<br />
for(var i in json){<br />
if(json[i]&gt;iMax){<br />
iMax = json[i];<br />
iIndex = i;<br />
}<br />
}<br />
alert('出现次数最多的是:'+iIndex+'出现'+iMax+'次');<br />
&middot;&middot;&middot;</p>
<h3>59、编写一个方法 求一个字符串的字节长度;</h3>
<p>&middot;&middot;&middot;<br />
//假设一个中文占两个字节<br />
var str = '22两是';</p>
<p>alert(getStrlen(str))</p>
<p>function getStrlen(str){<br />
var json = {len:0};<br />
var re = /[\u4e00-\u9fa5]/;<br />
for (var i = 0; i &lt; str.length; i++) {<br />
if(re.test(str.charAt(i))){<br />
json['len']++;<br />
}<br />
};<br />
return json['len']+str.length;<br />
}<br />
&middot;&middot;&middot;</p>
<h3>60、编写一个方法 去掉一个数组的重复元素</h3>
<p>&middot;&middot;&middot;<br />
var arr = [1,2,3,1,43,12,12,1];<br />
var json = {};<br />
var arr2 = [];<br />
for (var i = 0; i &lt; arr.length; i++) {<br />
if(!json[arr[i]]){<br />
json[arr[i]] = true;<br />
}else{<br />
json[arr[i]] = false;<br />
}</p>
<pre class="hljs bash"><code class="bash">    <span class="hljs-keyword">if(json[arr[i]]){
            arr2.push(arr[i]);
    }
</span></code></pre>
<p>};</p>
<p>for (var i = 0; i &lt; arr.length; i++) {<br />
if(!aa(arr[i], arr2)){<br />
arr2.push(arr[i])<br />
}<br />
};<br />
function aa(obj, arr){<br />
for (var i = 0; i &lt; arr.length; i++) {<br />
if(arr[i] == obj) return true;<br />
else return false;<br />
};<br />
}<br />
alert(arr2)<br />
&middot;&middot;&middot;</p>
<h3>61、写出3个使用this的典型应用</h3>
<p>事件： 如onclick  this-&gt;发生事件的对象<br />
构造函数          this-&gt;new 出来的object<br />
call/apply        改变this</p>
<h3>62、如何深度克隆</h3>
<p>&middot;&middot;&middot;<br />
var arr = [1,2,43];<br />
var json = {a:6,b:4,c:[1,2,3]};<br />
var str = 'sdfsdf';</p>
<p>var json2 = clone(json);</p>
<p>alert(json['c'])<br />
function clone(obj){<br />
var oNew = new obj.constructor(obj.valueOf());<br />
if(obj.constructor == Object){<br />
for(var i in obj){<br />
oNew[i] = obj[i];<br />
if(typeof(oNew[i]) == 'object'){<br />
clone(oNew[i]);<br />
}<br />
}<br />
}<br />
return oNew;<br />
}<br />
&middot;&middot;&middot;</p>
<h3>63、JavaScript中如何检测一个变量是一个String类型？请写出函数实现</h3>
<p>&middot;&middot;&middot;<br />
typeof(obj) == 'string'<br />
obj.constructor == String;<br />
&middot;&middot;&middot;</p>
<h3>64、网页中实现一个计算当年还剩多少时间的倒数计时程序，要求网页上实时动态显示&ldquo;&times;&times;年还剩&times;&times;天&times;&times;时&times;&times;分&times;&times;秒&rdquo;</h3>
<p>&middot;&middot;&middot;<br />
var oDate = new Date();<br />
var oYear = oDate.getFullYear();</p>
<p>var oNewDate = new Date();<br />
oNewDate.setFullYear(oYear, 11, 31, 23, 59, 59);<br />
var iTime = oNewDate.getTime()-oDate.getTime();</p>
<p>var iS = iTime/1000;<br />
var iM = oNewDate.getMonth()-oDate.getMonth();<br />
var iDate =iS<br />
&middot;&middot;&middot;</p>
<h3>65、请解释一下什么是语义化的HTML。</h3>
<p>内容使用特定标签，通过标签就能大概了解整体页面的布局分布</p>
<h3>66、为什么利用多个域名来存储网站资源会更有效？</h3>
<p>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站</p>
<h3>67、请说出三种减低页面加载时间的方法</h3>
<p>1、压缩css、js文件<br />
2、合并js、css文件，减少http请求<br />
3、外部js、css文件放在最底下<br />
4、减少dom操作，尽可能用变量替代不必要的dom操作</p>
<h3>68、什么是FOUC？你如何来避免FOUC？</h3>
<p>由于css引入使用了@import 或者存在多个style标签以及css文件在页面底部引入使得css文件加载在html之后导致页面闪烁、花屏<br />
用link加载css文件，放在head标签里面</p>
<h3>69、文档类型的作用是什么？你知道多少种文档类型？</h3>
<p>影响浏览器对html代码的编译渲染<br />
html2.0<br />
xHtml<br />
html5</p>
<h3>70、浏览器标准模式和怪异模式之间的区别是什么？</h3>
<p>盒模型解释不同</p>
<h3>71、闭包</h3>
<p>子函数能被外部调用到，则该作用连上的所有变量都会被保存下来。</p>
<h3>72、请解释什么是Javascript的模块模式，并举出实用实例。</h3>
<p>js模块化mvc（数据层、表现层、控制层）<br />
seajs<br />
命名空间</p>
<h3>73、你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h3>
<p>对内：模块模式<br />
对外：继承</p>
<h3>74、你如何优化自己的代码？</h3>
<p>代码重用<br />
避免全局变量（命名空间，封闭空间，模块化mvc..）<br />
拆分函数避免函数过于臃肿<br />
注释</p>
<h3>75、你能解释一下JavaScript中的继承是如何工作的吗？</h3>
<p>子构造函数中执行父构造函数，并用call\apply改变this<br />
克隆父构造函数原型上的方法</p>
<h3>76、请尽可能详尽的解释AJAX的工作原理。</h3>
<p>创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）<br />
判断数据传输方式(GET/POST)<br />
打开链接 open()<br />
发送 send()<br />
当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数</p>
<h3>77、最简单的一道题</h3>
<p>&middot;&middot;&middot;<br />
var a = 2, b = 3;<br />
var c = a+++b; // c = 5<br />
&middot;&middot;&middot;</p>
<h3>78、var和function的预解析问题,以及变量和function的先后顺序的问题</h3>
<p>&middot;&middot;&middot;<br />
// 以下代码执行输出结果是什么<br />
function b () {<br />
console.log(a);<br />
var a = 10;<br />
function a() {};<br />
a = 100;<br />
console.log(a);<br />
}<br />
b();</p>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">c (<span class="hljs-params">) {
    <span class="hljs-built_in">console.log(a);
    <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">a(<span class="hljs-params">) {};
    <span class="hljs-keyword">var a = <span class="hljs-number">10;
    a = <span class="hljs-number">100;
    <span class="hljs-built_in">console.log(a);
}
c();

(<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">d (<span class="hljs-params">num) {
    <span class="hljs-built_in">console.log(num);
    <span class="hljs-keyword">var num = <span class="hljs-number">10;
}(<span class="hljs-number">100))

(<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">e (<span class="hljs-params">num) {
    <span class="hljs-built_in">console.log(num);
    <span class="hljs-keyword">var num = <span class="hljs-number">10;
    <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">num (<span class="hljs-params">) {};
}(<span class="hljs-number">100))

(<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">f (<span class="hljs-params">num) {
    <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">num (<span class="hljs-params">) {};
    <span class="hljs-built_in">console.log(num);
    <span class="hljs-keyword">var num =<span class="hljs-number">10
    <span class="hljs-built_in">console.log(num);
}(<span class="hljs-number">100))

<span class="hljs-comment">//仍然是预解析(在与解析过程中还要考虑一下当前变量的作用于)
<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">m (<span class="hljs-params">) {
    <span class="hljs-built_in">console.log(a1); <span class="hljs-comment">// underfined
    <span class="hljs-built_in">console.log(a2); <span class="hljs-comment">// underfined
    <span class="hljs-built_in">console.log(b1); <span class="hljs-comment">// underfined
    <span class="hljs-built_in">console.log(b2); <span class="hljs-comment">// underfined
    <span class="hljs-keyword">if(<span class="hljs-literal">false) {
        <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">b1 (<span class="hljs-params">){};
        <span class="hljs-keyword">var a1 = <span class="hljs-number">10;
    }
    <span class="hljs-keyword">if(<span class="hljs-literal">true) {
        <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">b2 (<span class="hljs-params">){};
        <span class="hljs-keyword">var a2 = <span class="hljs-number">10;
    }
    <span class="hljs-built_in">console.log(a1); <span class="hljs-comment">// underfined
    <span class="hljs-built_in">console.log(a2); <span class="hljs-comment">// 10
    <span class="hljs-built_in">console.log(b1); <span class="hljs-comment">// underfined
    <span class="hljs-built_in">console.log(b2); <span class="hljs-comment">// function
}
m();

<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">n(<span class="hljs-params">) {
    <span class="hljs-keyword">if(<span class="hljs-number">2&gt;<span class="hljs-number">1) {
        arr = <span class="hljs-number">10;
        brr = <span class="hljs-number">10;
        <span class="hljs-keyword">let arr;
        <span class="hljs-keyword">var brr;
        <span class="hljs-built_in">console.log(arr);
        <span class="hljs-built_in">console.log(brr);
    }
}
n(); <span class="hljs-comment">// ReferenceError
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&middot;&middot;&middot;</p>
<h3>79、dom事件委托什么原理，有什么优缺点</h3>
<h4>事件委托原理:事件冒泡机制</h4>
<h4>优点</h4>
<p>1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。<br />
2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</p>
<h4>缺点</h4>
<p>事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</p>
<h3>80、http的cache机制，以及200状态下怎么实现 from cache（表示接触最多的就是304的from cache）（用于优化，没有接触过，需要理解）</h3>
<h4>含义</h4>
<p>定义：浏览器缓存（Browser Caching）是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p>
<h4>作用</h4>
<p>cache的作用：<br />
1、减少延迟，让你的网站更快，提高用户体验。<br />
2、避免网络拥塞，减少请求量，减少输出带宽。</p>
<h4>实现手段</h4>
<p>Cache-Control中的max-age是实现内容cache的主要手段，共有3种常用策略：max-age和Last-Modified（If-Modified-Since）的组合、仅max-age、max-age和ETag的组合。</p>
<p>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。<br />
对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<h3>81、一个原型链继承的问题</h3>
<pre><code><code>    <span class="hljs-comment">// 有一个构造函数A，写一个函数B，继承A
    <span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">A (<span class="hljs-params">num) {
        <span class="hljs-keyword">this.titileName = num;
    }
    A.prototype = {
        <span class="hljs-attr">fn1: <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) {},
        <span class="hljs-attr">fn2: <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) {}
    }
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>这个问题的关注点是B继承的A的静态属性，同时B的原型链中不存在A实例的titleName属性</p>
<h3>82、什么是虚拟dom</h3>
<p>React为啥这么大？因为它实现了一个虚拟DOM（Virtual DOM）。虚拟DOM是干什么的？这就要从浏览器本身讲起</p>
<p>如我们所知，在浏览器渲染网页的过程中，加载到HTML文档后，会将文档解析并构建DOM树，然后将其与解析CSS生成的CSSOM树一起结合产生爱的结晶&mdash;&mdash;RenderObject树，然后将RenderObject树渲染成页面（当然中间可能会有一些优化，比如RenderLayer树）。这些过程都存在与渲染引擎之中，渲染引擎在浏览器中是于JavaScript引擎（JavaScriptCore也好V8也好）分离开的，但为了方便JS操作DOM结构，渲染引擎会暴露一些接口供JavaScript调用。由于这两块相互分离，通信是需要付出代价的，因此JavaScript调用DOM提供的接口性能不咋地。各种性能优化的最佳实践也都在尽可能的减少DOM操作次数。</p>
<p>而虚拟DOM干了什么？它直接用JavaScript实现了DOM树（大致上）。组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React又通过在这个虚拟DOM上实现了一个 diff 算法找出最小变更，再把这些变更写入实际的DOM中。这个虚拟DOM以JS结构的形式存在，计算性能会比较好，而且由于减少了实际DOM操作次数，性能会有较大提升</p>
<h3>83、js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</h3>
<p>1.基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String<br />
2.引用数据类型（对象）：Object （Array，Date，RegExp，Function）<br />
ES6基本数据类型多了个symbol 据说这道题刷了百分之二十的人 感谢Abbyshen提出</p>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">gettype(<span class="hljs-params">nm){
    <span class="hljs-keyword">return <span class="hljs-built_in">Object.prototype.toString.call(nm);
}
</span></span></span></span></span></span></code></pre>
<h3>84、 dom选择器优先级是什么，以及权重值计算（一道老问题了）</h3>
<p>1.行内样式 1000<br />
2.id 0100<br />
3.类选择器、伪类选择器、属性选择器[type="text"] 0010<br />
4.标签选择器、伪元素选择器(::first-line) 0001<br />
5.通配符*、子选择器、相邻选择器 0000</p>
<h3>85、vue双向数据绑定的原理是什么</h3>
<p>首先传输对象的双向数据绑定 Object.defineProperty(target, key, decription),在decription中设置get和set属性（此时应注意description中get和set不能与描述属性共存）<br />
数组的实现与对象不同。<br />
同时运用观察者模式实现wather，用户数据和view视图的更新</p>
<h3>86、 react和vue比较来说有什么区别</h3>
<p>1 component层面，web component和virtual dom<br />
2 数据绑定（vue双向，react的单向）等好多<br />
3 计算属性 vue 有，提供方便；而 react 不行<br />
4 vue 可以 watch 一个数据项；而 react 不行<br />
5 vue 由于提供的 direct 特别是预置的 directive 因为场景场景开发更容易；react 没有<br />
6 生命周期函数名太长 directive</p>
<h3>87、git使用过程中，如果你在开发着业务，突然另一个分支有一个bug要改，你怎么办</h3>
<pre class="hljs cpp"><code class="cpp">git stash       <span class="hljs-comment">//将本次修改存到暂存区（紧急切换分支时）
git stash pop   <span class="hljs-comment">//将所有暂存区的内容取出来

</span></span></code></pre>
<h3>88、 网页布局有哪几种，有什么区别</h3>
<p>静态、自适应、流式、响应式四种网页布局<br />
静态布局：意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；<br />
自适应布局：就是说你看到的页面，里面元素的位置会变化而大小不会变化；<br />
流式布局：你看到的页面，元素的大小会变化而位置不会变化&mdash;&mdash;这就导致如果屏幕太大或者太小都会导致元素无法正常显示。<br />
自适应布局：每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p>
<h3>89、执行下面代码</h3>
<pre><code><code><span class="hljs-keyword">var a = {};
<span class="hljs-keyword">var b = {<span class="hljs-attr">key: <span class="hljs-string">'b'};
<span class="hljs-keyword">var c = {<span class="hljs-attr">key: <span class="hljs-string">'c'};
<span class="hljs-keyword">var d = [<span class="hljs-number">3,<span class="hljs-number">5,<span class="hljs-number">6];
a[b] = <span class="hljs-number">123;
a[c] = <span class="hljs-number">345;
a[d] = <span class="hljs-number">333;
<span class="hljs-built_in">console.log(a[b]);  <span class="hljs-comment">// 345
<span class="hljs-built_in">console.log(a[c]);  <span class="hljs-comment">// 345
<span class="hljs-built_in">console.log(a[d]);  <span class="hljs-comment">// 333
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>90、</h3>
<pre><code><code>    <span class="hljs-keyword">var R = (<span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">) {
        <span class="hljs-keyword">var u = {<span class="hljs-attr">a:<span class="hljs-number">1,<span class="hljs-attr">b:<span class="hljs-number">2};
        <span class="hljs-keyword">var r = {
            <span class="hljs-attr">fn: <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">k) {
                <span class="hljs-keyword">return u[k];
            }
        }
        <span class="hljs-keyword">return r;
    }());
    R.fn(<span class="hljs-string">'a');  <span class="hljs-comment">// 1
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>上述代码中如何获取匿名函数中的u</p>
<h3>91、不适用循环语句（包括map、forEach方法）实现一个100长度的数组，索引值和值相同的数组[0,1,2,3,4,5........99]</h3>
<pre><code><code><span class="hljs-keyword">var arr = <span class="hljs-keyword">new <span class="hljs-built_in">Array(<span class="hljs-number">100);
<span class="hljs-comment">//方法1
[...arr.keys()];
<span class="hljs-comment">//方法二
<span class="hljs-built_in">Array.from(arr.keys());

<span class="hljs-comment">//方法三
<span class="hljs-built_in">Array.from({<span class="hljs-attr">length: <span class="hljs-number">100});

<span class="hljs-comment">// 方法四 借助string
<span class="hljs-keyword">var arr1 = <span class="hljs-keyword">new <span class="hljs-built_in">Array(<span class="hljs-number">101);
<span class="hljs-keyword">var str = arr1.join(<span class="hljs-string">'1,');
str = str.replace(<span class="hljs-regexp">/(1\,)/g, <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">$<span class="hljs-number">0, $<span class="hljs-number">1, index) {
    <span class="hljs-keyword">var start = <span class="hljs-string">'' + <span class="hljs-built_in">Math.ceil(index/<span class="hljs-number">2);
    <span class="hljs-keyword">if(index &lt; str.length - <span class="hljs-number">2) {
        start += <span class="hljs-string">','
    }
    <span class="hljs-keyword">return start;
});
<span class="hljs-keyword">return str.split(<span class="hljs-string">',');

<span class="hljs-comment">// 方法五（函数式，参考网络）
<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">reduce(<span class="hljs-params">arr, val) {
    <span class="hljs-keyword">if(<span class="hljs-built_in">Object.prototype.toString.apply(val)){
        <span class="hljs-keyword">return;
    }
    <span class="hljs-keyword">if(val &gt;= <span class="hljs-number">100) {
        <span class="hljs-keyword">return arr;
    }
    arr.push(val);
    <span class="hljs-keyword">return reduce(arr, val+<span class="hljs-number">1);
}
<span class="hljs-keyword">var res = reduce([], <span class="hljs-number">0)
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>92、下面语句执行结果输出</h3>
<pre><code><code><span class="hljs-keyword">var a = <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">val, index) {
    <span class="hljs-built_in">console.log(index);
    <span class="hljs-keyword">return {
        <span class="hljs-attr">fn: <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">name) {
            <span class="hljs-keyword">return a(name, val);
        }
    }
}

<span class="hljs-keyword">var b = a(<span class="hljs-number">0); <span class="hljs-comment">// underfined
b.fn(<span class="hljs-number">1); <span class="hljs-comment">// 0
b.fn(<span class="hljs-number">2); <span class="hljs-comment">// 0
b.fn(<span class="hljs-number">3); <span class="hljs-comment">// 0
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>93、科普</h3>
<ol>
<li>dom节点的根节点是不是body<br />
回答： 不是，dom节点的根节点是html(包含head和body，head中分为meta、title等。body又分为一组)</li>


</ol>
<p>2）dom元素都会有offsetParent吗<br />
回答： offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素(在标准兼容模式下为html元素；在怪异呈现模式下为body元素)的引用。 当容器元素的style.display 被设置为 "none"时（译注：IE和Opera除外），offsetParent属性 返回 null。</p>
<ol start="3">
<li>[1,3,5]转译成字符串是什么<br />
回答： '1,3,5'<br />
调用toString方法，生成该字符串</li>


</ol>
<p>4）li标签的祖级元素可以为li，父级元素也可以为例<br />
回答： 错误</p>
<h3>94、 jsonp原理，jquery是怎么实现的，这样实现有什么好处和坏处</h3>
<h4>原理</h4>
<p>在同源策略下;在某个服务器下的页面是无法获取到该服务器以外的数据的;Jquery中ajax 的核心是通过 XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加 &lt;script&gt;标签来调用服务器提供的 js脚本<br />
当我们正常地请求一个JSON数据的时候，服务端返回的是一串 JSON类型的数据，而我们使用 JSONP模式来请求数据的时候服务端返回的是一段可执行的 JavaScript代码。因为jsonp 跨域的原理就是用的动态加载 script的src ，所以我们只能把参数通过 url的方式传递, 所以jsonp的 type类型只能是get ！</p>
<pre class="hljs ruby"><code class="ruby">$.ajax({
    <span class="hljs-symbol">url: <span class="hljs-string">'http://192.168.1.114/yii/demos/test.php', <span class="hljs-regexp">//不同的域
    <span class="hljs-symbol">type: <span class="hljs-string">'GET', <span class="hljs-regexp">// jsonp模式只有GET 是合法的
    <span class="hljs-symbol">data: {
        <span class="hljs-string">'action': <span class="hljs-string">'aaron'
    },
    <span class="hljs-symbol">dataType: <span class="hljs-string">'jsonp', <span class="hljs-regexp">// 数据类型
    <span class="hljs-symbol">jsonp: <span class="hljs-string">'backfunc', <span class="hljs-regexp">// 指定回调函数名，与服务器端接收的一致，并回传回来
})
其实jquery 内部会转化成
<span class="hljs-symbol">http:/<span class="hljs-regexp">/192.168.1.114/yii<span class="hljs-regexp">/demos/test.php?backfunc=jQuery2030038573939353227615_1402643146875&amp;action=aaron
然后动态加载
&lt;script type=<span class="hljs-string">"text/javascript"src=<span class="hljs-string">"http://192.168.1.114/yii/demos/test.php?backfunc=&gt;
然后后端就会执行backfunc(传递参数 )，把数据通过实参的形式发送出去。

</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>在jquery 源码中， jsonp的实现方式是动态添加&lt;script&gt;标签来调用服务器提供的 js脚本。jquery 会在window对象中加载一个全局的函数，当 &lt;script&gt;代码插入时函数执行，执行完毕后就 &lt;script&gt;会被移除。同时jquery还对非跨域的请求进行了优化，如果这个请求是在同一个域名下那么他就会像正常的 Ajax请求一样工作。</p>
<h3>95、 http协议属于七层协议中的哪一层，下一层是什么</h3>
<p>七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br />
tcp属于传输层；http属于应用层。<br />
表现层</p>
<h3>96、 js垃圾回收机制知道哪些，v8引擎使用的哪一种</h3>
<h4>js的两种回收机制</h4>
<p>1 标记清除（mark and sweep）<br />
2 引用计数（reference counting）</p>
<h4>javascript与V8引擎</h4>
<p>垃圾回收机制的好处和坏处</p>
<p>好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。</p>
<p>坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。</p>
<p>V8 自动垃圾回收算法<br />
<a href="https://segmentfault.com/a/1190000000440270" rel="nofollow" target="_blank">https://segmentfault.com/a/11...</a></p>
<h3>97、 作用域什么时候生成的？</h3>
<p>页面加载--&gt;创建window全局对象，并生成全局作用域--&gt;然后生成执行上下文，预解析变量(变量提升)，生成全局变量对象；<br />
$scope</p>
<h3>98、 websocket长连接原理是什么</h3>
<h4>含义</h4>
<p>Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。</p>
<h4>原理</h4>
<p>类似长轮循长连接 ; 发送一次请求 ; 源源不断的得到信息</p>
<h3>28. http缓存知道哪些</h3>
<p><a href="http://blog.csdn.net/yzf913214/article/details/52268651" rel="nofollow" target="_blank">http://blog.csdn.net/yzf91321...</a></p>
<h3>99、 讲一下事件循环机制</h3>
<p>执行上下文(Execution context)<br />
函数调用栈(call stack)<br />
队列数据结构(queue)<br />
Promise</p>
<p><a href="https://zhuanlan.zhihu.com/p/25407758" rel="nofollow" target="_blank">https://zhuanlan.zhihu.com/p/...</a></p>
<h3>100、 理解web安全吗？都有哪几种，介绍以及如何预防</h3>
<p>1.XSS，也就是跨站脚本注入</p>
<pre><code><code>攻击方法：
<span class="hljs-number">1\. 手动攻击:
编写注入脚本，比如&rdquo;/&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script&gt;<span>alert(<span class="hljs-built_in">document.cookie());<span class="hljs-tag">&lt;/<span class="hljs-name">script&gt;&lt;!--等，
手动测试目标网站上有的input, textarea等所有可能输入文本信息的区域
2\. 自动攻击
利用工具扫描目标网站所有的网页并自动测试写好的注入脚本，比如：Burpsuite等
防御方法：
1\. 将cookie等敏感信息设置为httponly，禁止Javascript通过document.cookie获得
2\. 对所有的输入做严格的校验尤其是在服务器端，过滤掉任何不合法的输入，比如手机号必须是数字，通常可以采用正则表达式
3\. 净化和过滤掉不必要的html标签，比如：&lt;iframe&gt;, alt,&lt;script&gt; 等
4\. 净化和过滤掉不必要的Javascript的事件标签，比如：onclick, onfocus等
5\. 转义单引号，双引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符
6\. 设置浏览器的安全设置来防范典型的XSS注入

</span></span></span></span></span></span></span></span></code></pre>
<p>2.SQL注入</p>
<pre class="hljs python"><code class="python">攻击方法：
编写恶意字符串，比如&lsquo; <span class="hljs-keyword">or  <span class="hljs-number">1=<span class="hljs-number">1--等，
手动测试目标网站上所有涉及数据库操作的地方
防御方法：
<span class="hljs-number">1\. 禁止目标网站利用动态拼接字符串的方式访问数据库
<span class="hljs-number">2\. 减少不必要的数据库抛出的错误信息
<span class="hljs-number">3\. 对数据库的操作赋予严格的权限控制
<span class="hljs-number">4\. 净化和过滤掉不必要的SQL保留字，比如：where, <span class="hljs-keyword">or, <span class="hljs-keyword">exec 等
<span class="hljs-number">5\. 转义单引号，上引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符

</span></span></span></span></span></span></span></span></span></span></code></pre>
<p>3.CSRF，也就是跨站请求伪造</p>
<pre class="hljs bash"><code class="bash">就是攻击者冒用用户的名义，向目标站点发送请求
防范方法：
1\. 在客户端进行cookie的hashing，并在服务端进行<span class="hljs-built_in">hash认证
2\. 提交请求是需要填写验证码
3\. 使用One-Time Tokens为不同的表单创建不同的伪随机值  

</span></code></pre>
<h3>101、 sessionStorage和localstorage能跨域拿到吗？比如我在<a href="http://www.baidu.com" rel="nofollow" target="_blank">www.baidu.com</a>设置的值能在<a href="http://m.baidu.com" rel="nofollow" target="_blank">m.baidu.com</a>能拿到吗？为什么</h3>
<p>localStorage会跟cookie一样受到跨域的限制，会被document.domain影响</p>
<h3>102、 localstorage不能手动删除的时候，什么时候过期</h3>
<p>除非被清除，否则永久保存 clear()可清楚<br />
sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除</p>
<h3>103、cookie可以设置什么域？可以设置.com吗</h3>
<p>可以通过设置domin来实现</p>
<h3>104、登录状态的保存你认为可以保存在sessionstorage或者localstorage或者cookie或者你知道的哪种方式，存在了哪里？？为什么保存在那里</h3>
<h3>105、 flux -&gt; redux -&gt; mobx 变化的本质是什么</h3>
<p>存储结构 将对象加工可观察 函数式 vs 面向对象<br />
<a href="https://zhuanlan.zhihu.com/p/25585910?refer=purerender" rel="nofollow" target="_blank">https://zhuanlan.zhihu.com/p/...</a></p>
<h3>106、 按需加载路由怎么加载对应的chunk文件的？换句话说浏览器怎么知道什么时候加载这个chunk，以及webpack是怎么识别那个多个经过hash过的chunk文件</h3>
<h3>107、get和post有什么区别？get可以通过body传递数据吗</h3>
<p>把数据放到 body 里面，必须用 POST 方式取，这是 HTTP 协议限制的。</p>
<h3>108、右边宽度固定，左边自适应</h3>
<p>第一种：</p>
<pre class="hljs xml"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style&gt;<span class="css">
<span class="hljs-selector-tag">body{
    <span class="hljs-attribute">display: flex;
}
<span class="hljs-selector-class">.left{
    <span class="hljs-attribute">background-color: rebeccapurple;
    <span class="hljs-attribute">height: <span class="hljs-number">200px;
    <span class="hljs-attribute">flex: <span class="hljs-number">1;
}
<span class="hljs-selector-class">.right{
    <span class="hljs-attribute">background-color: red;
    <span class="hljs-attribute">height: <span class="hljs-number">200px;
    <span class="hljs-attribute">width: <span class="hljs-number">100px;
}
<span class="hljs-tag">&lt;/<span class="hljs-name">style&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">body&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">class=<span class="hljs-string">"left"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">class=<span class="hljs-string">"right"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">body&gt;
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>第二种</p>
<pre class="hljs xml"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style&gt;<span class="css">
    <span class="hljs-selector-tag">div {
        <span class="hljs-attribute">height: <span class="hljs-number">200px;
    }
    <span class="hljs-selector-class">.left {
        <span class="hljs-attribute">float: right;
        <span class="hljs-attribute">width: <span class="hljs-number">200px;
        <span class="hljs-attribute">background-color: rebeccapurple;
    }
    <span class="hljs-selector-class">.right {
        <span class="hljs-attribute">margin-right: <span class="hljs-number">200px;
        <span class="hljs-attribute">background-color: red;
    }
<span class="hljs-tag">&lt;/<span class="hljs-name">style&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">body&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">class=<span class="hljs-string">"left"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">div <span class="hljs-attr">class=<span class="hljs-string">"right"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">body&gt;
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>109、水平垂直居中</h3>
<p>第一种</p>
<pre class="hljs css"><code class="css"><span class="hljs-selector-id">#container{
    <span class="hljs-attribute">position:relative;
}

<span class="hljs-selector-id">#center{
    <span class="hljs-attribute">width:<span class="hljs-number">100px;
    <span class="hljs-attribute">height:<span class="hljs-number">100px;
    <span class="hljs-attribute">position:absolute;
    <span class="hljs-attribute">top:<span class="hljs-number">50%;
    <span class="hljs-attribute">left:<span class="hljs-number">50%;
    <span class="hljs-attribute">transform: <span class="hljs-built_in">translate(-50%,-50%);
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>第二种</p>
<pre class="hljs css"><code class="css"><span class="hljs-selector-id">#container{
    <span class="hljs-attribute">position:relative;
}

<span class="hljs-selector-id">#center{
    <span class="hljs-attribute">width:<span class="hljs-number">100px;
    <span class="hljs-attribute">height:<span class="hljs-number">100px;
    <span class="hljs-attribute">position:absolute;
    <span class="hljs-attribute">top:<span class="hljs-number">50%;
    <span class="hljs-attribute">left:<span class="hljs-number">50%;
    <span class="hljs-attribute">margin:-<span class="hljs-number">50px <span class="hljs-number">0 <span class="hljs-number">0 -<span class="hljs-number">50px;
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>第三种</p>
<pre class="hljs css"><code class="css"><span class="hljs-selector-id">#container{
    <span class="hljs-attribute">position:relative;
}

<span class="hljs-selector-id">#center{
    <span class="hljs-attribute">position:absolute;
    <span class="hljs-attribute">margin:auto;
    <span class="hljs-attribute">top:<span class="hljs-number">0;
    <span class="hljs-attribute">bottom:<span class="hljs-number">0;
    <span class="hljs-attribute">left:<span class="hljs-number">0;
    <span class="hljs-attribute">right:<span class="hljs-number">0;
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>第四种 flex</p>
<pre class="hljs css"><code class="css"><span class="hljs-selector-id">#container{
    <span class="hljs-attribute">display:flex;
    <span class="hljs-attribute">justify-content:center;
    <span class="hljs-attribute">align-items: center;
}
</span></span></span></span></code></pre>
<h3>109、.四种定位的区别</h3>
<p><code>static</code> 是默认值<br />
<code>relative</code> 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中<br />
<code>absolute</code> 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指<code>position</code>不是<code>static</code>的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以<code>body</code>元素为偏移参照基准, 完全脱离了标准文档流。<br />
<code>fixed</code> 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。</p>
<h3>110、封装一个函数，参数是定时器的时间，.then执行回调函数。</h3>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">sleep (<span class="hljs-params">time) {
  <span class="hljs-keyword">return <span class="hljs-keyword">new <span class="hljs-built_in">Promise(<span class="hljs-function">(<span class="hljs-params">resolve) =&gt; setTimeout(resolve, time));
}
</span></span></span></span></span></span></span></span></span></code></pre>
<h3>111、一行代码实现数组去重？</h3>
<pre class="hljs json"><code class="json">[...new Set([<span class="hljs-number">1,<span class="hljs-number">2,<span class="hljs-number">3,<span class="hljs-number">1,'a',<span class="hljs-number">1,'a'])]
</span></span></span></span></span></code></pre>
<h3>112、使用addEventListener点击li弹出内容，并且动态添加li之后有效</h3>
<pre class="hljs xml"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">li&gt;1<span class="hljs-tag">&lt;/<span class="hljs-name">li&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">li&gt;2<span class="hljs-tag">&lt;/<span class="hljs-name">li&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">li&gt;3<span class="hljs-tag">&lt;/<span class="hljs-name">li&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">li&gt;4<span class="hljs-tag">&lt;/<span class="hljs-name">li&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">ul&gt;
var ulNode = document.getElementById("ul");
    ulNode.addEventListener('click', function (e) {
        if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == "LI") {
            alert(e.target.innerHTML);
        }
    }, false);
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>113、怎么判断两个对象相等</h3>
<pre><code><code><span class="hljs-built_in">JSON.stringify(obj)==<span class="hljs-built_in">JSON.stringify(obj);<span class="hljs-comment">//true
</span></span></span></code></pre>
<h3>114、Vue router 除了 router-link 怎么实现跳转?</h3>
<pre class="hljs bash"><code class="bash">router.go(1)
router.push(<span class="hljs-string">'/')
</span></code></pre>
<h3>115、Vue router 跳转和 location.href 有什么区别？</h3>
<p><code>router</code> 是 <code>hash</code> 改变<br />
<code>location.href</code> 是页面跳转，刷新页面</p>
<h3>116、重排和重绘</h3>
<p>部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。<br />
由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。</p>
<h3>117、什么情况会触发重排和重绘</h3>
<p>添加、删除、更新 DOM 节点<br />
通过 display: none 隐藏一个 DOM 节点-触发重排和重绘<br />
通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化<br />
移动或者给页面中的 DOM 节点添加动画<br />
添加一个样式表，调整样式属性<br />
用户行为，例如调整窗口大小，改变字号，或者滚动。</p>
<h3>118、js bind 实现机制？手写一个 bind 方法？</h3>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">bind(<span class="hljs-params">fn, context){
  <span class="hljs-keyword">return <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">){
     <span class="hljs-keyword">return fn.apply(context, <span class="hljs-built_in">arguments);
  }
}
<span class="hljs-comment">// 柯理化函数思想   感谢pursuitTom的提出
<span class="hljs-built_in">Function.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">context) {
    <span class="hljs-keyword">var args = <span class="hljs-built_in">Array.prototype.slice.call(<span class="hljs-built_in">arguments, <span class="hljs-number">1);
    <span class="hljs-keyword">var _this = <span class="hljs-keyword">this;
    <span class="hljs-keyword">return <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) {
        <span class="hljs-keyword">var thisArgs = [].slice.call(<span class="hljs-built_in">arguments);
        <span class="hljs-keyword">return _this.apply(context, args.concat(thisArgs))
    };
}
<span class="hljs-comment">// ES6写法 感谢waterc的提出
<span class="hljs-built_in">Function.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">context, ...res) {
    <span class="hljs-keyword">let self = <span class="hljs-keyword">this
    <span class="hljs-keyword">return <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">...arg) {
        <span class="hljs-keyword">return self.apply(context, [...res,...arg])
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>119、多个函数</h3>
<pre><code><code><span class="hljs-keyword">var a = (<span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){<span class="hljs-keyword">return <span class="hljs-string">'1';}, <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){<span class="hljs-keyword">return <span class="hljs-number">1;})();
<span class="hljs-built_in">console.log(<span class="hljs-keyword">typeof a); <span class="hljs-comment">//number
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>120、<strong>proto</strong>、prototype、Object.getPrototypeOf()</h3>
<pre><code><code>__proto__是指内部原型，和<span class="hljs-built_in">Object.getPrototypeOf()结果等价
<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">f(<span class="hljs-params">){}
f.__proto__ === <span class="hljs-built_in">Object.getPrototypeOf(f); <span class="hljs-comment">//true
f.prototype === <span class="hljs-built_in">Object.getPrototypeOf(f); <span class="hljs-comment">//false
</span></span></span></span></span></span></span></span></span></code></pre>
<h3>121、浏览记录前后跳转（尚未试验）</h3>
<pre class="hljs xml"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a <span class="hljs-attr">href=<span class="hljs-string">"javascript:history.go(-1)"&gt;backward<span class="hljs-tag">&lt;/<span class="hljs-name">a&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">a <span class="hljs-attr">href=<span class="hljs-string">"javascript:history.go(1)"&gt;forward<span class="hljs-tag">&lt;/<span class="hljs-name">a&gt;
</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>122、setTimeout 和 setInterval 细谈</h3>
<p>常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。<br />
后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。<br />
如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval</p>
<pre><code><code><span class="hljs-keyword">var time = <span class="hljs-number">400, times = <span class="hljs-number">0, max = <span class="hljs-number">10;
<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">func(<span class="hljs-params">){
  times++;
  <span class="hljs-keyword">if(times &lt; max){
    <span class="hljs-comment">//code here
    setTimeout(func, time);
  } <span class="hljs-keyword">else {
    <span class="hljs-built_in">console.log(<span class="hljs-string">"finished");
  }
}
setTimeout(func, time);
</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3>123、判断多图片加载完毕</h3>
<p>注：用jQueryObject.ready()只能判断dom结构加载完毕<br />
好像描述的不是很清楚，这里写一下代码。<br />
方法1：</p>
<pre><code><code><span class="hljs-keyword">var counter = <span class="hljs-number">0;
<span class="hljs-keyword">var queryInterval = <span class="hljs-number">30; <span class="hljs-comment">//ms
<span class="hljs-keyword">var pics = <span class="hljs-built_in">document.getElementsByClassName(<span class="hljs-string">"pics");

<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">singleQuery(<span class="hljs-params">i){
  <span class="hljs-keyword">if(pics[i].complete){
    counter++;
    <span class="hljs-built_in">console.log(i + <span class="hljs-string">" is loaded");
  } <span class="hljs-keyword">else {
    setTimeout(singleQuery, queryInterval, i);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">allQuery(<span class="hljs-params">callback){
  <span class="hljs-keyword">if(counter &lt; pics.length){
    <span class="hljs-built_in">console.log(<span class="hljs-string">"current number of loaded pics: " + counter);
    setTimeout(allQuery, queryInterval, callback);
  } <span class="hljs-keyword">else {
    <span class="hljs-built_in">console.log(<span class="hljs-string">"All pics are loaded.");
    callback();
  }
}

<span class="hljs-keyword">for(<span class="hljs-keyword">var i = <span class="hljs-number">0; i &lt; pics.length; i++){
  setTimeout(singleQuery, queryInterval, i);
}

setTimeout(allQuery, queryInterval, callback);

</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>主要也是采用setTimeout模拟轮询，判断方式是img标签dom的complete属性（布尔值），缺点是定时器太多。</p>
<p>方法2：</p>
<pre><code><code><span class="hljs-keyword">var counter = <span class="hljs-number">0, queryInterval = <span class="hljs-number">50;
<span class="hljs-keyword">var pics = <span class="hljs-built_in">document.getElementsByClassName(<span class="hljs-string">"pics");
<span class="hljs-keyword">for(<span class="hljs-keyword">var i = <span class="hljs-number">0; i &lt; pics.length; i++){
  pics[i].onload = <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){
    counter++;
    <span class="hljs-built_in">console.log(<span class="hljs-keyword">this.id + <span class="hljs-string">" is loaded");
  }
}

<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">queryPictures(<span class="hljs-params">callback){
  <span class="hljs-keyword">if(counter &lt; pics.length){
    <span class="hljs-built_in">console.log(<span class="hljs-string">"current number of loaded pics: " + counter);
    setTimeout(queryPictures, queryInterval, callback);
  } <span class="hljs-keyword">else {
    <span class="hljs-built_in">console.log(<span class="hljs-string">"All pics are loaded");
    callback();
  }
}

setTimeout(queryPictures, queryInterval, callback);
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>利用onload绑定图片加载成功后的回调，通过计数器判断是否加载完毕。</p>
<h3>124、CSS margin重叠问题</h3>
<p>块元素在垂直方向上的margin是很奇怪的，会有重叠现象。<br />
如果display都是block，有三种情况：<br />
外间距均为正数，竖直方向上会选择最大的外边距作为间隔<br />
一正一负，间距 = 正 - |负|<br />
两个负，间距 = 0 - 绝对值最大的那个<br />
设置display: inline-block的盒子不会有margin重叠，position: absolute的也不会出现。</p>
<h3>125、CSS选择器优先级 &amp;&amp; CSS选择器效率</h3>
<p>ID &gt; 类 &gt; 标签 &gt; 相邻 &gt; 子选择器 &gt; 后代选择器 &gt; * &gt; 属性 &gt; 伪类</p>
<h3>object.propertyIsEnumerable(xxx)</h3>
<p>判断对象中是否有xxx属性，并且能通过for in枚举，如Array对象的length是不可枚举的</p>
<h3>126、判断数组</h3>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">isArray(<span class="hljs-params">arr){
    <span class="hljs-keyword">return <span class="hljs-built_in">Object.prototype.toString.call(arr) === <span class="hljs-string">'[Object Array]';
}

</span></span></span></span></span></span></span></code></pre>
<h3>127、git fetch &amp;&amp; git pull</h3>
<p>git pull自动完成了fetch最新远程版本，并且和本地进行merge<br />
git fetch获得远程分支，要继续手动merge合并</p>
<h3>128、WebSocket</h3>
<p>HTML5带来的新协议，通过类似HTTP的请求建立连接。主要目的是可以获取服务端的推送。<br />
原来的方式可能是使用long poll（即不中断连接一直等待数据），或者是ajax轮询的方式（每隔一段时间发送请求，建立连接，询问是否有新的数据）。这两种方式的缺点在于long poll的阻塞，以及ajax轮询的冗余连接。<br />
WebSocket的设计思想有点类似于回调，在发送请求升级服务端的协议并收到确认信息后，服务端一有新的信息/数据就会主动推送给客户端，至于要一次HTTP握手便可以建立持久连接</p>
<h3>129、跨域相关</h3>
<p>只要协议、域名、端口有不同，则视为不同的域。（域名和域名对应的IP也是跨域）</p>
<h4>1.CORS: Cross-Origin Resource Sharing</h4>
<p>基于服务器支持的跨域，服务器设置Access-Control-Allow-Origin响应头，浏览器可允许跨域</p>
<h4>2.设置domain</h4>
<p>能从子域设到主域，如a.b.c.com&mdash;&gt;b.c.com&mdash;&gt;c.com<br />
具体情况：在页面中用iframe打开了另一个页面（前提：两个页面主域是相同的）<br />
利用frameElement.contentWindow.document.domain设置frame子页面的主域，document.domain设置主页面的主域，之后就能互相获取dom中的数据。<br />
缺点是只能用于不同子域间的交互。</p>
<h4>3.例如拥有src属性的img标签，每次改变src属性，都会发起http请求。</h4>
<pre><code><code><span class="hljs-keyword">var img = <span class="hljs-keyword">new Image();
img.onload = <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){
  <span class="hljs-comment">//code here
};
img.onerror = <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">){
  <span class="hljs-comment">//code here
};
img.src=<span class="hljs-string">"http://server.com/data?query=3";
</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>缺点是只能使用GET请求，不能获取数据，一般用于提交统计信息什么的。<br />
script、link、iframe只有在添加到DOM中才会发起请求</p>
<h4>4.HTML5 postMessage</h4>
<p>支持IE8+和主流浏览器，写法也简单..</p>
<pre><code><code><span class="hljs-comment">//source: http://test.org:4000
<span class="hljs-comment">//get the window object of target origin
<span class="hljs-keyword">var win = <span class="hljs-built_in">window.open(<span class="hljs-string">"http://target.com");
<span class="hljs-comment">//or this, when a frame is used
<span class="hljs-keyword">var win = <span class="hljs-built_in">document.getElementById(<span class="hljs-string">"targetId").contentWindow;
win.postMessage(<span class="hljs-string">"data here", <span class="hljs-string">"http://target.com/rest");

<span class="hljs-comment">//target: http://target.com/tiny
<span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">handleMessage(<span class="hljs-params">event){
  <span class="hljs-keyword">if(event.orgin!=<span class="hljs-string">"http://test.org:4000")
    <span class="hljs-keyword">return;
  <span class="hljs-keyword">var data = event.data;
  <span class="hljs-comment">//code here

  <span class="hljs-comment">//event.source is window.opener
  event.source.postMessage(<span class="hljs-string">"response data here", event.origin);
}
<span class="hljs-built_in">window.addEventListener(<span class="hljs-string">"message", handleMessage, <span class="hljs-literal">false);
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h4>5.window.name</h4>
<p>即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具。<br />
但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)：</p>
<h4>6. jsonp</h4>
<p>目前主流跨域方法<br />
调用其他域的脚本获取数据，前提是另一个域能知道回调函数名，这个可以通过请求发送给目标域。<br />
直接写jQuery封的jsonp</p>
<pre><code><code>$.getJSON(<span class="hljs-string">"http://target.com/data?callback=callbackFunctionName", <span class="hljs-function"><span class="hljs-keyword">function(<span class="hljs-params">data){});
</span></span></span></span></code></pre>
<p>$.getJSON会把获取的responseText转为json，如果url中有callback参数，数据会以script标签形式获取。</p>
<h3>130、闭包相关</h3>
<h4>什么是闭包</h4>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中变量的函数</p>
</blockquote>
<h4>怎么创建闭包</h4>
<blockquote>
<p>在函数内部嵌套使用函数</p>
</blockquote>
<pre><code><code><span class="hljs-function"><span class="hljs-keyword">function <span class="hljs-title">fn(<span class="hljs-params">) {
           <span class="hljs-keyword">for (<span class="hljs-keyword">var i = <span class="hljs-number">0; i &lt; <span class="hljs-number">2; i++) {
               (<span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) {
                   <span class="hljs-keyword">var variate = i;
                   setTimeout(<span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) {
                       <span class="hljs-built_in">console.log(<span class="hljs-string">"setTimeout执行后:"+variate);
                   }, <span class="hljs-number">1000);
               })();<span class="hljs-comment">//闭包,立即执行函数,匿名函数

           }
          <span class="hljs-built_in">console.log(i);<span class="hljs-comment">//2
          <span class="hljs-built_in">console.log(variate);<span class="hljs-comment">//variate is not defined
       }
       fn();

</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h4>为什么用闭包</h4>
<ul>
<li>因为在闭包内部保持了对外部活动对象的访问,但外部的变量却无法直接访问内部,避免了全局污染;</li>
<li>可以当做私有成员,弥补了因js语法带来的面向对象编程的不足;</li>
<li>可以长久的在内存中保存一个自己想要保存的变量.</li>
</ul>
<h4>闭包的缺点</h4>
<ul>
<li>可能导致内存占用过多,因为闭包携带了自身的函数作用域</li>
<li>闭包只能取得外部包含函数中得最后一个值</li>
</ul>
<p>详见<a href="https://segmentfault.com/a/1190000014540734?utm_source=channel-hottest" rel="nofollow" target="_blank">https://segmentfault.com/a/11...</a></p>
<h3>131、a:active 移动端实现</h3>
<p>有时候一些按钮的简单点击交互可以通过css伪类来实现；必须点击了更改颜色；松开恢复；IOS手机会出现伪类无效的情况；iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。</p>
<pre><code><code><span class="hljs-built_in">document.body.addEventListener(<span class="hljs-string">'touchstart', <span class="hljs-function"><span class="hljs-keyword">function (<span class="hljs-params">) { <span class="hljs-comment">//...空函数即可});
</span></span></span></span></span></span></code></pre>
<h3>132、ios滑动卡顿</h3>
<p>-webkit-overflow-scrolling:touch 可能会在IOS系统低的情况出现滚动条；尝试溢出解决</p>
<h3>133、forEach和map的区别</h3>
<p>相同点</p>
<ul>
<li>都是循环遍历数组中的每一项</li>
<li>forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）</li>
<li>匿名函数中的this都是指向window</li>
<li>只能遍历数组</li>
<li>都有兼容问题</li>
</ul>
<p>不同点</p>
<ul>
<li>map速度比foreach快</li>
<li>map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，</li>
<li>map因为返回数组所以可以链式操作，foreach不能</li>
</ul>
<h3>134、浅拷贝和深拷贝</h3>
<p>jQuery.extend第一个参数可以是布尔值，用来设置是否深度拷贝的</p>
<pre class="hljs css"><code class="css"><span class="hljs-selector-tag">jQuery<span class="hljs-selector-class">.extend(<span class="hljs-selector-tag">true, { <span class="hljs-attribute">a : { a : <span class="hljs-string">"a" } }, { <span class="hljs-attribute">a : { b : <span class="hljs-string">"b" } } );
<span class="hljs-selector-tag">jQuery<span class="hljs-selector-class">.extend( { <span class="hljs-attribute">a : { a : <span class="hljs-string">"a" } }, { <span class="hljs-attribute">a : { b : <span class="hljs-string">"b" } } ); 
</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>最简单的深拷贝</p>
<pre><code><code>aa = <span class="hljs-built_in">JSON.parse( <span class="hljs-built_in">JSON.stringify(a) )
</span></span></code></pre>
<p>浅复制---&gt;就是将一个对象的内存地址的&ldquo;&rdquo;编号&ldquo;&rdquo;复制给另一个对象。深复制---&gt;实现原理，先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的(注意可枚举的对象)属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到子子.....属性为基本数据类型。总结，深复制理解两点，1,新开辟内存地址，2,递归来刨根复制。</p>
<h3>135、外边距合并</h3>
<blockquote>
<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。<br />
合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>


</blockquote>
<h3>136、js加载位置区别优缺点</h3>
<p>html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。<br />
所以，大部分网上讨论是将script脚本放在&lt;body&gt;之后，那样dom的生成就不会因为长时间执行script脚本而延迟阻塞，加快了页面的加载速度。</p>
<p>但又不能将所有的script放在body之后，因为有一些页面的效果的实现，是需要预先动态的加载一些js脚本。所以这些脚本应该放在&lt;body&gt;之前。</p>
<p>其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效</p>
<p><strong>script放置位置的原则&ldquo;页面效果实现类的js应该放在body之前，动作，交互，事件驱动，需要访问dom属性的js都可以放在body之后</strong></p>

</div>

<br /><br />作者：O蚂蚁O<br />链接：https://www.jianshu.com/p/f1f39d5b2a2e<br />来源：简书<br />简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>