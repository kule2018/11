<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修prototype，__proto__，constructor理解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>prototype，__proto__，constructor理解</center></div><div class='banquan'>原文出处:本文由博客园博主素昧平生97提供。<br/>
原文连接:https://www.cnblogs.com/bravefuture/p/11265909.html</div><br>
    <p><span style="font-size: 15px;">prototype:&nbsp;<span class="md-expand">任何函数（箭头函数除外）都具有一个 prototype属性，<span style="color: #ff0000;">该属性是一个对象</span>。一般情况下只有声明function的变量才会有（自动生成）prototype这个属性，而function通过在它的名字前加new 可以创建出属于它的实例。是<span style="color: #ff0000;">函数所独有</span>的。</span></span></p>
<p><span style="font-size: 15px;">__proto__: 引用类型的__proto__属性是浏览器给他们添加的一个自定义属性，属性值也是一个普通对象。引用类型的__proto__属性指向它们的构造函数的prototype属性。<span style="color: #ff0000;">对象所独有</span>的。</span></p>
<p><span style="font-size: 15px;">constructor: 是一个构造函数，是一种特殊的method。在生成prototype时自动生成的属性，其指向函数本身（在申明函数时，js自动创建该函数的peototype属性）。在用new给一个类创建对象的时候会自动调用该类的构造函数。<span style="color: #ff0000;">对象所独有</span>的。</span></p>
<p><span style="font-size: 15px;">&nbsp;</span></p>
<div class="cnblogs_code">
<pre><code>let fn = <span style="color: #0000ff;">function</span><span style="color: #000000;">() {}
let fn2 </span>= <span style="color: #0000ff;">new</span> fn()</pre>
</div>
<p>关系图解：</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>prototype</strong></span></p>
<p>&nbsp;任何函数（箭头函数除外）都具有一个 prototype属性</p>
<p><img src="./images/prototype，__proto__，constructor理解0.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>__proto__</strong></span></p>
<p>&nbsp;一个对象的__proto__指向产生它的类的prototype。<span style="color: #ff0000;">function声明的变量的__proto__指向Function的prototype，其它对象的__proto__指向Object的prototype。</span>每个函数的prototype是一个对象，prototype的__proto__指向一定是Object.prototype。</p>
<p>特殊的Function跟Object</p>
<p>Function:</p>
<p><img src="./images/prototype，__proto__，constructor理解1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/prototype，__proto__，constructor理解2.png" alt="" /></p>
<p>从控制台分别打印Function的prototype跟__proto__，可以明显的看出来Function的__proto__指向了自己的prototype。</p>
<p>Object:</p>
<p><img src="./images/prototype，__proto__，constructor理解3.png" alt="" /></p>
<p><img src="./images/prototype，__proto__，constructor理解4.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;如上图，Object与Function的__proto__的指向是相同的，都是指向了Function的prototype。</p>
<p><img src="./images/prototype，__proto__，constructor理解5.png" alt="" /></p>
<p>&nbsp;</p>
<p>如上图，Object的proptotype又有些不同，没有灰色的&lt;prototype&gt;，在控制台中也可以清楚的看到Object的__proto__指向了null，也可以讲Object.prototype看作为一切之源。</p>
<p>&nbsp;</p>
<p><img src="./images/prototype，__proto__，constructor理解6.png" alt="" /></p>
<p>Object的prototype称为源型，将图逆推，</p>
<p>所有通过这个源型创造出的都是object，第一步先创造出Function的prototype，因此这个prototype的__proto__指向源型，然后再通过这个prototype造出Function，因此Function的__proto__指向它自己的prototype，然后用Function造出Object，因此Object的__proto__指向Function的prototype。</p>
<p><span style="color: #ff0000;">&nbsp;peototype是原型，__proto__所指向的以及其后的所有peototype称为原型链。</span></p>
<p><span style="font-size: 18pt;"><strong><span style="color: #000000;">constructor</span></strong></span></p>
<p><code></code><span style="color: red;">对象独有的</span>，它是从<span style="color: red;">一个对象指向一个函数</span>，含义就是<span style="color: red;">指向该对象的构造函数<span style="color: #000000;">。</span></span></p>
<p><span style="color: red;"><span style="color: #000000;">根据上文逆推的结论：所有函数和对象最终都是由Function构造函数得来，所以<span style="color: #ff0000;"><code>constructor</code>属性的终点就是Function这个函数</span>。</span></span></p>
<p><span style="color: red;"><span style="color: #000000;">当一个对象不具备constructor时会沿着__proto__到原型链中去找。</span></span></p>
<p><img src="./images/prototype，__proto__，constructor理解7.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>总结</strong></span></p>
<p><img src="./images/prototype，__proto__，constructor理解8.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src="./images/prototype，__proto__，constructor理解9.png" alt="" /></p>
<p>感谢两篇博文，内容主要参考博文：<a href="https://blog.csdn.net/cc18868876837/article/details/81211729#4_constructor_20">https://blog.csdn.net/cc18868876837/article/details/81211729#4_constructor_20</a>，<a href="https://blog.csdn.net/backee/article/details/83378772">https://blog.csdn.net/backee/article/details/83378772</a></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>