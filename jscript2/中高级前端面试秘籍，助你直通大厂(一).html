<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修中高级前端面试秘籍，助你直通大厂(一)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>中高级前端面试秘籍，助你直通大厂(一)</center></div><div class='banquan'>原文出处:本文由博客园博主小维FE提供。<br/>
原文连接:https://www.cnblogs.com/tangshiwei/p/11925903.html</div><br>
    <h2 id="引言">引言</h2>
<p>又是一年寒冬季，只身前往沿海工作，也是我第一次感受到沿海城市冬天的寒冷。刚过完金九银十，经过一场惨烈的江湖厮杀后，相信有很多小伙伴儿已经找到了自己心仪的工作，也有的正在找工作的途中。考虑到年后必定又是一场不可避免的厮杀，这里提前记录一下自己平时遇到和总结的一些知识点，自己巩固复习加强基础的同时也希望能在你的江湖路上对你有所帮助。笔者在入职最近这家公司之前也曾有过长达3个月的闭关修炼期，期间查阅资料无数，阅读过很多文章，但总结下来真正让你印象深刻的，不是那些前沿充满神秘感的新技术，也不是为了提升代码逼格的奇淫巧技，而是那些我们经常由于项目周期紧而容易忽略的基础知识。<strong>所谓万丈高楼平地起，只有你的地基打得足够牢固，你才有搭建万丈高楼的底气，你才能在你的前端人生路上越走越远</strong>。</p>
<p>这篇主要是先总结一下CSS相关的知识点，可能某些部分不会涉及到太多具体的细节，主要是对知识点做一下汇总，如果有兴趣或者有疑惑的话可以自行百度查阅下相关资料或者在下方评论区留言讨论，后续文章再继续总结JS和其他方面相关的知识点，如有不对的地方还请指出。</p>
<h3 id="css盒模型">1. CSS盒模型</h3>
<p>CSS盒模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。CSS 假定所有的HTML 文档元素都生成了一个描述该元素在HTML文档布局中所占空间的矩形元素框，可以形象地将其看作是一个盒子。CSS 围绕这些盒子产生了一种“盒子模型”概念，通过定义一系列与盒子相关的属性，可以极大地丰富和促进各个盒子乃至整个HTML文档的表现效果和布局结构。</p>
<p>CSS盒模型可以看成是<strong>由从内到外的四个部分构成，即内容区（content）、内边距(padding)、边框(border)和外边距(margin)。内容区是盒子模型的中心，呈现盒子的主要信息内容；内边距是内容区和边框之间的空间；边框是环绕内容区和内边距的边界；外边距位于盒子的最外围，是添加在边框外周围的空间。</strong><br />
<img src="./images/中高级前端面试秘籍，助你直通大厂(一)0.png" /><br />
根据计算宽高的区域我们可以将其分为<code>IE盒模型</code>和<code>W3C标准盒模型</code>，可以通过<code>box-sizing</code>来进行设置：</p>
<ul>
<li><code>content-box</code>：W3C标准盒模型</li>
<li><code>border-box</code>：IE盒模型</li>
</ul>
<p>区别：<br />
<code>W3C标准盒模型</code>：width(宽度) = content(内容宽度)<br />
<code>IE盒模型</code>：width(宽度) = content(内容宽度) + padding(内边距) + border(边框)</p>
<h3 id="bfc">2. BFC</h3>
<p>BFC即Block Fromatting Context(块级格式化上下文)，它是页面中的一块独立的渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。具有BFC特性的元素可以看成是一个隔离的独立容器，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>
<blockquote>
<p>IE浏览器下为hasLayout，一般可以通过zoom:(除normal外任意值)来触发，hasLayout是IE浏览器渲染引擎的一个内部组成部分。在IE浏览器中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和和组织内容。为了调节这两个不同的概念，渲染引擎采用了hasLayout的属性，属性值可以为true或false。当一个元素的hasLayout属性为true时，我们就说这个元素有一个布局(Layout)。当拥有布局后，它会负责对自己和可能的子孙元素进行尺寸计算和定位，而不是依赖于祖先元素来完成这些工作。</p>
</blockquote>
<h4 id="触发条件">2.1 触发条件</h4>
<ul>
<li>根元素(<code>&lt;html&gt;</code>)</li>
<li>浮动元素(元素的<code>float</code>不是<code>none</code>)</li>
<li>绝对定位元素(元素的<code>position</code>为<code>absolute</code>或<code>fixed</code>)</li>
<li>行内块元素(元素的<code>display</code>为<code>inline-block</code>)</li>
<li>表格单元格(元素的<code>display</code>为<code>table-cell</code>，HTML表格单元格默认为该值)</li>
<li>表格标题(元素的<code>display</code>为<code>table-caption</code>，HTML表格标题默认为该值)</li>
<li><code>display</code>值为<code>flow-root</code>的元素</li>
<li><code>overflow</code>属性的值不为<code>visible</code></li>
<li>弹性元素(<code>display</code>为<code>flex</code>或<code>inline-flex</code>元素的直接子元素)</li>
<li><p>网格元素(<code>display</code>为<code>grid</code>或者<code>inline-grid</code>元素的直接子元素)</p>
<h4 id="布局规则">2.2 布局规则</h4>
<code>普通文档流布局规则</code>：</li>
<li>浮动的元素是不会被父级计算高度的</li>
<li>非浮动元素会覆盖浮动元素的位置</li>
<li>margin会传递给父级</li>
<li><p>两个相邻元素上下margin会发生重叠</p></li>
</ul>
<p><code>BFC布局规则</code>：</p>
<ul>
<li>浮动的元素会被父级计算高度(父级触发了BFC)</li>
<li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)</li>
<li>margin不会传递给父级(父级触发了BFC)</li>
<li><p>两个相邻元素上下margin不会发生重叠(给其中一个元素增加一个父级，并让它的父级触发BFC)</p>
<h4 id="应用">2.3 应用</h4></li>
<li>防止margin重叠</li>
<li>清除内部浮动(原理是父级计算高度时，浮动的子元素也会参与计算)</li>
<li>自适应两栏布局</li>
<li><p>防止元素被浮动元素所覆盖</p>
<h3 id="层叠上下文">3. 层叠上下文</h3>
<p>层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置都是三维的，分别是平面画布上的<code>X轴</code>，<code>Y轴</code>以及表示层叠的<code>Z轴</code>。一般情况下，元素在页面上沿<code>X轴Y轴</code>平铺，我们察觉不到它们在<code>Z轴</code>上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p></li>
</ul>
<p><img src="./images/中高级前端面试秘籍，助你直通大厂(一)1.png" /><br />
如果一个元素含有层叠上下文，我们就可以理解为这个元素在<code>Z轴</code>上就&quot;高人一等&quot;，最终表现就是它离屏幕观察者更近。</p>
<blockquote>
<p>你可以把层叠上下文理解为该元素当了官，而其他非层叠上下文元素则可以理解为普通群众。凡是&quot;当了官的元素&quot;就比普通元素等级要高，也就是说元素在<code>Z轴</code>上更靠上，更靠近观察者。</p>
</blockquote>
<h4 id="触发条件-1">3.1 触发条件</h4>
<ul>
<li>根层叠上下文(<code>&lt;html&gt;</code>)</li>
<li><code>position</code>属性为非<code>static</code>值并设置<code>z-index</code>为具体数值</li>
<li><code>CSS3</code>中的属性也可以产生层叠上下文
<ul>
<li><code>flex</code></li>
<li><code>transform</code></li>
<li><code>opacity</code></li>
<li><code>filter</code></li>
<li><code>will-change</code></li>
<li><p><code>-webkit-overflow-scrolling</code></p>
<h4 id="层叠等级">3.2 层叠等级</h4>
层叠等级(stacking level)，又叫&quot;层叠级别&quot;或者&quot;层叠水平&quot;。</li>
</ul></li>
<li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在<code>Z轴</code>上的上下顺序</li>
<li><p>在其他普通元素中，它描述定义的是这些普通元素在<code>Z轴</code>上的上下顺序</p>
<blockquote>
注意：
<ol>
<li>普通元素的层叠等级优先由其所在的层叠上下文决定。<br />
</li>
<li>层叠等级的比较只有在当前层叠上下文元素中才有意义，不同层叠上下文中比较层叠等级是没有意义的。</li>
</ol>
</blockquote></li>
</ul>
<p><img src="./images/中高级前端面试秘籍，助你直通大厂(一)2.png" /><br />
根据以上的层叠等级图，我们在比较层叠等级时可以按照以下的思路来顺序比较：</p>
<ul>
<li>首先判定两个要比较的元素是否处于同一个层叠上下文中</li>
<li>如果处于同一个层叠上下文中，则谁的层叠等级大，谁最靠上</li>
<li>如果处于不同的层叠上下文中，则先比较他们所处的层叠上下文的层叠等级</li>
<li>当两个元素层叠等级相同，层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上</li>
</ul>
<h3 id="css3中新增的选择器以及属性">4. CSS3中新增的选择器以及属性</h3>
<ul>
<li>属性选择器：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>属性选择器</th>
<th>含义描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E[attr^=&quot;val&quot;]</td>
<td>属性attr的值以&quot;val&quot;<strong>开头</strong>的元素</td>
</tr>
<tr class="even">
<td>E[attr$=&quot;val&quot;]</td>
<td>属性attr的值以&quot;val&quot;<strong>结尾</strong>的元素</td>
</tr>
<tr class="odd">
<td>E[attr*=&quot;val&quot;]</td>
<td>属性attr的值<strong>包含</strong>&quot;val&quot;子字符串的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>结构伪类选择器</li>
</ul>
<table>
<thead>
<tr class="header">
<th>选择器</th>
<th>含义描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E:root</td>
<td>匹配元素所在文档的根元素，对于HTML文档，根元素始终是<code>&lt;html&gt;</code></td>
</tr>
<tr class="even">
<td>E:nth-child(n)</td>
<td>匹配其<strong>父元素的第n个子元素</strong>，第一个编号为1</td>
</tr>
<tr class="odd">
<td>E:nth-last-child(n)</td>
<td>匹配其<strong>父元素的倒数第n个子元素</strong>，第一个编号为1</td>
</tr>
<tr class="even">
<td>E:nth-of-type(n)</td>
<td>与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr class="odd">
<td>E:nth-last-of-type(n)</td>
<td>与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr class="even">
<td>E:last-child</td>
<td>匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>
</tr>
<tr class="odd">
<td>E:first-of-type</td>
<td>匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>
</tr>
<tr class="even">
<td>E:last-of-type</td>
<td>匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>
</tr>
<tr class="odd">
<td>E:only-child</td>
<td>匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>
</tr>
<tr class="even">
<td>E:only-of-type</td>
<td>匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>
</tr>
<tr class="odd">
<td>E:empty</td>
<td>匹配一个不包含任何子元素的元素，文本节点也被看作子元素</td>
</tr>
<tr class="even">
<td>E:not(selector)</td>
<td>匹配不符合当前选择器的任何元素</td>
</tr>
</tbody>
</table>
<ul>
<li>CSS3新增属性</li>
</ul>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>含义描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>transition</td>
<td>过渡效果</td>
</tr>
<tr class="even">
<td>transform</td>
<td>变换效果(移动(translate)、缩放(scale)、旋转(rotate)、倾斜(skew))</td>
</tr>
<tr class="odd">
<td>transform-origin</td>
<td>设置旋转元素的基点位置</td>
</tr>
<tr class="even">
<td>animation</td>
<td>动画效果</td>
</tr>
<tr class="odd">
<td>border-color</td>
<td>为边框设置多种颜色</td>
</tr>
<tr class="even">
<td>border-radius</td>
<td>圆角边框</td>
</tr>
<tr class="odd">
<td>box-shadow</td>
<td>边框阴影</td>
</tr>
<tr class="even">
<td>border-image</td>
<td>边框图片</td>
</tr>
<tr class="odd">
<td>background-size</td>
<td>规定背景图片的尺寸</td>
</tr>
<tr class="even">
<td>background-origin</td>
<td>规定背景图片的定位区域</td>
</tr>
<tr class="odd">
<td>background-clip</td>
<td>规定背景图片从什么位置开始裁切</td>
</tr>
<tr class="even">
<td>text-shadow</td>
<td>文本阴影</td>
</tr>
<tr class="odd">
<td>text-overflow</td>
<td>文本截断</td>
</tr>
<tr class="even">
<td>word-wrap</td>
<td>对长单词进行拆分，并换行到下一行</td>
</tr>
<tr class="odd">
<td>opacity</td>
<td>不透明度</td>
</tr>
<tr class="even">
<td>box-sizing</td>
<td>控制盒模型的组成模式</td>
</tr>
<tr class="odd">
<td>rgba</td>
<td>基于r,g,b三个颜色通道来设置颜色值，通过a来设置透明度</td>
</tr>
</tbody>
</table>
<h3 id="css3中transition和animation的属性">5. CSS3中transition和animation的属性</h3>
<p>1) <code>transition(过渡动画)</code></p>
<p>用法：<code>transition: property duration timing-function delay</code><br />
| 属性 | 含义描述 |<br />
| ---- | ---- |<br />
| transition-property | 指定哪个<strong>CSS属性</strong>需要应用到transition效果 |<br />
| transition-duration | 指定transition效果的<strong>持续时间</strong> |<br />
| transition-timing-function | 指定transition效果的<strong>速度曲线</strong> |<br />
| transition-delay | 指定transition效果的<strong>延迟时间</strong> |</p>
<p>2) <code>animation(关键帧动画)</code></p>
<p>用法：<code>animation: name duration timing-function delay iteration-count direction fill-mode play-state</code><br />
| 属性 | 含义描述 |<br />
| ---- | ---- |<br />
| animation-name | 指定要<strong>绑定到选择器的关键帧的名称</strong> |<br />
| animation-duration | 指定动画的<strong>持续时间</strong> |<br />
| animation-timing-function | 指定动画的<strong>速度曲线</strong> |<br />
| animation-delay | 指定动画的<strong>延迟时间</strong> |<br />
| animation-iteration-count | 指定动画的<strong>播放次数</strong> |<br />
| animation-direction | 指定是否应该<strong>轮流反向播放动画</strong> |<br />
| animation-fill-mode | 规定当动画<strong>不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</strong> |<br />
| animation-play-state | 指定动画<strong>是否正在运行或已暂停</strong> |</p>
<h3 id="清除浮动的方式以及各自的优缺点">6. 清除浮动的方式以及各自的优缺点</h3>
<ul>
<li><p>额外标签法(在最后一个浮动元素的后面新加一个标签如<code>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</code>，并在其CSS样式中设置clear: both;)</p>
<blockquote>
<p>优点：简单，通俗易懂，写少量代码，兼容性好<br />
缺点：额外增加无语义html元素，代码语义化差，后期维护成本大</p>
</blockquote></li>
<li><p>给父级设置高度</p>
<blockquote>
<p>优点：简单，写少量代码，容易掌握<br />
缺点：不够灵活，只适用于高度固定的布局</p>
</blockquote></li>
<li><p>触发父级BFC(如给父元素设置<code>overflow:hidden</code>，特别注意的是：在IE6中还需要触发hasLayout，例如给父元素设置<code>zoom:1</code>。原理是触发父级BFC后，父元素在计算高度时，浮动的子元素也会参与计算)</p>
<blockquote>
<p>优点：简单，代码简洁<br />
缺点：设置<code>overflow:hidden</code>容易造成不会自动换行导致超出的尺寸被隐藏掉，无法显示要溢出的元素</p>
</blockquote></li>
<li>使用after伪元素，常见的写法如下：</li>
</ul>
<pre><code><code> .clearfix::after {
    content: &quot;.&quot;;
    display: block;
    height: 0;
    line-height: 0;
    clear: both;
    visibility:hidden;
    font-size: 0;
 }
 
 .clearfix {
    // 注意此处是为了兼容IE6和IE7浏览器，即触发hasLayout
    zoom: 1;
 }</code></pre>
<blockquote>
<p>优点：符合闭合浮动思想，结构语义化正确<br />
缺点：代码量多，因为IE6-7下不支持after伪元素，需要额外写<code>zoom:1</code>来触发hasLayout</p>
</blockquote>
<h3 id="居中布局的方式">7. 居中布局的方式</h3>
<p><code>水平居中</code>：</p>
<ul>
<li>若是行内元素，则直接给其父元素设置<code>text-align: center</code>即可</li>
<li>若是块级元素，则直接给该元素设置<code>margin: 0 auto</code>即可</li>
<li>若子元素包含浮动元素，则给父元素设置<code>width:fit-content</code>并且配合<code>margin</code></li>
</ul>
<pre><code><code>.parent {
    width: -webkit-fit-content;
    width: -moz-fit-content;
    width: fit-content;
    margin: 0 auto;
}</code></pre>
<ul>
<li>使用flex布局的方式，可以轻松实现水平居中，即使子元素中存在浮动元素也同样适用</li>
</ul>
<pre><code><code>// flex 2012年版本写法
.parent {
    display: flex;
    flex-direction: row;
    justify-content: center;
}

// flex 2009年版本写法
.parent {
    display: box;
    box-orient: horizontal;
    box-pack: center;
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合CSS3新增的<code>transform</code>属性</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    left: 50%;
    transform: translate(-50%, 0);
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合负值的<code>margin-left</code>(<strong>此方法需要固定宽度</strong>)</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    left: 50%;
    width: 200px; // 假定宽度为200px
    margin-left: -100px; // 负值的绝对值为宽度的一半
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合<code>left:0;right:0;margin:0 auto;</code>(<strong>此方法需要固定宽度</strong>)</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    left: 0;
    right: 0;
    margin: 0 auto;
    width: 200px; // 假定宽度为200px
}</code></pre>
<p><code>垂直居中</code>：</p>
<ul>
<li>若元素是单行文本，则直接给该元素设置<code>line-height</code>等于其父元素的高度</li>
<li>若元素是行内块级元素，可以配合使用<code>display:inline-block;vertical-align:middle</code>和一个伪元素来让内容块居中</li>
</ul>
<pre><code><code>.parent::after, .child {
    display: inline-block;
    vertical-align: middle;
}

.parent::after {
    content: &quot;&quot;;
    height: 100%;
}</code></pre>
<ul>
<li>使用<code>vertical-align</code>属性并且配合使用<code>display:table</code>和<code>display:table-cell</code>来让内容块居中</li>
</ul>
<pre><code><code>.parent {
    display: table;
}

.child {
    display: table-cell;
    vertical-align: middle;
}</code></pre>
<ul>
<li>使用flex布局的方式，可以轻松实现垂直居中，即使子元素中存在浮动元素也同样适用</li>
</ul>
<pre><code><code>// flex 2012年版本写法
.parent {
    display: flex;
    align-items: center;
}

// flex 2009年版本写法
.parent {
    display: box;
    box-orient: vertical;
    box-pack: center;
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合CSS3新增的transform属性</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    top: 50%;
    transform: translate(0, -50%);
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合负值的<code>margin-top</code>(<strong>此方法需要固定高度</strong>)</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    top: 50%;
    height: 200px; // 假定高度为200px
    margin-top: -100px; // 负值的绝对值为高度的一半
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合<code>top:0;bottom:0;margin:auto 0;</code>(<strong>此方法需要固定高度</strong>)</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    top: 0;
    bottom: 0;
    margin: auto 0;
    height: 200px; // 假定高度为200px
}</code></pre>
<p><code>水平垂直居中</code>：</p>
<ul>
<li>使用flex布局的方式同样可以轻松实现水平垂直居中</li>
</ul>
<pre><code><code>// flex 2012年版本写法
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}

// flex 2009年版本写法
.parent {
    display: box;
    box-pack: center;
    box-align: center;
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合CSS3新增的<code>transform</code>属性</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}</code></pre>
<ul>
<li>使用绝对定位的方式，再配合使用负值的<code>margin-top</code>和负值的<code>margin-left</code>(<strong>此方法需要同时固定宽度和高度</strong>)</li>
</ul>
<pre><code><code>.child {
    position: absolute;
    left: 50%;
    top: 50%;
    margin-top: -50px; // 负值的绝对值为高度的一半
    margin-left: -100px; // 负值的绝对值为宽度的一半
    width: 200px; // 假定宽度为200px
    height: 100px; // 假定高度为100px
}</code></pre>
<h3 id="css的优先级和权重">8. CSS的优先级和权重</h3>
<table>
<thead>
<tr class="header">
<th>选择器(优先级从高到低)</th>
<th>示例</th>
<th>特殊性值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>!important(重要性标识)</td>
<td><code>div { color: #fff !important; }</code></td>
<td>无，但为了方便记忆，可将其表示为1,0,0,0,0</td>
</tr>
<tr class="even">
<td>行内样式</td>
<td><code>&lt;div style=&quot;color: #fff;&quot;&gt;&lt;/div&gt;</code></td>
<td>1,0,0,0</td>
</tr>
<tr class="odd">
<td>id选择器</td>
<td><code>#id</code></td>
<td>0,1,0,0</td>
</tr>
<tr class="even">
<td>类，伪类和属性选择器</td>
<td><code>.content, :first-child, [type=&quot;text&quot;]</code></td>
<td>0,0,1,0</td>
</tr>
<tr class="odd">
<td>标签和伪元素选择器</td>
<td><code>h1, ::after</code></td>
<td>0,0,0,1</td>
</tr>
<tr class="even">
<td>通配符、子选择器、相邻选择器</td>
<td><code>*, div &gt; p, p + p</code></td>
<td>0,0,0,0</td>
</tr>
<tr class="odd">
<td>继承</td>
<td><code>span { color: inherit; }</code></td>
<td>无</td>
</tr>
<tr class="even">
<td>浏览器默认值</td>
<td>浏览器开发者工具右侧的<code>Styles</code>面板中会显示<code>user agent stylesheet</code>字样</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="移动端1px物理像素边框">9. 移动端1px物理像素边框</h3>
<p>我们知道，在移动端存在<code>物理像素(physical pixel)</code>和<code>设备独立像素(density-independent pixel)</code>的概念。物理像素也称为设备像素，它是显示设备中一个最微小的物理部件，每个像素可以根据操作系统设置自己的颜色和亮度。设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如CSS像素)，然后由相关系统转换为物理像素。根据物理像素和设备独立像素也衍生出了<code>设备像素比(device pixel ratio)</code>的概念，简称为<code>dpr</code>，其定义了物理像素和设备独立像素的对应关系，其计算公式为<code>设备像素比 = 物理像素 / 设备独立像素</code>。因为视网膜(Retina)屏幕的出现，使得一个物理像素并不能和一个设备独立像素完全对等，如下图所示：<br />
<img src="./images/中高级前端面试秘籍，助你直通大厂(一)3.png" /><br />
在上图中，在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素却对应4个物理像素，即在Retina屏幕下会有不同的<code>dpr</code>值。为了追求在移动端网页中更好的显示质量，因此我们需要做各种各样的适配处理，最经典的莫过于1px物理像素边框问题，我们需要根据移动端不同的<code>dpr</code>值来对边框进行处理。在JavaScript中，可以通过<code>window.devicePixelRatio</code>来获取当前设备的<code>dpr</code>，在CSS中，可以通过<code>-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和-webkit-max-device-pixel-ratio</code>来进行媒体查询，从而针对不同的设备，来做一些样式适配。这里对于1px像素的边框问题，给出一种最常见的写法：</p>
<pre><code><code>.border-1px {
    position: relative;
}

.border-1px::after {
    content: &quot;&quot;;
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background-color: #000;
    -webkit-transform: scaleY(.5);
    transform: scaleY(.5);
}

@media only screen and (-webkit-min-device-pixel-ratio: 2.0), (min-device-pixel-ratio: 2.0) {
    .border-1px::after {
        -webkit-transform: scaleY(.5);
        transform: scaleY(.5);
    }
}

@media only screen and (-webkit-min-device-pixel-ratio: 3.0), (min-device-pixel-ratio: 3.0) {
    .border-1px::after {
        -webkit-transform: scaleY(.33);
        transform: scaleY(.33);
    }
}</code></pre>
<h3 id="实现三栏布局的方式有哪些">10. 实现三栏布局的方式有哪些</h3>
<p>三栏布局，顾名思义就是分为左中右三个模块进行布局，并且左右两边固定，中间模块根据浏览器的窗口变化进行自适应，效果图如下：<br />
<img src="./images/中高级前端面试秘籍，助你直通大厂(一)4.png" /><br />
这里给出四种实现三栏布局的方式：</p>
<ul>
<li>使用绝对定位的方式</li>
</ul>
<pre><code><code>.container {
    position: relative;
    height: 200px;
    line-height: 200px;
    text-align: center;
    font-size: 20px;
    color: #fff;
}

.left {
    position: absolute;
    left: 0;
    top: 0;
    width: 150px;
    background: red;
}

.main {
    margin-left: 160px;
    margin-right: 110px;
    background: green;
}

.right {
    position: absolute;
    right: 0;
    top: 0;
    width: 100px;
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;中&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;
&lt;/div&gt;</code></pre>
<blockquote>
<p>优点：方便快捷，简单实用，不容易出现问题，而且还可以将<code>&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</code>元素放到最前面，使得主要内容被优先加载。<br />
缺点：元素脱离了文档流，可能会造成元素的重叠。</p>
</blockquote>
<ul>
<li>使用flex布局的方式</li>
</ul>
<pre><code><code>.container {
    display: flex;      
    height: 200px;
    line-height: 200px;
    text-align: center;
    font-size: 20px;
    color: #fff;
}

.left {
    width: 150px;
    background: red;
}

.main {
    margin: 0 10px;
    flex: 1;
    background: green;
}

.right {
    width: 100px;
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;中&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;
&lt;/div&gt;</code></pre>
<blockquote>
<p>优点：简单实用，是现在比较流行的方案，特别是在移动端，大多数布局都采用的这种方式，是目前比较完美的一个。<br />
缺点：需要考虑到浏览器的兼容性，根据不同的浏览器厂商需要添加相应的前缀。</p>
</blockquote>
<ul>
<li>双飞翼布局</li>
</ul>
<pre><code><code>.content {
    float: left;
    width: 100%;
}

.main,
.left,
.right {
    height: 200px;
    line-height: 200px;
    text-align: center;
    font-size: 20px;
    color: #fff;
}

.main {
    margin-left: 160px;
    margin-right: 110px;
    background: green;
}

.left {
    float: left;
    margin-left: -100%;
    width: 150px;
    background: red;
}

.right {
    float: right;
    margin-left: -100px;
    width: 100px;
    background: blue;
}

&lt;div class=&quot;content&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;中&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;</code></pre>
<blockquote>
<p>优点：比较经典的一种方式，通用性强，没有兼容性问题，而且支持主要内容优先加载。<br />
缺点：元素脱离了文档流，要注意清除浮动，防止高度塌陷，同时额外增加了一层DOM结构，即增加了渲染树生成的计算量。</p>
</blockquote>
<ul>
<li>圣杯布局</li>
</ul>
<pre><code><code>.container {
    margin-left: 160px;
    margin-right: 110px;
}

.left,
.main,
.right {
    height: 200px;
    line-height: 200px;
    text-align: center;
    font-size: 20px;
    color: #fff;    
}

.main {
    float: left;
    width: 100%;
    background: green;      
}

.left {
    position: relative;
    left: -160px;
    margin-left:  -100%;
    float: left;
    width: 150px;
    background: red;
}

.right {
    position: relative;
    right: -110px;
    margin-left:  -100px;
    float: left;
    width: 100px;
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;中&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;
&lt;/div&gt;</code></pre>
<blockquote>
<p>优点：相比于双飞翼布局，结构更加简单，没有多余的DOM结构层，同样支持主要内容优先加载。<br />
缺点：元素同样脱离了文档流，要注意清除浮动，防止高度塌陷。</p>
</blockquote>
<h3 id="实现等高布局的方式有哪些">11. 实现等高布局的方式有哪些</h3>
<p>等高布局，顾名思义就是在同一个父容器中，子元素高度相等的布局。从等高布局的实现方式来说，可以分为两种，分别是<code>伪等高</code>和<code>真等高</code>。<strong>伪等高是指子元素的高度差依然存在，只是视觉上给人的感觉就是等高，真等高是指子元素的高度真实相等</strong>。效果图如下：<br />
<img src="./images/中高级前端面试秘籍，助你直通大厂(一)5.png" /><br />
这里给出五种实现等高布局的方式：</p>
<p><code>伪等高</code>：</p>
<ul>
<li>使用<code>padding-bottom</code>和负的<code>margin-bottom</code>来实现</li>
</ul>
<pre><code><code>.container {
    position: relative;
    overflow: hidden;
}
    
.left,
.main,
.right {
    padding-bottom: 100%;
    margin-bottom: -100%;
    float: left;
    color: #fff;
}

.left {
    width: 20%;
    background: red;
}

.main {
    width: 60%;
    background: green;
}

.right {
    width: 20%;
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;左侧内容&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p><code>真等高</code>：</p>
<ul>
<li>使用flex布局的方式</li>
</ul>
<pre><code><code>.container {
    display: flex;
}

.left,
.main,
.right {
    flex: 1;
    color: #fff;
}

.left {
    background: red;
}

.main {
    background: green;
}

.right {
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;左侧内容&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>使用绝对定位的方式</li>
</ul>
<pre><code><code>.container {
  position: relative;
  height: 200px;
}

.left,
.main,
.right {
    position: absolute;
    top: 0;
    bottom: 0;
    color: #fff;
}

.left {
    left: 0;
    width: 20%;
    background: red;
}

.main {
    left: 20%;
    right: 20%;
    background: green;
}

.right {
    right: 0;
    width: 20%;
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;左侧内容&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>使用table布局的方式</li>
</ul>
<pre><code><code>.container {
    width: 100%;
    display: table;
}

.left,
.main,
.right {
    display: table-cell;
    color: #fff;
}

.left {
    width: 20%;
    background: red;
}

.main {
    width: 60%;
    background: green;
}

.right {
    width: 20%;
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;左侧内容&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>使用grid网格布局的方式</li>
</ul>
<pre><code><code>.container {
    display: grid;
    width: 100%;
    grid-template-columns: 1fr 1fr 1fr;
    color: #fff;
}

.left {
    background: red;
}

.main {
    background: green;
}

.right {
    background: blue;
}

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;左侧内容&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
        &lt;p&gt;中间内容&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;
&lt;/div&gt;</code></pre>
<h3 id="css实现三角形的原理">12. CSS实现三角形的原理</h3>
<p>工作中我们经常会遇到需要三角形图标的应用场景，例如内容展开收起、左右箭头点击切换轮播，点击某条列表数据查看详情等。三角形图标的应用范围之广，使得我们有必要了解一下它的实现原理。<br />
1) 首先我们来实现一个最基础的边框效果</p>
<pre><code><code>.content {
    width: 50px;
    height: 50px;
    border: 2px solid;
    border-color:#ff9600 #3366ff #12ad2a #f0eb7a;
}</code></pre>
<p>效果如下：</p>
<p><img src="./images/中高级前端面试秘籍，助你直通大厂(一)6.png" /></p>
<p>2) 然后我们尝试将border值放大10倍</p>
<pre><code><code>.content {
    width: 50px;
    height: 50px;
    border: 20px solid;
    border-color: #ff9600 #3366ff #12ad2a #f0eb7a;
}</code></pre>
<p>效果如下：<br />
<img src="./images/中高级前端面试秘籍，助你直通大厂(一)7.png" /><br />
上图中我们可以很清楚地看到，在绘制border的时候并不是矩形区域，而是梯形区域，那么此时如果我们将<code>width</code>和<code>height</code>值设置为0，看会发生什么：</p>
<pre><code><code>.content {
    width: 0;
    height: 0;
    border: 20px solid;
    border-color: #ff9600 #3366ff #12ad2a #f0eb7a;
}</code></pre>
<p>效果如下：<br />
<img src="./images/中高级前端面试秘籍，助你直通大厂(一)8.png" /><br />
此时会看到一个由四个三角形拼装而成的矩形区域，即由上下左右四个边框组合而成。因此不难想象，如果我们想得到某一个方向的三角形，我们只需要让其他方向的边框不可见就行了，例如我们想得到一个朝左的三角形：</p>
<pre><code><code>.content {
    width: 0;
    height: 0;
    border: 20px solid;
    border-color: transparent #3366ff transparent transparent;
}</code></pre>
<p>效果如下:<br />
<img src="./images/中高级前端面试秘籍，助你直通大厂(一)9.png" /><br />
这样就得到了一个很完美的三角形图标，是不是很简单？</p>
<h3 id="link与import的区别">13. link与@import的区别</h3>
<ul>
<li><p>从属关系区别</p>
<blockquote>
<p>@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS，Rel连接属性，设置浏览器资源提示符preload、prefetch等。</p>
</blockquote></li>
<li><p>加载顺序区别</p>
<blockquote>
<p>HTML文档在解析的过程当中，如果遇到<code>link</code>标签，则会立即发起获取CSS文件资源的请求；@import引入的CSS将在页面加载完毕后才会被加载。</p>
</blockquote></li>
<li><p>兼容性区别</p>
<blockquote>
<p>@import是CSS2.1才有的语法，因此需要IE5以上才能识别；link标签作为HTML元素，不存在兼容性问题。</p>
</blockquote></li>
<li><p>DOM可控性区别</p>
<blockquote>
<p>link标签可以通过JS来动态引入，而@import无法通过JS来插入样式</p>
</blockquote></li>
</ul>
<pre class="javascript"><code>const loadStyle = (url) =&gt; {
    const link = document.createElement(&#39;link&#39;);
    link.setAttribute(&#39;type&#39;, &#39;text/css&#39;);
    link.setAttribute(&#39;rel&#39;, &#39;stylesheet&#39;);
    link.setAttribute(&#39;href&#39;, url);
    
    document.head.appendChild(link);
}</code></pre>
<h3 id="浏览器是怎样解析css选择器的">14. 浏览器是怎样解析CSS选择器的</h3>
<p><strong>CSS选择器的解析是从右向左解析的</strong>。若从左向右地匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点(叶子节点)，而从左向右的匹配规则的性能都浪费在了失败的查找上面。而在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立Render Tree时浏览器就要为每个DOM Tree中的元素根据CSS的解析结果(Style Rules)来确定生成怎样的Render Tree。</p>
<h3 id="css的性能优化方案">15. CSS的性能优化方案</h3>
<ul>
<li>层级尽量扁平，避免嵌套过多层级的选择器；</li>
<li>使用特定的选择器，避免解析器过多层级的查找；</li>
<li>减少使用通配符与属性选择器；</li>
<li>减少不必要的多余属性；</li>
<li>避免使用<code>!important</code>标识，可以选择其他选择器；</li>
<li>实现动画时优先使用CSS3的动画属性，动画时脱离文档流，开启硬件加速；</li>
<li>使用<code>link</code>标签代替@import；</li>
<li>将渲染首屏内容所需的关键CSS内联到HTML中；</li>
<li>使用资源预加载指令<code>preload</code>让浏览器提前加载CSS资源并缓存；</li>
<li>使用Gulp，Webpack等构建工具对CSS文件进行压缩处理；</li>
</ul>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://juejin.im/post/5db556376fb9a0207a6ddce7">记一次大厂的面试过程</a><br />
<a href="https://juejin.im/post/5dc26364f265da4d0e00a8af">装饰你的敲门砖，离大厂更近一步</a></p>
<h2 id="交流">交流</h2>
<p>终于接近尾声了，居然花费掉了我一整个周末的时间，不过这篇主要是先总结一下CSS相关的知识点，当然还有很多地方没有总结到，只是列出了个人觉得比较容易考察的点，如果你有其他补充的，欢迎在下方留言区讨论哦，也欢迎关注我的<strong>公众号[前端之境]</strong>，关注后我可以拉你加入微信前端交流群，我们一起互相交流学习，共同进步。<br />
后续会陆续总结出<strong>JS方面、浏览器视角、算法基础和框架方面</strong>的内容，希望你能够喜欢！</p>
<p><strong>文章已同步更新至<a href="https://github.com/qq591468061/xwfe">Github博客</a>，若觉文章尚可，欢迎前往star！</strong></p>
<p><strong>你的一个点赞，值得让我付出更多的努力！</strong></p>
<p><strong>逆境中成长，只有不断地学习，才能成为更好的自己，与君共勉！</strong></p>
<p><img src="./images/中高级前端面试秘籍，助你直通大厂(一)10.png" /></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>