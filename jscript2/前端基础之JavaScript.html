<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修前端基础之JavaScript' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>前端基础之JavaScript</center></div><div class='banquan'>原文出处:本文由博客园博主与鹿逐秋提供。<br/>
原文连接:https://www.cnblogs.com/wangyueping/p/11200342.html</div><br>
    <h1 id="前端基础之javascript">前端基础之JavaScript</h1>
<h2 id="一javascript概述">一、JavaScript概述</h2>
<ol>
<li><p>ECMAScript和JavaScript的关系</p>
<p>1996年11月，JavaScript的创造者--Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这门语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p>
<p>该标准一开始就是针对JavaScript语言制定的，但是没有称其为JavaScript，有两个方面的原因。一是商标，JavaScript本身已被Netscape注册为商标。二是想体现这门语言的制定者是ECMA，而不是Netscape，这样有利于保证这门语言的开发性和中立性。</p>
<p>因此ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。</p></li>
<li><p>ECMAScript的历史</p>
<table>
<thead>
<tr class="header">
<th>年份</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1997</td>
<td>ECMAScript 1</td>
<td>第一个版本</td>
</tr>
<tr class="even">
<td>1998</td>
<td>ECMAScript 2</td>
<td>版本变更</td>
</tr>
<tr class="odd">
<td>1999</td>
<td>ECMAScript 3</td>
<td>添加正则表达式添加try/catch</td>
</tr>
<tr class="even">
<td></td>
<td>ECMAScript 4</td>
<td>没有发布</td>
</tr>
<tr class="odd">
<td>2009</td>
<td>ECMAScript 5</td>
<td>添加&quot;strict mode&quot;严格模式添加JSON支持</td>
</tr>
<tr class="even">
<td>2011</td>
<td>ECMAScript 5.1</td>
<td>版本变更</td>
</tr>
<tr class="odd">
<td>2015</td>
<td>ECMAScript 6</td>
<td>添加类和模块</td>
</tr>
<tr class="even">
<td>2016</td>
<td>ECMAScript 7</td>
<td>增加指数运算符（**）增加Array.prototype.includes</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><em>注：ES6就是指ECMAScript 6。</em></p>
<p>尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：</p>
<ul>
<li>核心（ECMAScript）</li>
<li>文档对象模型（DOM） Document object model (整合js，css，html)</li>
<li>浏览器对象模型（BOM） Broswer object model（整合js和浏览器）</li>
</ul>
<p>简单地说，ECMAScript 描述了JavaScript语言本身的相关内容。</p>
<p>JavaScript 是脚本语言<br />
JavaScript 是一种轻量级的编程语言。</p>
<p>JavaScript 是可插入 HTML 页面的编程代码。</p>
<p>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p>
<p><del>JavaScript 很容易学习。</del></p>
<p><br></p></li>
</ol>
<h2 id="二javascript的引入方式">二、JavaScript的引入方式</h2>
<ol>
<li><p>Script标签内写代码</p>
<pre><code><code>&lt;script&gt;
  // 在这里写你的JS代码
&lt;/script&gt;</code></pre></li>
<li><p>引入额外的JS文件</p>
<pre><code><code>&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></pre>
<p><br></p></li>
</ol>
<h2 id="三javascript语言规范">三、JavaScript语言规范</h2>
<ol>
<li><p>注释（注释是代码之母）</p>
<pre><code><code>// 这是单行注释

/*
这是
多行注释
*/</code></pre></li>
<li><p>结束符</p>
<p>JavaScript中的语句要以分号（;）为结束符。</p>
<p><br></p></li>
</ol>
<h2 id="四javascript语言基础">四、JavaScript语言基础</h2>
<ol>
<li><p>变量声明</p>
<ul>
<li>JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头</li>
<li>声明变量使用 var 变量名; 的格式来进行声明</li>
</ul>
<p>注意：</p>
<p>变量名是区分大小写的。</p>
<p>推荐使用驼峰式命名规则。</p>
<p>保留字不能用做变量名。</p>
<p><em>补充：</em></p>
<p><em>ES6新增了let命令，用于声明变量。其用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。例如：for循环的计数器就很适合使用let命令。</em></p>
<pre><code><code>for (let i=0;i&lt;arr.length;i++){...}</code></pre>
<p><em>ES6新增const用来声明常量。一旦声明，其值就不能改变。</em></p>
<pre><code><code>const PI = 3.1415;
PI // 3.1415

PI = 3
// TypeError: &quot;PI&quot; is read-only</code></pre>
<p><br></p></li>
</ol>
<h2 id="五javascript数据类型">五、JavaScript数据类型</h2>
<p><strong>JavaScript拥有动态类型</strong></p>
<pre><code><code>var x;  // 此时x是undefined
var x = 1;  // 此时x是数字
var x = &quot;dogfa&quot;  // 此时x是字符串 </code></pre>
<ol>
<li><p>数值(Number)</p>
<p>JavaScript不区分整型和浮点型，就只有一种数字类型。</p>
<pre><code><code>var a = 12.34;
var b = 20;
var c = 123e5;  // 12300000
var d = 123e-5;  // 0.00123</code></pre>
<p>还有一种NaN，表示不是一个数字（Not a Number）。</p>
<p>常用方法：</p>
<pre><code><code>parseInt(&quot;123&quot;)  // 返回123
parseInt(&quot;ABC&quot;)  // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。
parseFloat(&quot;123.456&quot;)  // 返回123.456</code></pre></li>
<li><p>字符串(String)</p>
<pre><code><code>var a = &quot;Hello&quot;
var b = &quot;world;
var c = a + b; 
console.log(c);  // 得到Helloworld</code></pre>
<p>常用方法：</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.length</td>
<td>返回长度</td>
</tr>
<tr class="even">
<td>.trim()</td>
<td>移除空白</td>
</tr>
<tr class="odd">
<td>.trimLeft()</td>
<td>移除左边的空白</td>
</tr>
<tr class="even">
<td>.trimRight()</td>
<td>移除右边的空白</td>
</tr>
<tr class="odd">
<td>.charAt(n)</td>
<td>返回第n个字符</td>
</tr>
<tr class="even">
<td>.concat(value, ...)</td>
<td>拼接</td>
</tr>
<tr class="odd">
<td>.indexOf(substring, start)</td>
<td>子序列位置</td>
</tr>
<tr class="even">
<td>.substring(from, to)</td>
<td>根据索引获取子序列</td>
</tr>
<tr class="odd">
<td>.slice(start, end)</td>
<td>切片</td>
</tr>
<tr class="even">
<td>.toLowerCase()</td>
<td>小写</td>
</tr>
<tr class="odd">
<td>.toUpperCase()</td>
<td>大写</td>
</tr>
<tr class="even">
<td>.split(delimiter, limit)</td>
<td>分割</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>slice和substring的区别：</strong></p>
<p>string.slice(start, stop)和string.substring(start, stop)：</p>
<p>两者的相同点：<br />
如果start等于end，返回空字符串<br />
如果stop参数省略，则取到字符串末<br />
如果某个参数超过string的长度，这个参数会被替换为string的长度</p>
<p>substirng()的特点：<br />
如果 start &gt; stop ，start和stop将被交换<br />
如果参数是负数或者不是数字，将会被0替换</p>
<p>silce()的特点：<br />
如果 start &gt; stop 不会交换两者<br />
如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符)<br />
如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符)</p>
<p><br></p>
<p><em>补充：</em></p>
<p><em>ES6中引入了模板字符串。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</em></p>
<pre><code><code>// 普通字符串
`这是普通字符串！`
// 多行文本
`这是多行的
文本`
// 字符串中嵌入变量
var name = &quot;djb&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`</code></pre>
<p><em>注意：</em></p>
<p><em>如果模板字符串中需要使用反引号，则在其前面要用反斜杠转义。</em></p>
<p><em>JSHint启用ES6语法支持:/* jshint esversion: 6 */</em></p>
<p><br></p></li>
<li><p>布尔值(Boolean)</p>
<p>区别于Python，true和false都是小写。</p>
<pre><code><code>var a = true;
var b = false;</code></pre>
<p>&quot;&quot;(空字符串)、0、null、undefined、NaN都是false。</p>
<p><br></p></li>
<li><p>null和undefined</p>
<ul>
<li>null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null;</li>
<li>undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined</li>
</ul>
<p>null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值。</p>
<p><br></p></li>
<li><p>对象(Object)</p>
<p>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数...此外，JavaScript 允许自定义对象。</p>
<p>JavaScript 提供多个内建对象，比如 String、Date、Array 等等。</p>
<p>对象只是带有属性和方法的特殊数据类型</p>
<p><br></p>
<p><strong>数组</strong></p>
<p>数组对象的作用是：使用单独的变量名来存储一系列的值。类似于Python中的列表。</p>
<pre><code><code>var a = [123, &quot;ABC&quot;];
console.log(a[1]);  // 输出&quot;ABC&quot;</code></pre>
<p>常用方法：</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.length</td>
<td>数组的大小</td>
</tr>
<tr class="even">
<td>.push(ele)</td>
<td>尾部追加元素</td>
</tr>
<tr class="odd">
<td>.pop()</td>
<td>获取尾部的元素</td>
</tr>
<tr class="even">
<td>.unshift(ele)</td>
<td>头部插入元素</td>
</tr>
<tr class="odd">
<td>.shift()</td>
<td>头部移除元素</td>
</tr>
<tr class="even">
<td>.slice(start, end)</td>
<td>切片</td>
</tr>
<tr class="odd">
<td>.reverse()</td>
<td>反转</td>
</tr>
<tr class="even">
<td>.join(seq)</td>
<td>将数组元素连接成字符串</td>
</tr>
<tr class="odd">
<td>.concat(val, ...)</td>
<td>连接数组</td>
</tr>
<tr class="even">
<td>.sort()</td>
<td>排序</td>
</tr>
<tr class="odd">
<td>.forEach()</td>
<td>将数组的每个元素传递给回调函数</td>
</tr>
<tr class="even">
<td>.splice()</td>
<td>删除元素，并向数组添加新元素。</td>
</tr>
<tr class="odd">
<td>.map()</td>
<td>返回一个数组元素调用函数处理后的值的新数组</td>
</tr>
</tbody>
</table>
<p>关于sort()需要注意：</p>
<p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>
<p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br />
若 a 等于 b，则返回 0。<br />
若 a 大于 b，则返回一个大于 0 的值。</p>
<p>示例：</p>
<pre><code><code>function sortNumber(a,b){
    return a - b
}
var arr1 = [11, 100, 22, 55, 33, 44]
arr1.sort(sortNumber)</code></pre>
<p>关于遍历数组中的元素，可以使用下面的方式：</p>
<pre><code><code>var a = [10, 20, 30, 40];
for (var i=0;i&lt;a.length;i++) {
  console.log(a[i]);
}</code></pre>
<p><br></p></li>
<li><p>splice()</p>
<p><strong>语法：</strong></p>
<p>splice(index,howmany,item1,.....,itemX)</p>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>index</em></td>
<td>必需。规定从何处添加/删除元素。 该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</td>
</tr>
<tr class="even">
<td><em>howmany</em></td>
<td>必需。规定应该删除多少元素。必须是数字，但可以是 &quot;0&quot;。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td>
</tr>
<tr class="odd">
<td><em>item1</em>, ..., <em>itemX</em></td>
<td>可选。要添加到数组的新元素</td>
</tr>
</tbody>
</table>
<p><br></p></li>
<li><p>map()</p>
<p><strong>语法：</strong></p>
<p>map(function(currentValue,index,arr), thisValue)</p>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>function(currentValue, index,arr)</em></td>
<td>必须。函数，数组中的每个元素都会执行这个函数</td>
</tr>
<tr class="even">
<td><em>thisValue</em></td>
<td>可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值。 如果省略了 thisValue ，&quot;this&quot; 的值为 &quot;undefined&quot;</td>
</tr>
</tbody>
</table>
<p><em>function(currentValue, index,arr)</em></p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>currentValue</em></td>
<td>必须。当前元素的值</td>
</tr>
<tr class="even">
<td><em>index</em></td>
<td>可选。当期元素的索引值</td>
</tr>
<tr class="odd">
<td><em>arr</em></td>
<td>可选。当期元素属于的数组对象</td>
</tr>
</tbody>
</table>
<p><br></p></li>
<li><p>forEach()</p>
<p><strong>语法：</strong></p>
<p>forEach(function(currentValue, index, arr), thisValue)</p>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>function(currentValue, index, arr)</em></td>
<td>必需。 数组中每个元素需要调用的函数。</td>
</tr>
<tr class="even">
<td><em>thisValue</em></td>
<td>可选。传递给函数的值一般用 &quot;this&quot; 值。 如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值</td>
</tr>
</tbody>
</table>
<p><em>function(currentValue, index, arr)</em></p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>currentValue</em></td>
<td>必需。当前元素</td>
</tr>
<tr class="even">
<td><em>index</em></td>
<td>可选。当前元素的索引值。</td>
</tr>
<tr class="odd">
<td><em>arr</em></td>
<td>可选。当前元素所属的数组对象。</td>
</tr>
</tbody>
</table>
<p><br></p></li>
<li><p>类型查询</p>
<pre><code><code>typeof &quot;abc&quot;  // &quot;string&quot;
typeof null  // &quot;object&quot;
typeof true  // &quot;boolean&quot;
typeof 123 // &quot;number&quot;</code></pre>
<p>typeof是一个一元运算符（就像++，--，！，- 等一元运算符），不是一个函数，也不是一个语句。</p>
<p>对变量或值调用 typeof 运算符将返回下列值之一：</p>
<ul>
<li>undefined - 如果变量是 Undefined 类型的</li>
<li>boolean - 如果变量是 Boolean 类型的</li>
<li>number - 如果变量是 Number 类型的</li>
<li>string - 如果变量是 String 类型的</li>
<li>object - 如果变量是一种引用类型或 Null 类型的</li>
</ul>
<p><br></p></li>
</ol>
<h2 id="六运算符">六、运算符</h2>
<ol>
<li><p>算术运算符</p>
<pre><code><code>+ - * / % ++ --</code></pre></li>
<li><p>比较运算符</p>
<pre><code><code>&gt; &gt;= &lt; &lt;= != == === !==</code></pre>
<p>注意：</p>
<pre><code><code>1 == “1”  // true
1 === &quot;1&quot;  // false</code></pre></li>
<li><p>逻辑运算符</p>
<pre><code><code>&amp;&amp; || !</code></pre></li>
<li><p>赋值运算符</p>
<pre><code><code>= += -= *= /=</code></pre>
<p><br></p></li>
</ol>
<h2 id="七流程控制">七、流程控制</h2>
<ol>
<li><p>if-else</p>
<pre><code><code>var a = 10;
if (a &gt; 5){
  console.log(&quot;yes&quot;);
}else {
  console.log(&quot;no&quot;);
}</code></pre></li>
<li><p>if-else if-else</p>
<pre><code><code>var a = 10;
if (a &gt; 5){
  console.log(&quot;a &gt; 5&quot;);
}else if (a &lt; 5) {
  console.log(&quot;a &lt; 5&quot;);
}else {
  console.log(&quot;a = 5&quot;);
}</code></pre></li>
<li><p>switch</p>
<pre><code><code>var day = new Date().getDay();
switch (day) {
  case 0:
  console.log(&quot;Sunday&quot;);
  break;
  case 1:
  console.log(&quot;Monday&quot;);
  break;
default:
  console.log(&quot;...&quot;)
}</code></pre>
<p><strong>switch中的case子句通常都会加break语句，否则程序会继续执行后续case中的语句。</strong></p></li>
<li><p>for</p>
<pre><code><code>for (var i=0;i&lt;10;i++) {
  console.log(i);
}</code></pre></li>
<li><p>while</p>
<pre><code><code>var i = 0;
while (i &lt; 10) {
  console.log(i);
  i++;
}</code></pre></li>
<li><p>三元运算</p>
<pre><code><code>var a = 1;
var b = 2;
var c = a &gt; b ? a : b</code></pre></li>
</ol>
<p><br></p>
<h2 id="八函数">八、函数</h2>
<ol>
<li><p>函数定义</p>
<pre><code><code>// 普通函数定义
function f1() {
  console.log(&quot;Hello world!&quot;);
}

// 带参数的函数
function f2(a, b) {
  console.log(arguments);  // 内置的arguments对象
  console.log(arguments.length);
  console.log(a, b);
}

// 带返回值的函数
function sum(a, b){
  return a + b;
}
sum(1, 2);  // 调用函数

// 匿名函数方式
var sum = function(a, b){
  return a + b;
}
sum(1, 2);

// 立即执行函数
(function(a, b){
  return a + b;
})(1, 2);</code></pre>
<p><em>补充：</em></p>
<p>ES6中允许使用“箭头”（=&gt;）定义函数。</p>
<pre><code><code>var f = v =&gt; v;
// 等同于
var f = function(v){
  return v;
}</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就是用圆括号代表参数部分：</p>
<pre><code><code>var f = () =&gt; 5;
// 等同于
var f = function(){return 5};

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2){
  return num1 + num2;
}</code></pre>
<p><br></p></li>
<li><p>函数中的arguments参数</p>
<pre><code><code>function add(a,b){
  console.log(a+b);
  console.log(arguments.length)
}

add(1,2)
// 输出3 2</code></pre>
<p><em>注意：</em></p>
<p>函数只能返回一个值，如果要返回多个值，只能将其放在数组或对象中返回。</p>
<p><br></p></li>
<li><p>函数的全局变量和局部变量</p>
<ul>
<li><p>局部变量</p>
<p>在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。只要函数运行完毕，本地变量就会被删除。</p></li>
<li><p>全局变量</p>
<p>在函数外声明的变量是<em>全局</em>变量，网页上的所有脚本和函数都能访问它。</p></li>
<li><p>变量生存周期</p>
<p>JavaScript变量的生命期从它们被声明的时间开始。</p>
<p>局部变量会在函数运行以后被删除。</p>
<p>全局变量会在页面关闭后被删除。</p></li>
</ul>
<p><br></p></li>
<li><p>作用域</p>
<p>首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层。</p>
<p><strong>几个例子：</strong></p>
<p>一、</p>
<pre><code><code>var city = &quot;BeiJing&quot;;
function f() {
  var city = &quot;ShangHai&quot;;
  function inner(){
    var city = &quot;ShenZhen&quot;;
    console.log(city);
  }
  inner();
}

f();  
// 输出 ShenZhen</code></pre>
<p>二、</p>
<pre><code><code>var city = &quot;BeiJing&quot;;
function Bar() {
  console.log(city);
}
function f() {
  var city = &quot;ShangHai&quot;;
  return Bar;
}
var ret = f();
ret();  
// 输出 BeiJing</code></pre>
<p>三、闭包</p>
<pre><code><code>var city = &quot;BeiJing&quot;;
function f(){
    var city = &quot;ShangHai&quot;;
    function inner(){
        console.log(city);
    }
    return inner;
}
var ret = f();
ret();
// 输出 ShangHai</code></pre>
<p><br></p></li>
</ol>
<h2 id="九词法分析">九、词法分析</h2>
<p>JavaScript中在调用函数的那一瞬间，会先进行词法分析。</p>
<p><strong>词法分析的过程：</strong></p>
<p>当函数调用的前一瞬间，会先形成一个激活对象：Avtive Object（AO），并会分析以下3个方面：</p>
<p>1:函数参数，如果有，则将此参数赋值给AO，且值为undefined。如果没有，则不做任何操作。<br />
2:函数局部变量，如果AO上有同名的值，则不做任何操作。如果没有，则将此变量赋值给AO，并且值为undefined。<br />
3:函数声明，如果AO上有，则会将AO上的对象覆盖。如果没有，则不做任何操作。</p>
<p><strong>函数内部无论是使用参数还是使用局部变量都到AO上找。</strong></p>
<p>看两个例子：</p>
<pre><code><code>var age = 18;
function foo(){
  console.log(age);
  var age = 22;
  console.log(age);
}
foo();  // 问：执行foo()之后的结果是？</code></pre>
<p>第二题：</p>
<pre><code><code>var age = 18;
function foo(){
  console.log(age);
  var age = 22;
  console.log(age);
  function age(){
    console.log(&quot;呵呵&quot;);
  }
  console.log(age);
}
foo();  // 执行后的结果是？</code></pre>
<p>词法分析过程：<br />
1、分析参数，有一个参数，形成一个 AO.age=undefine;<br />
2、分析变量声明，有一个 var age, 发现 AO 上面已经有一个 AO.age，因此不做任何处理<br />
3、分析函数声明，有一个 function age(){...} 声明， 则把原有的 age 覆盖成 AO.age=function(){...};</p>
<p>最终，AO上的属性只有一个age，并且值为一个函数声明</p>
<p>执行过程：<br />
<strong>注意：执行过程中所有的值都是从AO对象上去寻找</strong></p>
<p>1、执行第一个 console.log(age) 时，此时的 AO.age 是一个函数，所以第一个输出的一个函数<br />
2、这句 var age=22; 是对 AO.age 的属性赋值， 此时AO.age=22 ，所以在第二个输出的是 2<br />
3、同理第三个输出的还是22, 因为中间再没有改变age值的语句了</p>
<p><br></p>
<h2 id="十内置对象和方法">十、内置对象和方法</h2>
<p>JavaScript中的所有事物都是对象：字符串、数字、数组、日期，等等。在JavaScript中，对象是拥有属性和方法的数据。</p>
<p><strong>注意var s1 = &quot;abc&quot;和var s2 = new String(&quot;abc&quot;)的区别：typeof s1 --&gt; string而 typeof s2 --&gt; Object</strong></p>
<p><img src="./images/前端基础之JavaScript0.png" /></p>
<ol>
<li><p>自定义对象</p>
<p>JavaScript的对象（Object）本质上是键值对的集合（Hash结构），但是只能用字符串作为键。</p>
<pre><code><code>var a = {&quot;name&quot;: &quot;djb&quot;, &quot;age&quot;: 18};
console.log(a.name);
console.log(a[&quot;age&quot;]);</code></pre>
<p>遍历对象中的内容：</p>
<pre><code><code>var a = {&quot;name&quot;: &quot;djb&quot;, &quot;age&quot;: 18};
for (var i in a){
  console.log(i, a[i]);
}</code></pre></li>
<li><p>Date对象</p>
<ul>
<li><p>创建Date对象</p>
<pre><code><code>//方法1：不指定参数
var d1 = new Date();
console.log(d1.toLocaleString());
//方法2：参数为日期字符串
var d2 = new Date(&quot;2004/3/20 11:12&quot;);
console.log(d2.toLocaleString());
var d3 = new Date(&quot;04/03/20 11:12&quot;);
console.log(d3.toLocaleString());
//方法3：参数为毫秒数
var d3 = new Date(5000);
console.log(d3.toLocaleString());
console.log(d3.toUTCString());

//方法4：参数为年月日小时分钟秒毫秒
var d4 = new Date(2004,2,20,11,12,0,300);
console.log(d4.toLocaleString());  //毫秒并不直接显示</code></pre></li>
<li><p>Date对象的方法</p>
<pre><code><code>var d = new Date(); 
//getDate()                 获取日
//getDay ()                 获取星期
//getMonth ()               获取月（0-11）
//getFullYear ()            获取完整年份
//getHours ()               获取小时
//getMinutes ()             获取分钟
//getSeconds ()             获取秒
//getMilliseconds ()        获取毫秒
//getTime ()                返回累计毫秒数(从1970/1/1午夜)</code></pre></li>
</ul></li>
<li><p>Json对象</p>
<pre><code><code>var str1 = &#39;{&quot;name&quot;: &quot;djb&quot;, &quot;age&quot;: 18}&#39;;
var obj1 = {&quot;name&quot;: &quot;djb&quot;, &quot;age&quot;: 18};
// JSON字符串转换成对象
var obj = JSON.parse(str1); 
// 对象转换成JSON字符串
var str = JSON.stringify(obj1);</code></pre></li>
<li><p>RegExp对象</p>
<pre><code><code>//RegExp对象

//创建正则对象方式1
// 参数1 正则表达式(不能有空格)
// 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写)

// 用户名只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。

// 创建RegExp对象方式（逗号后面不要加空格）
var reg1 = new RegExp(&quot;^[a-zA-Z][a-zA-Z0-9_]{5,11}$&quot;);

// 匹配响应的字符串
var s1 = &quot;bc123&quot;;

//RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。
reg1.test(s1);  // true

// 创建方式2
// /填写正则表达式/匹配模式（逗号后面不要加空格）
var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/;

reg2.test(s1);  // true


// String对象与正则结合的4个方法
var s2 = &quot;hello world&quot;;

s2.match(/o/g);         // [&quot;o&quot;, &quot;o&quot;]             查找字符串中 符合正则 的内容
s2.search(/h/g);        // 0                      查找字符串中符合正则表达式的内容位置
s2.split(/o/g);         // [&quot;hell&quot;, &quot; w&quot;, &quot;rld&quot;]  按照正则表达式对字符串进行切割
s2.replace(/o/g, &quot;s&quot;);  // &quot;hells wsrld&quot;          对字符串按照正则进行替换

// 关于匹配模式：g和i的简单示例
var s1 = &quot;name:Alice age:18&quot;;

s1.replace(/a/, &quot;哈哈哈&quot;);      // &quot;n哈哈哈me:Alice age:18&quot;
s1.replace(/a/g, &quot;哈哈哈&quot;);     // &quot;n哈哈哈me:Alice 哈哈哈ge:18&quot;      全局匹配
s1.replace(/a/gi, &quot;哈哈哈&quot;);    // &quot;n哈哈哈me:哈哈哈lice 哈哈哈ge:18&quot;  不区分大小写


// 注意事项1：
// 如果regExpObject带有全局标志g，test()函数不是从字符串的开头开始查找，而是从属性regExpObject.lastIndex所指定的索引处开始查找。
// 该属性值默认为0，所以第一次仍然是从字符串的开头查找。
// 当找到一个匹配时，test()函数会将regExpObject.lastIndex的值改为字符串中本次匹配内容的最后一个字符的下一个索引位置。
// 当再次执行test()函数时，将会从该索引位置处开始查找，从而找到下一个匹配。
// 因此，当我们使用test()函数执行了一次匹配之后，如果想要重新使用test()函数从头开始查找，则需要手动将regExpObject.lastIndex的值重置为 0。
// 如果test()函数再也找不到可以匹配的文本时，该函数会自动把regExpObject.lastIndex属性重置为 0。

var reg3 = /foo/g;
// 此时 regex.lastIndex=0
reg3.test(&#39;foo&#39;); // 返回true
// 此时 regex.lastIndex=3
reg3.test(&#39;xxxfoo&#39;); // 还是返回true
// 所以我们在使用test()方法校验一个字符串是否完全匹配时，一定要加上^和$符号。

// 注意事项2(说出来你可能不信系列)：
// 当我们不加参数调用RegExpObj.test()方法时, 相当于执行RegExpObj.test(&quot;undefined&quot;), 并且/undefined/.test()默认返回true。
var reg4 = /^undefined$/;
reg4.test(); // 返回true
reg4.test(undefined); // 返回true
reg4.test(&quot;undefined&quot;); // 返回true</code></pre></li>
<li><p>Math对象</p>
<pre><code><code>abs(x)      返回数的绝对值。
exp(x)      返回 e 的指数。
floor(x)    对数进行下舍入。
log(x)      返回数的自然对数（底为e）。
max(x,y)    返回 x 和 y 中的最高值。
min(x,y)    返回 x 和 y 中的最低值。
pow(x,y)    返回 x 的 y 次幂。
random()    返回 0 ~ 1 之间的随机数。
round(x)    把数四舍五入为最接近的整数。
sin(x)      返回数的正弦。
sqrt(x)     返回数的平方根。
tan(x)      返回角的正切。</code></pre></li>
</ol>
<p><br></p>
<p><br><br></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>