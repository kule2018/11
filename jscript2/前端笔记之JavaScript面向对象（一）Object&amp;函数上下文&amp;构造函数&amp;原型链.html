<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链</center></div><div class='banquan'>原文出处:本文由博客园博主RopeHuo提供。<br/>
原文连接:https://www.cnblogs.com/rope/p/10705049.html</div><br>
    <h1>一、<strong>对象（</strong><strong>Object</strong><strong>）</strong></h1>
<h2><strong>1.1 <span style="font-family: 宋体;">认识对象</span></strong></h2>
<p><span style="font-family: 宋体;">对象在</span>JS<span style="font-family: 宋体;">中狭义对象、广义对象两种。</span></p>
<p><span style="font-family: 微软雅黑;">广义：相当于宏观概念，是狭义内容的升华，高度的提升，范围的拓展。</span><br /><span style="font-family: 微软雅黑;">狭义：相当于微观概念，什么是</span>&ldquo;狭&rdquo;？因为内容狭隘具体，范围窄所以称为&ldquo;狭&rdquo;</p>
<h3>l&nbsp;<strong>狭义对象</strong></h3>
<p><span style="font-family: 宋体;">就是用</span>{}<span style="font-family: 宋体;">这种字面量的形式定义的对象，它是一组属性的无序集合</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   name : </span>"小明"<span style="color: #000000;">,
   age : </span>12<span style="color: #000000;">,
   sex : </span>"男"<span style="color: #000000;">,
   hobby : [</span>"足球","刺绣","打麻将"<span style="color: #000000;">]
}</span></pre>
</div>
<p>&nbsp;<span style="font-family: 宋体;">上面这个对象，表示一个</span>&ldquo;人&rdquo;里面有<span style="font-family: Consolas;">4</span><span style="font-family: 宋体;">个属性，换句话说，</span><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">这个对象里面除了</span>4<span style="font-family: 宋体;">个属性，别的什么都没有。</span></strong></span></p>
<p>&nbsp;</p>
<p>比如不用对象，而用数组来存储一组刚才的值：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> arr = ["小明",12,"男",["足球","刺绣","打麻将"<span style="color: #000000;">]]
console.log(arr)</span></pre>
</div>
<p><span style="font-family: 宋体;">数组只能存储</span>&ldquo;值&rdquo;，不能存储&ldquo;键&rdquo;。</p>
<p><span style="font-family: 宋体;">换句话说，数组中的值</span>&ldquo;语义&rdquo;不详。对象除了能存储值，还能存储值的&ldquo;语义&rdquo;，术语叫&ldquo;键<span style="font-family: Consolas;">(key)</span><span style="font-family: 宋体;">&rdquo;</span></p>
<p><span style="color: #ff0000;"><strong>其实，对象就是一组值和值的语义的封装。</strong></span></p>
<p>&nbsp;</p>
<p>【广义对象】</p>
<p><span style="color: #ff0000;"><strong>DOM<span style="font-family: 宋体;">元素是对象</span></strong></span><span style="font-family: 宋体;">，但是和刚刚说的</span>&ldquo;狭义对象里面只有一组值，别的什么都没有&rdquo;不同</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> oBox = document.getElementById("box"); <span style="color: #008000;">//</span><span style="color: #008000;">得到一个DOM对象</span>
oBox.xingming = "小明"<span style="color: #000000;">;
oBox.age </span>= 12<span style="color: #000000;">;
oBox.sex </span>= "男"<span style="color: #000000;">;
oBox.hobby </span>= ["足球","刺绣","打麻将"<span style="color: #000000;">];
console.log(oBox.hobby);
console.log(</span><span style="color: #0000ff;">typeof</span> oBox); <span style="color: #008000;">//</span><span style="color: #008000;">object</span></pre>
</div>
<p><span style="font-family: 宋体;">通过</span>DOM<span style="font-family: 宋体;">方法得到一个</span><span style="font-family: Consolas;">DOM</span><span style="font-family: 宋体;">对象，此时可以通过&ldquo;</span><span style="font-family: Consolas;">.</span><span style="font-family: 宋体;">&rdquo;点语法，给这个对象添加属性，用</span><span style="font-family: Consolas;">oBox</span><span style="font-family: 宋体;">访问</span><span style="font-family: Consolas;">age</span><span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">此时这个对象不仅仅只有</span>4<span style="font-family: 宋体;">个属性，还有别的，因为</span><span style="font-family: Consolas;">oBox</span><span style="font-family: 宋体;">毕竟有一个</span><span style="font-family: Consolas;">HTML</span><span style="font-family: 宋体;">标签实体在页面上。</span></p>
<p>&nbsp;</p>
<p><strong><span style="color: #ff0000;">数组也是对象</span>：</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> arr = [1,2,3,4,5<span style="color: #000000;">];
</span><span style="color: #008000;">//</span><span style="color: #008000;">也可以通过&ldquo;点&rdquo;语法，给数组添加属性</span>
arr.xingming = "小明"<span style="color: #000000;">;
arr.age </span>= 12<span style="color: #000000;">;
arr.sex </span>= "男"<span style="color: #000000;">;
console.log(</span><span style="color: #0000ff;">typeof</span> arr); <span style="color: #008000;">//</span><span style="color: #008000;">object</span>
console.log(arr.xingming); <span style="color: #008000;">//</span><span style="color: #008000;">小明</span></pre>
</div>
<p><span style="font-family: 宋体;">说明数组有对象的一切特征，能添加属性，但是你不能说这个数组只有</span>name<span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">age</span><span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">sex</span><span style="font-family: 宋体;">三个属性，别的什么都没有，毕竟它有一组数。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-family: 宋体;"><span style="color: #ff0000;">函数也是对象</span>：</span></strong></p>
<p>typeof<span style="font-family: 宋体;">检测类型返回结果是</span><span style="font-family: Consolas;">function</span><span style="font-family: 宋体;">不是</span><span style="font-family: Consolas;">object</span><span style="font-family: 宋体;">，这是系统规定，但</span><span style="font-family: Consolas;">function</span><span style="font-family: 宋体;">也是</span><span style="font-family: Consolas;">object</span><span style="font-family: 宋体;">对象，后面详解。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun(){
}
console.log(</span><span style="color: #0000ff;">typeof</span><span style="color: #000000;"> fun);
fun.xingming </span>= "小明"<span style="color: #000000;">;
fun.age </span>= 12<span style="color: #000000;">;
fun.sex </span>= "男"<span style="color: #000000;">;
console.log(fun.xingming)</span></pre>
</div>
<p><span style="font-family: 宋体;">此时对象添加了</span>4<span style="font-family: 宋体;">个属性，但是你不能说这个</span><span style="font-family: Consolas;">fun</span><span style="font-family: 宋体;">对象只有</span><span style="font-family: Consolas;">4</span><span style="font-family: 宋体;">个属性别的什么都没有，因为它毕竟是一个函数。</span>能够圆括号执行。</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>正则表达式</strong></span>也是对象：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> regexp = /\d/<span style="color: #000000;">g;
console.log(</span><span style="color: #0000ff;">typeof</span><span style="color: #000000;"> regexp)
regexp.xingming </span>= "小明"<span style="color: #000000;">;
regexp.age </span>= 12<span style="color: #000000;">;
regexp.sex </span>= "男"<span style="color: #000000;">;
console.log(regexp.xingming)</span></pre>
</div>
<p><span style="font-family: 宋体;">能添加属性成功，但是你不能说只有</span>3<span style="font-family: 宋体;">个属性，毕竟是一个正则。</span></p>
<p>&nbsp;</p>
<p>系统内置的所有引用类型值，都是对象，都能添加自定义属性，并且能够访问这些属性：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> 函数
Array 数组
RegExp 正则表达式
DOM元素
window、document、Math、Date对象
Number()、Sting()内置包装构造函数</span></pre>
</div>
<p>这些对象除了一组属性之外，还有其他的东西。比如数组还有一组值；比如函数还有一组语句，能够圆括号执行。</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>什么不是对象？就是系统的基本类型：</strong></span></p>
<p>数字不能添加属性，因为数字是基本类型，不是对象</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> a = 100<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">试图添加属性</span>
a.xingming = "小明"<span style="color: #000000;">;
a.age </span>= 12<span style="color: #000000;">;
console.log(a.age); </span><span style="color: #008000;">//</span><span style="color: #008000;">undefined</span></pre>
</div>
<p><span style="font-family: 宋体;">这几天研究的就是对象，只有</span>JS<span style="font-family: 宋体;">提供（除了属性还有别的东西）的对象，我们不能创建，也就是说，</span><span style="color: #ff0000;"><strong>对开发者而言，我们只能创建狭义对象。</strong></span></p>
<p>&nbsp;</p>
<p>那么到底有什么性质，就称它为是对象？</p>
<p><span style="color: #ff0000;"><strong>能添加属性，特别的微观层面，只要这个东西能存放在堆内存中，就可以认为是一个对象。</strong></span></p>
<hr />
<h2><strong>1.2<span style="font-family: 宋体;">对象的方法</span></strong></h2>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">如果一个对象的属性是函数，我们称这个属性叫这个对象的方法（</span>methods<span style="font-family: 宋体;">）</span></strong></span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">当一个函数当作对象的方法被调用时，这个函数里面的</span>this<span style="font-family: 宋体;">表示这个对象。</span></strong></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">下面这个对象有一个属性，叫sayHello，它的值是函数，所以可以把它叫做obj的方法</span>
<span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   xingming : </span>"小明"<span style="color: #000000;">,
   age : </span>12<span style="color: #000000;">,
   sex :</span>"男"<span style="color: #000000;">,
   sayHello : </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       alert(</span>"你好，我是" + <span style="color: #0000ff;">this</span>.xingming +"，今年" + <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
   }
};
obj.sayHello()</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">现在调用</span>sayHello<span style="font-family: 宋体;">函数时，是通过</span><span style="font-family: Consolas;">obj</span><span style="font-family: 宋体;">打点调用的，所以这个</span><span style="font-family: Consolas;">sayHello</span><span style="color: #ff0000;"><strong><span style="text-decoration: underline;"><span style="font-family: 宋体;">函数的上下文</span></span></strong></span><span style="font-family: 宋体;">就是</span>obj<span style="font-family: 宋体;">对象。</span></p>
<p><span style="font-family: 宋体;">即</span>sayHello<span style="font-family: 宋体;">函数内部的</span><span style="font-family: Consolas;">this</span><span style="font-family: 宋体;">指向</span><span style="font-family: Consolas;">obj</span><span style="font-family: 宋体;">。</span></p>
<p>&nbsp;</p>
<p>但是千万不要认为写在对象里面的函数，上下文就是这个对象！！！</p>
<p>比如：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> xingming = "小红"<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> age = 18<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   xingming : </span>"小明"<span style="color: #000000;">,
   age : </span>12<span style="color: #000000;">,
   sex : </span>"男"<span style="color: #000000;">,
   sayHello : </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       alert(</span>"你好，我是" + <span style="color: #0000ff;">this</span>.xingming +"，今年" + <span style="color: #0000ff;">this</span><span style="color: #000000;">.age)
   }
};
</span><span style="color: #0000ff;">var</span> fn =<span style="color: #000000;"> obj.sayHello;
fn(); </span><span style="color: #008000;">//</span><span style="color: #008000;">直接()调用，不是对象打点调用，所以this上下文是window</span></pre>
</div>
<p><span style="color: #ff0000;"><strong>函数的上下文是什么，取决于函数是怎么调用的，而不是函数如何定义。</strong></span></p>
<p><span style="color: #ff0000;"><strong>函数的上下文是函数的调用时表现的性质，不是函数定义时写死的性质。</strong></span></p>
<hr />
<h2><strong>1.3<span style="font-family: 宋体;">对象和</span><span style="font-family: 华文中宋;">JSON</span><span style="font-family: 宋体;">的区别</span></strong></h2>
<p>JSON(JavaScript Object Notation, JS <span style="font-family: 宋体;">对象</span><span style="font-family: 宋体;">标记</span>) <span style="font-family: 宋体;">是一种轻量级的数据交换格式</span><span style="font-family: 宋体;">，</span>JS<span style="font-family: 宋体;">对象表示法</span><span style="font-family: 宋体;">。</span></p>
<p><span style="color: #ff0000;"><strong>JSON<span style="font-family: 宋体;">是</span><span style="font-family: Consolas;">JS</span><span style="font-family: 宋体;">对象的严格子集。</span></strong></span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">区别就是引号：</span>JSON<span style="font-family: 宋体;">要求所有的键都必须加引号，而</span><span style="font-family: Consolas;">JS</span><span style="font-family: 宋体;">对象实际上不要求加引号。</span></strong></span></p>
<p>这是一个标准的JSON<span style="font-family: 宋体;">：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   </span>"name" : "小明"<span style="color: #000000;">,
   </span>"age" : 12<span style="color: #000000;">,
   </span>"sex" : "男"<span style="color: #000000;">
}</span></pre>
<hr />
<pre><code><span style="color: #000000;">
实际上不加引号也合法：
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   name : </span>"小明"<span style="color: #000000;">,
   age : </span>12<span style="color: #000000;">,
   sex : </span>"男"<span style="color: #000000;">
}</span></pre>
</div>
<p><span style="font-family: 宋体;">为什么</span>JSON<span style="font-family: 宋体;">规定要加上引号呢？因为</span><span style="font-family: Consolas;">JSON</span><span style="font-family: 宋体;">是一个数据交互格式，它是</span>前端<span style="font-family: 宋体;">和</span>PHP<span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">Java</span><span style="font-family: 宋体;">等后台语言的信息交换媒介，后台工程师可以从数据库得到数据，组建</span><span style="font-family: Consolas;">JSON</span><span style="font-family: 宋体;">，前台通过</span><span style="font-family: Consolas;">Ajax</span><span style="font-family: 宋体;">拿到这个</span><span style="font-family: Consolas;">JSON</span><span style="font-family: 宋体;">之后，解析</span><span style="font-family: Consolas;">JSON</span><span style="font-family: 宋体;">渲染页面。</span></p>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链0.png" alt="" /></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">所以是其他语言要求这个</span>JSON<span style="font-family: 宋体;">有引号，否则其他语言会报错，不是</span><span style="font-family: Consolas;">JS</span><span style="font-family: 宋体;">要求的，</span><span style="font-family: Consolas;">JSON</span><span style="font-family: 宋体;">天生为通信而生！！</span></strong></span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">但是，有一种必须加引号，就是不符合命名规范的键名，必须加引号，否则报错。</span></strong></span></p>
<p>&nbsp;</p>
<p>&nbsp;比如下面的键名都不符合标识符的命名规范，必须加引号：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
       </span>"-" : 18<span style="color: #000000;">,
       </span>"@#$" : 20<span style="color: #000000;">,
       </span>"2018" : 100<span style="color: #000000;">,
       </span>"哈哈" : 200<span style="color: #000000;">,
       </span>"key"  : 888<span style="color: #000000;">,
</span>"true" : 999<span style="color: #000000;">
}
console.log(obj[</span>"-"]); <span style="color: #008000;">//</span><span style="color: #008000;">访问属性时，也要加引号，表示键名</span>
console.log(obj["@#$"<span style="color: #000000;">]);
console.log(obj[</span>"2018"<span style="color: #000000;">]);
console.log(obj.哈哈);
console.log(obj[</span>"哈哈"]);</pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">特别的是，如果用一个变量存储一个</span>key<span style="font-family: 宋体;">，此时必须用</span><span style="font-family: Consolas;">[]</span><span style="font-family: 宋体;">枚举，并且</span><span style="font-family: Consolas;">[]</span><span style="font-family: 宋体;">不能加引号</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> key = 2018<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> k = 3 &lt; 8; <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
console.log(obj.key);   <span style="color: #008000;">//</span><span style="color: #008000;">888 点语法只能以字符串形式访问对象的属性，key不能是变量</span>
console.log(obj["key"]); <span style="color: #008000;">//</span><span style="color: #008000;">888</span>
console.log(obj[key]); <span style="color: #008000;">//</span><span style="color: #008000;">2018的100，实际上读取的是obj["2018"]，[]会隐式转换为字符串</span>
console.log(obj[k]); <span style="color: #008000;">//</span><span style="color: #008000;">999</span></pre>
</div>
<hr />
<h2><strong>1.4<span style="font-family: 宋体;">全局变量是</span><span style="font-family: 华文中宋;">window</span><span style="font-family: 宋体;">对象的属性</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> a = 100<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> b = 200<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> c = 300<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> d = 400<span style="color: #000000;">;
alert(window.a)
alert(window.b)
alert(window.c)
alert(window.d)</span></pre>
</div>
<hr />
<h1><strong>二、函数的上下文（</strong><strong>context</strong><strong>）</strong></h1>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">所谓的上下文就是指函数里面的</span>this<span style="font-family: 宋体;">是谁。</span></strong></span><span style="font-family: 宋体;">就说</span>&ldquo;函数的上下文是什么&rdquo;</p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">函数中的</span>this<span style="font-family: 宋体;">是谁，看这个函数是如何调用的，而不是看这个函数如何定义的。</span></strong></span></p>
<p>举个例子：踢足球的时候，球进对方的门，看谁最后碰到球，我方球员射门的那一脚踢到了门柱，反弹给对方球员进门，就是乌龙球。</p>
<h2><strong>2.1<span style="font-family: 宋体;">规则</span><span style="font-family: 华文中宋;">1</span><span style="font-family: 宋体;">：函数直接圆括号调用，上下文是</span><span style="font-family: 华文中宋;">window</span><span style="font-family: 宋体;">对象</span></strong></h2>
<p><strong><span style="text-decoration: underline;">直接</span></strong><span style="font-family: 宋体;">两个字，表示这个函数代号之前，没有任何标识符，没有小圆点，没有方括号。通常从数组、对象中</span>&ldquo;提&rdquo;出函数的操作（把函数赋给变量）：</p>
<p><span style="font-family: 宋体;">在</span>obj<span style="font-family: 宋体;">对象中定义一个函数，叫</span><span style="font-family: Consolas;">fun</span><span style="font-family: 宋体;">，这个是</span><span style="font-family: Consolas;">obj</span><span style="font-family: 宋体;">的属性：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> a = 888<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   a : </span>100<span style="color: #000000;">,
   fun : </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.a);
   }
}</span></pre>
</div>
<p>如直接<strong><span style="text-decoration: underline;">对象打点调用函数</span></strong><span style="font-family: 宋体;">：此时弹出</span>100<span style="font-family: 宋体;">，说明函数上下文是</span><span style="font-family: Consolas;">obj</span><span style="font-family: 宋体;">对象本身。</span></p>
<div class="cnblogs_code">
<pre><code>obj.fun();</pre>
</div>
<p>&nbsp;</p>
<p>但如果这个函数被一个变量接收（让变量直接指向这个对象的方法）</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> fn =<span style="color: #000000;"> obj.fun;
<span style="color: #ff0000;">fn(); </span></span><span style="color: #ff0000;">//这个叫()直接运行</span></pre>
</div>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">然后调用，函数的</span>this<span style="font-family: 宋体;">将是</span><span style="font-family: Consolas;">window</span><span style="font-family: 宋体;">对象，</span><span style="font-family: Consolas;">this.a</span><span style="font-family: 宋体;">就是访问全局的</span><span style="font-family: Consolas;">a</span><span style="font-family: 宋体;">变量是</span><span style="font-family: Consolas;">888</span></strong></span></p>
<p>&nbsp;</p>
<p>l&nbsp;<strong><span style="font-family: 宋体;">注意，所有</span>IIFE<span style="font-family: 宋体;">，都属于直接调用范围，里面的</span><span style="font-family: Consolas;">this</span><span style="font-family: 宋体;">都是</span><span style="font-family: Consolas;">window</span><span style="font-family: 宋体;">。</span></strong></p>
<p><span style="font-family: 宋体;">不管</span>IIFE<span style="font-family: 宋体;">写的有多深，不管所在的环境多复杂，上下文一律是</span><span style="font-family: Consolas;">window</span><span style="font-family: 宋体;">对象。</span></p>
<p><span style="font-family: 宋体;">比如下面</span>obj<span style="font-family: 宋体;">对象中的</span><span style="font-family: Consolas;">b</span><span style="font-family: 宋体;">，是</span><span style="font-family: Consolas;">IIFE</span><span style="font-family: 宋体;">：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> a = 888<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   a : </span>100<span style="color: #000000;">,
   b : (</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.a);
   })()
}
obj.b; </span><span style="color: #008000;">//</span><span style="color: #008000;">888</span></pre>
</div>
<p>&nbsp;</p>
<p>小题目：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> xiaoming =<span style="color: #000000;"> {
    name :</span>"小明"<span style="color: #000000;">,
    age : </span>23<span style="color: #000000;">,
    chengwei: (</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.age &gt;= 18 ? "先生" : "小朋友"<span style="color: #000000;">
    })()
}
alert(xiaoming.name </span>+ xiaoming.chengwei)</pre>
</div>
<hr />
<h2>&nbsp;</h2>
<h2><strong>2.2<span style="font-family: 宋体;">规则</span><span style="font-family: 华文中宋;">2</span><span style="font-family: 宋体;">：定时器直接调用函数，上下文是</span><span style="font-family: 华文中宋;">window</span><span style="font-family: 宋体;">对象</span></strong></h2>
<p><span style="font-family: 宋体;">这个</span>fn<span style="font-family: 宋体;">的最终调用者是定时器</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> a = 100<span style="color: #000000;">;
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn(){
   console.log(</span><span style="color: #0000ff;">this</span>.a++<span style="color: #000000;">);
}
setInterval(fn,</span>1000)</pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链1.png" alt="" /></p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Consolas; mso-hansi-font-family: Consolas; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">注意临门一脚谁踢的，是谁最终调用那个函数，比如：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> a = 100<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   a : </span>200<span style="color: #000000;">,
   fn : </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       console.log(</span><span style="color: #0000ff;">this</span>.a++<span style="color: #000000;">);
   }
}
setInterval(obj.fn, </span>1000); <span style="color: #008000;">//</span><span style="color: #008000;">obj.fn没有()执行，是定时器调用的</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链2.png" alt="" /></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> a = 100<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   a : </span>200<span style="color: #000000;">,
   fn : </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       console.log(</span><span style="color: #0000ff;">this</span>.a++<span style="color: #000000;">);
   }
}
setInterval(</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
   obj.fn();  </span><span style="color: #008000;">//</span><span style="color: #008000;">obj.fn()直接调用，上下文的this是obj</span>
}, 1000);</pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链3.png" alt="" /></p>
<hr />
<h2><strong>2.3<span style="font-family: 宋体;">规则</span><span style="font-family: 华文中宋;">3</span><span style="font-family: 宋体;">：</span><span style="font-family: 华文中宋;">DOM</span><span style="font-family: 宋体;">事件处理函数的</span><span style="font-family: 华文中宋;">this</span><span style="font-family: 宋体;">，指的是触发事件的这个元素</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> box1 = document.getElementById("box1"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> box2 = document.getElementById("box2"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> box3 = document.getElementById("box3"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> btn1 = document.getElementById("btn1"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> btn2 = document.getElementById("btn2"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> btn3 = document.getElementById("btn3"<span style="color: #000000;">);
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> setColor(){
    </span><span style="color: #0000ff;">this</span>.style.backgroundColor = 'red'<span style="color: #000000;">;
}
box1.onclick </span>=<span style="color: #000000;"> setColor;
box2.onclick </span>=<span style="color: #000000;"> setColor;
box3.onclick </span>=<span style="color: #000000;"> setColor;
btn1.onclick </span>=<span style="color: #000000;"> setColor;
btn2.onclick </span>=<span style="color: #000000;"> setColor;
btn3.onclick </span>= setColor;</pre>
</div>
<p>&nbsp;</p>
<p>此时点击上面的元素，上面元素就是函数的上下文。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> box1 = document.getElementById("box1"<span style="color: #000000;">);
box1.onclick </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span>; <span style="color: #008000;">//</span><span style="color: #008000;">备份this</span>
    setTimeout(<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">这里this指向window，所以先在外面备份this，再用</span>
        self.style.background = 'red'<span style="color: #000000;">;
    },</span>1000<span style="color: #000000;">)
}</span></pre>
</div>
<hr />
<h2><strong>2.4<span style="font-family: 宋体;">规则</span><span style="font-family: 华文中宋;">4</span><span style="font-family: 宋体;">：</span><span style="font-family: 华文中宋;">call()</span><span style="font-family: 宋体;">和</span><span style="font-family: 华文中宋;">apply()</span><span style="font-family: 宋体;">设置函数的上下文</span></strong></h2>
<p><span style="font-family: 宋体;">普通函数</span>function<span style="font-family: 宋体;">的</span>this是<span style="font-family: 宋体;">指向</span>window<span style="font-family: 宋体;">。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun(){
   console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">);
}
fun();</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链4.png" alt="" /></p>
<p><span style="font-family: 宋体;">我们说函数的上下文看函数是如何调用的，但任何函数可以通过</span>call()<span style="font-family: 宋体;">和</span><span style="font-family: Consolas;">apply()</span><span style="font-family: 宋体;">这两个内置方法来调用函数的同时，还能改变它的</span><span style="font-family: Consolas;">this</span><span style="font-family: 宋体;">指向。</span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">l&nbsp;<strong>公式：函数将以某对象为上下文运行。</strong></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">函数.call(某对象);
函数.apply(某对象);</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> oBox = document.getElementById('box'<span style="color: #000000;">);
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun(){
    console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">this</span>.style.backgroundColor = 'red'<span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">call和apply作用都一样，有两个作用：</span><span style="color: #008000;">
//</span><span style="color: #008000;">1、执行fun函数</span><span style="color: #008000;">
//</span><span style="color: #008000;">2、改变fun函数的this指向div</span>
<span style="color: #000000;">fun.call(oBox)
fun.apply(oBox)</span></pre>
</div>
<p><span style="color: #ff0000;"><strong>call<span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">apply</span><span style="font-family: 宋体;">功能是一样的，都是让函数调用，并且设置函数</span><span style="font-family: Consolas;">this</span><span style="font-family: 宋体;">指向谁。区别</span></strong><strong>在于</strong><strong>函数传递参数的语法不同。</strong></span></p>
<p>&nbsp;</p>
<p>l&nbsp;call<span style="font-family: 宋体;">需要用逗号隔开罗列所有参数</span></p>
<p>l&nbsp;apply<span style="font-family: 宋体;">是把所有参数写在数组里面，即使只有一个参数，也必须写在数组中。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   a:</span>100<span style="color: #000000;">
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun(a,b,c){
   console.log(a,b,c)
   console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">);
}
fun.call(obj,</span>10,20,30<span style="color: #000000;">);
fun.apply(obj,[</span>10,20,30]);</pre>
</div>
<p><span style="font-family: 宋体;">比如有一个函数叫变性函数（</span>bianxing<span style="font-family: 宋体;">），它能够将自己上下文的</span><span style="font-family: Consolas;">sex</span><span style="font-family: 宋体;">属性改变。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">此时小明对象（</span>xiaoming<span style="font-family: 宋体;">），迫切要变性，</span><span style="font-family: Consolas;">xiaoming</span><span style="font-family: 宋体;">就成为</span><span style="font-family: Consolas;">bianxing</span><span style="font-family: 宋体;">的上下文：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> bianxing(){
   </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.sex == '男'<span style="color: #000000;">){
       </span><span style="color: #0000ff;">this</span>.sex  = '女'<span style="color: #000000;">
   }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
       </span><span style="color: #0000ff;">this</span>.sex  = '男'<span style="color: #000000;">
   }
}
</span><span style="color: #0000ff;">var</span> xiaoming =<span style="color: #000000;"> {
   name : </span>"小明"<span style="color: #000000;">,
   sex  : </span>"男"<span style="color: #000000;">,
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> bianxing : bianxing</span>
<span style="color: #000000;">}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> xiaoming.bianxing()</span>
<span style="color: #000000;">bianxing.call(xiaoming);
bianxing.apply(xiaoming);
console.log(xiaoming)</span></pre>
</div>
<p><span style="color: #ff0000;"><strong>call<span style="font-family: 宋体;">和</span><span style="font-family: Consolas;">apply</span><span style="font-family: 宋体;">方法帮我们做了两件事：</span></strong></span></p>
<p><span style="color: #ff0000;">l&nbsp;<strong><span style="font-family: 宋体;">调用</span>bianxing<span style="font-family: 宋体;">函数</span></strong></span></p>
<p><span style="color: #ff0000;">l&nbsp;<strong><span style="font-family: 宋体;">改变</span>bianxing<span style="font-family: 宋体;">函数的</span><span style="font-family: Consolas;">this</span><span style="font-family: 宋体;">指向为</span><span style="font-family: Consolas;">xiaoming</span></strong></span></p>
<hr />
<h3><strong>小题目：</strong></h3>
<p>apply<span style="font-family: 宋体;">通常用于一个函数调用另一个函数的时，将自己所有的参数都传入一个函数：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun1(){
   fun2.apply(obj, arguments)
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun2(a,b,c){
   console.log(</span><span style="color: #0000ff;">this</span> === obj);<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #000000;">   console.log(a)
   console.log(b)
   console.log(c)
}
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {}
fun1(</span>"苹果","西瓜","哈密瓜")</pre>
</div>
<p>&nbsp;</p>
<p>比如要求数组中的最大值</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Math.max(); 方法可以返回所有参数的最大值</span><span style="color: #008000;">
//</span><span style="color: #008000;"> Math.min(); 方法可以返回所有参数的最小值</span>
console.log(Math.max(312,432,64,654,88,213,888,999<span style="color: #000000;">));
console.log(Math.min(</span>312,432,64,654,88,213,888,999));</pre>
</div>
<p>但是，如果给你一个数组呢？此时迫切要将数组拆解为裸写的一个个的参数。</p>
<p><span style="font-family: 宋体;">那么</span>apply<span style="font-family: 宋体;">足够好用，这里不能用</span><span style="font-family: Consolas;">call</span><span style="font-family: 宋体;">，因为</span><span style="font-family: Consolas;">call</span><span style="font-family: 宋体;">是裸写参数，不是传数组。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> arr = [31,88,543,999,777,42<span style="color: #000000;">]
console.log(Math.max.apply(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, arr))
console.log(Math.min.apply(</span><span style="color: #0000ff;">null</span>, arr))</pre>
</div>
<hr />
<h2><strong>2.5<span style="font-family: 宋体;">规则</span><span style="font-family: 华文中宋;">5</span><span style="font-family: 宋体;">：从对象或数组中枚举的函数，上下文是这个对象或数组</span></strong></h2>
<p><span style="font-family: 宋体;">来看一个最基本的模型，就是对象中的方法，方法中出现</span>this<span style="font-family: 宋体;">。</span></p>
<p>如果调用是：<span style="color: #ff0000;"><strong><span style="text-decoration: underline;"><span style="font-family: 宋体;">对象</span>.<span style="font-family: 宋体;">方法</span><span style="font-family: Consolas;">()</span></span></strong><strong><span style="font-family: 宋体;">，此时函数中</span>this<span style="font-family: 宋体;">就是指向这个对象。</span></strong></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   a : </span>100<span style="color: #000000;">,
   b : </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.a)
   }
}
obj.b(); </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">数组也一样，如果一样函数是从数组中枚举的，加圆括号执行，数组</span>[0](); <span style="font-family: 宋体;">此时上下文就是数组</span></strong></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> arr =<span style="color: #000000;"> [
    </span>"A"<span style="color: #000000;">,
    </span>"B"<span style="color: #000000;">,
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.length)
    }
]
arr[</span>2](); <span style="color: #008000;">//</span><span style="color: #008000;">输出3，这写法是从数组中枚举出来的，所以是数组在调用函数。</span>
<span style="color: #0000ff;">var</span> f = arr[2<span style="color: #000000;">];
f(); </span><span style="color: #008000;">//</span><span style="color: #008000;">0 全局没有length长度</span>
console.log(arr)</pre>
</div>
<hr />
<h3><strong>知识复习</strong></h3>
<p><span style="font-family: 宋体;">函数的</span>length<span style="font-family: 宋体;">值是函数的：</span><strong><span style="text-decoration: underline;">形参列表的长度</span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> f(a,b,c,d,e,f,g,h){
}
console.log(f.length); </span><span style="color: #008000;">//</span><span style="color: #008000;">8</span></pre>
</div>
<p>&nbsp;</p>
<p>arguments.length<span style="font-family: 宋体;">表示函数的：</span><strong><span style="text-decoration: underline;">实参列表的长度</span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> f(a,b,c,d,e,f,g,h){
   console.log(arguments);
   console.log(arguments.length); </span><span style="color: #008000;">//</span><span style="color: #008000;">5</span>
   console.log(arguments.callee); <span style="color: #008000;">//</span><span style="color: #008000;">callee等价于函数本身f</span>
   console.log(arguments.callee.length); <span style="color: #008000;">//</span><span style="color: #008000;">8</span>
<span style="color: #000000;">}
f(</span>1,2,3,4,5)</pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun1(a,b,c){
   console.log(arguments[</span>0].length); <span style="color: #008000;">//</span><span style="color: #008000;">5</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun2(a,b,c,d,e) {
}
fun1(fun2)</span></pre>
</div>
<h3>&nbsp;</h3>
<hr />
<h3>&nbsp;</h3>
<h3><strong><span style="font-family: 宋体;">小题目</span>1<span style="font-family: 宋体;">：</span></strong></h3>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">arguments枚举出了第0项，就是传入的fun2函数，加()执行。</span><span style="color: #008000;">
//</span><span style="color: #008000;">这里就符合规律5的内容，所以fun2的上下文this执行的是fun1的arguments类数组对象</span><span style="color: #008000;">
//</span><span style="color: #008000;">所以它的length表示调用fun1的时候传入的实参长度，是9</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> fun1(a,b,c){
   arguments[</span>0<span style="color: #000000;">]();
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun2(a,b,c,d,e) {
   alert(</span><span style="color: #0000ff;">this</span>.length); <span style="color: #008000;">//</span><span style="color: #008000;">9</span>
<span style="color: #000000;">}
fun1(fun2,</span>2,3,4,5,6,7,8,9); <span style="color: #008000;">//</span><span style="color: #008000;">9</span></pre>
</div>
<h3>&nbsp;</h3>
<hr />
<h3>&nbsp;</h3>
<h3><strong><span style="font-family: 宋体;">小题目</span>2<span style="font-family: 宋体;">：</span></strong></h3>
<p>小题目进阶版：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun1(a,b,c){
   arguments[</span>0](1,2,3,4,5,6); <span style="color: #008000;">//</span><span style="color: #008000;">arguments[0] == fun2函数</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun2(a,b,c,d,e) {
   </span><span style="color: #008000;">//</span><span style="color: #008000;">这个函数里面的this表示fun1函数的arguments对象</span>
   alert(<span style="color: #0000ff;">this</span>.length);         <span style="color: #008000;">//</span><span style="color: #008000;">9    fun1的实参个数</span>
   alert(<span style="color: #0000ff;">this</span>.callee.length);  <span style="color: #008000;">//</span><span style="color: #008000;">3   fun1的形参个数</span>
   alert(arguments.length);    <span style="color: #008000;">//</span><span style="color: #008000;">6   fun2的实参个数</span>
   alert(arguments.callee.length);  <span style="color: #008000;">//</span><span style="color: #008000;">5  fun2的形参个数</span>
<span style="color: #000000;">}
fun1(fun2,</span>2,3,4,5,6,7,8,9); <span style="color: #008000;">//</span><span style="color: #008000;">9</span></pre>
</div>
<h3>&nbsp;</h3>
<hr />
<h3>&nbsp;</h3>
<h3><strong><span style="font-family: 宋体;">小题目</span>3<span style="font-family: 宋体;">：</span></strong></h3>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> m = 1<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
    fn1 : </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.fn2();
    },
    fn2 : fn2,
    <span style="color: #ff0000;">m : </span></span><span style="color: #ff0000;">2</span><span style="color: #000000;">
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn2(){
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.m;
}
alert(obj.fn1()); </span><span style="color: #008000;">//</span><span style="color: #008000;">2</span></pre>
</div>
<h3>&nbsp;</h3>
<hr />
<h3>&nbsp;</h3>
<h3><strong><span style="font-family: 宋体;">小题目</span>4<span style="font-family: 宋体;">：</span></strong></h3>
<p><span style="font-family: 宋体;">不管函数的</span>&ldquo;身世&rdquo;多复杂，一定要只看调用的哪一下是如何调用的</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> length = 1<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   length : </span>10<span style="color: #000000;">,
   b : [{
       length:</span>20<span style="color: #000000;">,
       fn:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
           alert(</span><span style="color: #0000ff;">this</span>.length) <span style="color: #008000;">//</span><span style="color: #008000;">this == {}</span>
<span style="color: #000000;">       }
   }]
}
obj.b[</span>0].fn(); <span style="color: #008000;">//</span><span style="color: #008000;">20 b[0] == {}</span>
<span style="color: #0000ff;">var</span> o = obj.b[0<span style="color: #000000;">];
</span><span style="color: #0000ff;">var</span> fn = obj.b[0<span style="color: #000000;">].fn;
o.fn();     </span><span style="color: #008000;">//</span><span style="color: #008000;">20</span>
fn();          <span style="color: #008000;">//</span><span style="color: #008000;">1</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> length = 1<span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
   length : </span>10<span style="color: #000000;">,
   b : [{
           length:</span>20<span style="color: #000000;">,
           fn:</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
               alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.length)
           }
       }]
}
</span><span style="color: #0000ff;">var</span> arr = [obj, obj.b, obj.b[0], obj.b[0<span style="color: #000000;">].fn];
arr[</span>0].b[0].fn();  <span style="color: #008000;">//</span><span style="color: #008000;">20</span>
arr[1][0].fn();    <span style="color: #008000;">//</span><span style="color: #008000;">20</span>
arr[2].fn();       <span style="color: #008000;">//</span><span style="color: #008000;">20</span>
arr[3]();          <span style="color: #008000;">//</span><span style="color: #008000;">4</span></pre>
</div>
<div class="cnblogs_code">
<pre><code>如何判断上下文（<span style="color: #0000ff;">this</span><span style="color: #000000;">）：
规则1：直接圆括号调用fn()，IIFE调用，此时this是window
规则2：对象打点调用obj.fn()，此时this是obj
规则3：数组中枚举函数调用arr[</span>3<span style="color: #000000;">]()，此时this是arr
规则4：定时器调用函数setInterval(fn , </span>10<span style="color: #000000;">)，此时this是window
规则5：DOM事件监听oBtn.onclick </span>=<span style="color: #000000;"> fn，此时this是oBtn
规则6：call和allpay可以指定，fn.call(obj)，此时this是obj
规则7：用new调用函数，</span><span style="color: #0000ff;">new</span> fun()，此时this是秘密新创建的空白对象。</pre>
</div>
<hr />
<h1><strong>三、构造函数</strong></h1>
<h2><strong>3.1<span style="font-family: 宋体;">构造函数</span></strong></h2>
<p>到目前为止，调用一个函数的方法，有很多：直接()圆括号调用、数组或对象枚举调用、定时器调用、DOM<span style="font-family: 宋体;">事件调用，随着调用的方法不同，函数的上下文也不同。</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">现在，要介绍一种函数的调用方式，用</span>new<span style="font-family: 宋体;">来调用。</span></strong></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun(){
   alert(</span>"我调用"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">var</span> obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> fun();
console.log(obj)</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链5.png" alt="" /></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
   </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数，可以称为一个&ldquo;类&rdquo;，描述的是一个类对象需要拥有的属性</span>
   <span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
   </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
   </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数的实例，也可以称为&ldquo;类的实例&rdquo;，就相当于按照类的要求，实例化了一个个人</span>
<span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaohong = <span style="color: #0000ff;">new</span> People("小红",13,"女"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaogangpao = <span style="color: #0000ff;">new</span> People("小钢炮",16,"女"<span style="color: #000000;">);
console.log(xiaoming)
console.log(xiaohong)
console.log(xiaogangpao)</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链6.png" alt="" /></p>
<p align="justify">new<span style="font-family: 宋体;">是一个动词，表示产生&ldquo;新&rdquo;的，会发现，的确这个函数产生了新的对象。</span></p>
<p>&nbsp;<img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链7.png" alt="" /></p>
<p><strong><span style="font-family: 宋体;">结论：当用</span>new<span style="font-family: 宋体;">调用一个函数时，会发生</span><span style="font-family: Consolas;">4</span><span style="font-family: 宋体;">四件事（</span><span style="font-family: Consolas;">4</span><span style="font-family: 宋体;">步走）</span></strong></p>
<p><span style="color: #ff0000;">1)&nbsp;<strong><span style="font-family: 宋体;">函数内部会创建一个新的空对象</span>&ldquo;<span style="font-family: Consolas;">{}</span><span style="font-family: 宋体;">&rdquo;</span></strong></span></p>
<p><span style="color: #ff0000;">2)&nbsp;<strong><span style="font-family: 宋体;">将构造函数的作用域赋值给新对象（因此</span>this<span style="font-family: 宋体;">就指向这个新的空对象）</span></strong></span></p>
<p><span style="color: #ff0000;">3)&nbsp;<strong>执行构造函数中的代码（为这个新的空对象添加属性）</strong></span></p>
<p><span style="color: #ff0000;">4)&nbsp;<strong><span style="font-family: 宋体;">函数执行完毕后，将这个对象返回（</span>return<span style="font-family: 宋体;">）到外面被接收。（函数将把自己的上下文返回给这个对象）</span></strong></span></p>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<p>&nbsp;<span style="color: #ff0000;"><strong><span style="font-family: 宋体;">对象是什么？一个泛指，</span>JS<span style="font-family: 宋体;">中万物皆对象。</span></strong></span></p>
<p><span style="color: #ff0000;">l&nbsp;<strong>类：对象的一个具体的细分</strong></span></p>
<p><span style="color: #ff0000;">l&nbsp;<strong>实例：类中的一个具体事物</strong></span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">例如：自然界万物皆对象，把自然界中的事物分为几大类：人类、动物类、植物类</span>...<span style="font-family: 宋体;">等，而每一个人都是人类中的一个实例。</span></strong></span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">学习</span>JS<span style="font-family: 宋体;">，需要给</span><span style="font-family: Consolas;">JS</span><span style="font-family: 宋体;">分类，然后再研究每一个类别中具体的对象 &rarr; 面向对象编程思想。</span></strong></span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">所有的编程语言都是面向对象开发</span> &rarr; <span style="font-family: Consolas;">js</span><span style="font-family: 宋体;">是一门轻量级的脚本编程语言。</span></strong></span></p>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<p><span style="font-family: 宋体;">面向对象开发</span> &rarr; 研究类的继承、封装、多态</p>
<p><span style="font-family: 宋体;">可以认为</span>People<span style="font-family: 宋体;">是一个人</span>&ldquo;<span style="color: #ff0000;"><strong><span style="text-decoration: underline;"><span style="font-family: 宋体;">类（</span>class<span style="font-family: 宋体;">）</span></span></strong></span>&rdquo;<span style="font-family: 宋体;">，</span>xiaoming<span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">xiaoming</span><span style="font-family: 宋体;">都是这个</span><span style="font-family: Consolas;">People</span><span style="font-family: 宋体;">类的</span>&ldquo;<strong><span style="text-decoration: underline;"><span style="color: #ff0000; text-decoration: underline;"><span style="font-family: 宋体;">实例（</span>instance</span><span style="font-family: 宋体;"><span style="color: #ff0000; text-decoration: underline;">）</span>&rdquo;</span></span></strong>。</p>
<p>会发现产生的对象拥有相同的<strong><span style="text-decoration: underline;">属性群</span></strong>，我们称它们是同一个<strong><span style="text-decoration: underline;">类型的对象</span></strong>。</p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">当函数被</span>new<span style="font-family: 宋体;">调用时，此时总会返回同一类型的对象，感觉在构造什么东西，这个函数就被称为</span><strong><span style="text-decoration: underline;">&ldquo;构造函数&rdquo;。</span></strong></p>
<p>注意：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">●函数是构造函数，不是因为函数本身，而是因为它被new调用了
●习惯上：构造函数要用大写字母开头，暗示其他程序员这是一个构造函数。但是，记住了，不是说大写字母开头的就是构造函数，而是因为被new了
●顾名思义，它能够构造同一类型的对象，都有相同属性群。</span></pre>
</div>
<p><span style="font-family: 宋体;">类比</span>Java<span style="font-family: 宋体;">等</span><span style="font-family: Consolas;">OO</span><span style="font-family: 宋体;">语言（面向对象语言），</span><span style="font-family: Consolas;">People</span><span style="font-family: 宋体;">可以叫做类（</span><span style="font-family: Consolas;">class</span><span style="font-family: 宋体;">）。</span></p>
<p><span style="font-family: 宋体;">在</span>Java<span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">C++</span><span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">C#</span><span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">Python</span><span style="font-family: 宋体;">中，这种东西很像&ldquo;类&rdquo;的功能。实</span><strong><span style="text-decoration: underline;"><span style="font-family: 宋体;">际上</span>JavaScript<span style="font-family: 宋体;">没有类（</span><span style="font-family: Consolas;">class</span><span style="font-family: 宋体;">）的概念，只有构造函数（</span><span style="font-family: Consolas;">constructor</span><span style="font-family: 宋体;">）的概念！</span></span></strong></p>
<p>JavaScript<span style="font-family: 宋体;">是</span><strong><span style="text-decoration: underline;">基于对象的语言</span></strong><span style="font-family: 宋体;">（</span>Base on Object<span style="font-family: 宋体;">），而不是具体意义上&ldquo;面向对象&rdquo;（</span><span style="font-family: Consolas;">oriented object</span><span style="font-family: 宋体;">）语言。但是，我们将</span><span style="font-family: Consolas;">Java</span><span style="font-family: 宋体;">的一些概念，给移植过来</span></p>
<p>&nbsp;<img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链8.png" alt="" /></p>
<p><span style="font-family: 宋体;">灰色部分，</span> <span style="font-family: 宋体;">表示属性在自己身上。</span></p>
<p>&nbsp;</p>
<p>DOM<span style="font-family: 宋体;">语句也可以写在构造函数中：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Star(name,age,sex,url){
   </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
   </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
   </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
   </span><span style="color: #0000ff;">this</span>.url = "images/star/"+ url +".jpg"<span style="color: #000000;">;
   </span><span style="color: #008000;">//</span><span style="color: #008000;">创建图片对象</span>
   <span style="color: #0000ff;">this</span>.img = document.createElement('img'<span style="color: #000000;">);
   </span><span style="color: #0000ff;">this</span>.img.src = <span style="color: #0000ff;">this</span>.url; <span style="color: #008000;">//</span><span style="color: #008000;">添加图片地址</span>
   <span style="color: #008000;">//</span><span style="color: #008000;">上树</span>
   document.body.appendChild(<span style="color: #0000ff;">this</span><span style="color: #000000;">.img)
}
</span><span style="color: #0000ff;">var</span> liudehua = <span style="color: #0000ff;">new</span> Star("刘德华", 55, "男", 61<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> wanglihong = <span style="color: #0000ff;">new</span> Star("王力宏", 50, "男", 73<span style="color: #000000;">);
console.log(liudehua)
console.log(wanglihong)</span></pre>
</div>
<hr />
<h2><strong>3.2<span style="font-family: 宋体;">构造函数</span><span style="font-family: 华文中宋;">return</span></strong></h2>
<p><span style="font-family: 宋体;">构造函数不用写</span>return<span style="font-family: 宋体;">就能帮你返回一个对象，但如果写了</span><span style="font-family: Consolas;">return</span><span style="font-family: 宋体;">怎么办？</span></p>
<p>&nbsp;</p>
<p>面试题考察：</p>
<p>●如果<span style="font-family: Consolas;">return</span><span style="font-family: 宋体;">基本类型值，则无视</span><span style="font-family: Consolas;">return</span><span style="font-family: 宋体;">，函数该返回什么就返回什么，但</span><span style="font-family: Consolas;">return</span><span style="font-family: 宋体;">会结束构造函数的执行。</span></p>
<p>●如果<span style="font-family: Consolas;">return</span><span style="font-family: 宋体;">引用类型值，就不返回</span><span style="font-family: Consolas;">new</span><span style="font-family: 宋体;">出的对象了，则返回</span><span style="font-family: Consolas;">return</span><span style="font-family: 宋体;">的这个，原有</span><span style="font-family: Consolas;">return</span><span style="font-family: 宋体;">被覆盖。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
   </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
   </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
   </span><span style="color: #ff0000;">return 100;</span> <span style="color: #008000;">//</span><span style="color: #008000;">返回基本类型值，所以被忽略</span>
   <span style="color: #0000ff;">this</span>.sex = sex; <span style="color: #008000;">//</span><span style="color: #008000;">return会打断程序执行</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
console.log(xiaoming)</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链9.png" alt="" /></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #000000;">类似的，都会被忽略：注意，null此时看作基本类型
</span><span style="color: #0000ff;">return</span> "abc"
<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>
<span style="color: #0000ff;">return</span><span style="color: #000000;"> undefined
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span></pre>
</div>
<p>&nbsp;</p>
<p>如果返回引用类型值：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
   </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
   </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
   </span><span style="color: #0000ff;">return</span> {a:100,b:200}; <span style="color: #008000;">//</span><span style="color: #008000;">返回引用类型值，所以被返回，原有的被覆盖</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
console.log(xiaoming)</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链10.png" alt="" /></p>
<p>四步走失效了，构造函数没有任何意义了。</p>
<p>类似的，都会被返回，原有的新对象被覆盖</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">return</span><span style="color: #000000;"> {}
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> []
</span><span style="color: #0000ff;">return</span> /\d/
<span style="color: #0000ff;">return</span><span style="color: #000000;"> Math
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span>
<span style="color: #0000ff;">return</span> document</pre>
</div>
<p><span style="font-family: 宋体;">工作中不允许在构造函数</span>return<span style="font-family: 宋体;">，面试都是偏、难、怪。</span></p>
<hr />
<h2><strong>3.3<span style="font-family: 宋体;">构造函数</span><span style="font-family: 华文中宋;">-</span><span style="font-family: 宋体;">写成工厂模式</span></strong></h2>
<p><span style="font-family: 宋体;">工厂模式是软件工程领域一种广为人知的设计模式，而由于在</span>ECMAScript<span style="font-family: 宋体;">中无法创建类，因此用函数封装以特定接口创建对象。其实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性及方法再将对象返回即可。可以看到工厂模式的实现方法非常简单，解决了创建多个相似对象的问题，但是工厂模式却无从识别对象的类型，因为全部都是</span><span style="font-family: Consolas;">Object</span><span style="font-family: 宋体;">，不像</span><span style="font-family: Consolas;">Date</span><span style="font-family: 宋体;">、</span><span style="font-family: Consolas;">Array</span><span style="font-family: 宋体;">等，因此出现了构造函数模式。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
   </span><span style="color: #ff0000;">var obj =</span><span style="color: #000000;"><span style="color: #ff0000;"> {}</span>
   obj.name </span>=<span style="color: #000000;"> name;
   obj.age </span>=<span style="color: #000000;"> age;
   obj.sex </span>=<span style="color: #000000;"> sex;
   </span><span style="color: #ff0000;">return</span><span style="color: #000000;"><span style="color: #ff0000;"> obj;</span>
}
</span><span style="color: #0000ff;">var</span> xiaoming = People("小明",12,"男"<span style="color: #000000;">);
console.log(xiaoming)</span></pre>
</div>
<hr />
<h2><strong>3.4<span style="font-family: 宋体;">构造函数</span><span style="font-family: 华文中宋;">-</span><span style="font-family: 宋体;">添加方法</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
   </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
   </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
   </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
   </span><span style="color: #0000ff;">this</span>.sayHello = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
       alert(</span>"我是" + <span style="color: #0000ff;">this</span><span style="color: #000000;">.name)
   }
}
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaohong = <span style="color: #0000ff;">new</span> People("小红",13,"女"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaogangpao = <span style="color: #0000ff;">new</span> People("小钢炮",16,"女"<span style="color: #000000;">);
xiaoming.sayHello()
xiaohong.sayHello()
xiaogangpao.sayHello()</span></pre>
</div>
<p>信息不会串，因为对象自己打点调用自己的方法，函数中的this<span style="font-family: 宋体;">是这个对象。</span></p>
<p><span style="font-family: 宋体;">但是要研究一个事情，函数在哪？函数在每个实例身上。会发现每个人身上都有</span>sayHello<span style="font-family: 宋体;">函数</span></p>
<p>&nbsp;<img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链11.png" alt="" /></p>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链12.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">以下测试结果为</span>false<span style="font-family: 宋体;">，因为每一个对象身上都有一个独立的函数：</span></p>
<div class="cnblogs_code">
<pre><code>console.log(xiaoming.sayHello === xiaohong.sayHello); <span style="color: #008000;">//</span><span style="color: #008000;">false</span></pre>
</div>
<p>&nbsp;</p>
<p>此时有一个重大的问题，就是函数都分别定义在三个实例身上，是三个函数的不同副本。</p>
<p>但是，函数天生就是要被复用，否则封装函数有毛毛用？而且造成资源浪费，每个函数都占内存空间。</p>
<p><span style="font-family: 宋体;">深层次原因：你</span>new<span style="font-family: 宋体;">出的实例，</span><span style="color: #ff0000;"><strong>往往有一个需求：它们需要调用、使用、得到同一个对象。</strong></span></p>
<p><span style="color: #ff0000;"><strong>用构造函数生成的实例对象，有一个缺点，就是无法共享属性和方法。</strong></span></p>
<p>&nbsp;<img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链13.png" alt="" /></p>
<p><strong>JS<span style="font-family: 宋体;">创始人</span><span style="font-family: Consolas;">Brendan Eich</span><span style="font-family: 宋体;">鬼才发明了原型链。</span></strong></p>
<hr />
<h1><strong>四、原型链</strong></h1>
<p><span style="color: #ff0000;"><strong>用构造函数生成实例对象，有一个缺点，就是无法共享属性和方法。</strong></span></p>
<h2><strong>4.1<span style="font-family: 宋体;">原型对象和原型链查找</span></strong></h2>
<p><span style="color: #ff0000;"><strong>每一个函数天生都有一个</strong><strong><span style="text-decoration: underline;"><span style="font-family: 宋体;">属性（</span>prototype<span style="font-family: 宋体;">）原型，</span></span></strong><strong><span style="font-family: 宋体;">指向一个对象。当函数被</span>new<span style="font-family: 宋体;">调用时，它产生的每一个实例都会有一个</span></strong><strong>__proto__<span style="font-family: 宋体;">属性，也指向这个对象（函数的</span><span style="font-family: Consolas;">prototype</span><span style="font-family: 宋体;">）</span></strong></span></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">函数都有</span>prototype<span style="font-family: 宋体;">属性：</span></strong></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> fun(){

}
console.log(fun.prototype)</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链14.png" alt="" /></p>
<p>一般来说，函数的prototype<span style="font-family: 宋体;">对它自己没有任何意义，它唯一的意义是儿子们的指明灯，所以，如果这个函数是一个母亲（要构造东西，要被</span><span style="font-family: Consolas;">new</span><span style="font-family: 宋体;">调用时），这个原型就太有用了。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
   </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
   </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
   </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
}
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
console.log(People.prototype)
console.log(xiaoming.__proto__)
console.log(People.prototype </span>=== xiaoming.__proto__); <span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链15.png" alt="" /></p>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链16.png" alt="" />三角关系图</p>
<p>l&nbsp;大白话：</p>
<p><span style="font-family: 宋体;">你可以认为</span>People<span style="font-family: 宋体;">构造函数是妈妈，它有一个</span><span style="font-family: Consolas;">prototype</span><span style="font-family: 宋体;">属性可以找到孩子它爹，每一个实例都有</span><span style="font-family: Consolas;">__proto__</span><span style="font-family: 宋体;">属性，可以找到它爹，他爹有的属性或方法，孩子都有。</span></p>
<p>&nbsp;</p>
<p>l&nbsp;术语：</p>
<p>l&nbsp;People.prototype<span style="font-family: 宋体;">是构造函数</span><span style="font-family: Consolas;">People</span><span style="font-family: 宋体;">的&ldquo;原型&rdquo;</span></p>
<p>l&nbsp;People.prototype<span style="font-family: 宋体;">是小明实例的&ldquo;原型对象&rdquo;</span></p>
<p>l&nbsp;<span style="font-family: 宋体;">上面这张关系图，叫</span>&ldquo;原型链&rdquo;</p>
<p>l&nbsp;小明实例会沿着原型链向上查找，如果原型有一些属性和方法，小明实例都有拥有。</p>
<p><span style="color: #ff0000;"><strong>一定要记住三角恋：</strong><strong><span style="font-family: 宋体;">构造函数的</span>prototype<span style="font-family: 宋体;">属性指向谁，</span><span style="font-family: Consolas;">new</span><span style="font-family: 宋体;">出来的实例</span><span style="font-family: Consolas;">__proto__</span><span style="font-family: 宋体;">就指向谁</span></strong><strong><span style="font-family: 宋体;">。这个</span>__proto__<span style="font-family: 宋体;">有原型链查找功能。</span></strong></span></p>
<p><span style="font-family: 宋体;">所以，当</span>xiaoming<span style="font-family: 宋体;">身上没有某个属性的时候，系统会沿着</span><span style="font-family: Consolas;">__proto__</span><span style="font-family: 宋体;">（原型链）寻找它的构造函数的原型有没有这个属性。</span></p>
<p><span style="font-family: 宋体;">每一个属性在用</span>&ldquo;<span style="font-family: Consolas;">.</span><span style="font-family: 宋体;">&rdquo;语法访问自己的属性、方法时，都会沿着</span><span style="font-family: Consolas;">__proto__</span><span style="font-family: 宋体;">寻找，如果自己身上没有，将访问自己的原型对象，如果原型对象身上有，此时对象可以打点调用这个方法，如同自己的方法一样。</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
}
People.prototype </span>=<span style="color: #000000;"> {
    teacher : </span>"朱老师"<span style="color: #000000;">,
    age : </span>18<span style="color: #000000;">,
    sex : </span>"帅哥"<span style="color: #000000;">
}
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaohong = <span style="color: #0000ff;">new</span> People("小红",13,"女"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaogangpao = <span style="color: #0000ff;">new</span> People("小钢炮",16,"女"<span style="color: #000000;">);
console.log(xiaoming.teacher)
console.log(xiaohong.teacher)
console.log(xiaogangpao.teacher)</span></pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链17.png" alt="" /></p>
<p>&nbsp;</p>
<p>更改指向：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 改变构造函数指向Math对象，自己的实例能调用Math对象所有的方法</span>
People.prototype =<span style="color: #000000;"> Math;
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaohong = <span style="color: #0000ff;">new</span> People("小红",13,"女"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaogangpao = <span style="color: #0000ff;">new</span> People("小钢炮",16,"女"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">小明身上虽然没有random方法，但是小明的父亲有，会沿着__proto__去找</span>
<span style="color: #000000;">console.log(xiaoming.random())
console.log(xiaohong.PI)
console.log(xiaohong.pow(</span>3,4))</pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链18.png" alt="" /></p>
<hr />
<h2><strong>4.2<span style="font-family: 宋体;">方法定义在原型上</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> People(name,age,sex){
    </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    </span><span style="color: #0000ff;">this</span>.sex =<span style="color: #000000;"> sex;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">属性和方法定义在原型上，所有的实例都可以共用一个方法</span>
People.prototype.aaa = 100<span style="color: #000000;">;
People.prototype.bbb </span>= 200<span style="color: #000000;">;
People.prototype.sayHello </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.name);
};
</span><span style="color: #0000ff;">var</span> xiaoming = <span style="color: #0000ff;">new</span> People("小明",12,"男"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaohong = <span style="color: #0000ff;">new</span> People("小红",13,"女"<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> xiaogangpao = <span style="color: #0000ff;">new</span> People("小钢炮",16,"女"<span style="color: #000000;">);
console.log(People.prototype)
console.log(xiaoming.aaa)
console.log(xiaoming.bbb)
xiaoming.sayHello()
xiaohong.sayHello()
xiaogangpao.sayHello()</span></pre>
</div>
<p>在上面例子中，属性都是直接在对象自己的身上，而方法在实例的原型对象上（也就是构造函数的原型）</p>
<p>&nbsp;<img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链19.png" alt="" /></p>
<p>&nbsp;</p>
<p>可以验证：返回true<span style="font-family: 宋体;">，表示我们的图正确的</span></p>
<div class="cnblogs_code">
<pre><code>console.log(xiaoming.sayHello === xiaohong.sayHello); <span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p>&nbsp;</p>
<p>今后我们写面向对象的程序，创建一个类（构造函数），套路如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> 构造函数名字(属性1,属性2,属性3,属性N){
</span><span style="color: #0000ff;">this</span>.属性1 =<span style="color: #000000;"> 属性1;
</span><span style="color: #0000ff;">this</span>.属性2 =<span style="color: #000000;"> 属性2;
</span><span style="color: #0000ff;">this</span>.属性3 =<span style="color: #000000;"> 属性3;
...
}

构造函数名字.prototype.方法1 </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){}
构造函数名字.prototype.方法2 </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){}
构造函数名字.prototype.方法3 </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){}
构造函数名字.prototype.方法4 </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){}
构造函数名字.prototype.方法5 </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){}
构造函数名字.prototype.方法N </span>= <span style="color: #0000ff;">function</span>(){}</pre>
</div>
<hr />
<h1><!--[if !supportLists]-->五、<!--[endif]--><strong>练习题</strong></h1>
<h2><strong>5.1<span style="font-family: 宋体;">题目</span><span style="font-family: 华文中宋;">:1</span><span style="font-family: 宋体;">：</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> length = 10<span style="color: #000000;">;
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> fn() {
    alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.length);
}
</span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
    length: </span>5<span style="color: #000000;">, 
    haha: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(fn) {
        alert(</span><span style="color: #0000ff;">this</span> === obj); <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
        fn(); <span style="color: #008000;">//</span><span style="color: #008000;">函数fn的上下文是window，弹出10</span>
        fn.call(<span style="color: #0000ff;">this</span>); <span style="color: #008000;">//</span><span style="color: #008000;">强制指定上下文为这里的上下文obj，弹出5</span>
        arguments[0]();<span style="color: #008000;">//</span><span style="color: #008000;">函数fn的this是此时的arguments，弹出1</span>
<span style="color: #000000;">    }
}
obj.haha(fn);</span></pre>
</div>
<hr />
<h2>&nbsp;</h2>
<h2><strong>5.2<span style="font-family: 宋体;">题目</span><span style="font-family: 华文中宋;">2</span><span style="font-family: 宋体;">：</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> haha(){
    </span><span style="color: #0000ff;">var</span> a = (<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">return</span> 8<span style="color: #000000;">;
    })();
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
}
</span><span style="color: #0000ff;">var</span> m =<span style="color: #000000;"> haha();
console.log(m); </span><span style="color: #008000;">//</span><span style="color: #008000;">8</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function getLength(){
    return this.length;
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> foo(){
    </span><span style="color: #0000ff;">this</span>.length = 1; <span style="color: #008000;">//</span><span style="color: #008000;">全局的length</span>
    <span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">function</span>(){ <span style="color: #008000;">//</span><span style="color: #008000;">返回了一个IIFE的执行</span>
        <span style="color: #0000ff;">var</span> length = 2<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #ff0000;"> {
            length : </span><span style="color: #99cc00;">function(a,b,c){
                return this</span><span style="color: #000000;"><span style="color: #99cc00;">.arr.length
            },</span>
           <span style="color: #ff0000;"> arr : [</span></span><span style="color: #ff0000;">1,2,3,4],
            info : function(){
             //this == {}，此时这里的this是{}对象
                 return getLength.call(this</span><span style="color: #000000;"><span style="color: #ff0000;">.length);
            }</span>
        <span style="color: #ff0000;">}</span>
    })();
}
</span><span style="color: #0000ff;">var</span> l =<span style="color: #000000;"> foo().info();
console.log(l); </span><span style="color: #008000;">//</span><span style="color: #008000;">3</span></pre>
</div>
<p><span style="font-family: 宋体;">答案：</span>3<span style="font-family: 宋体;">，返回的是上面绿色</span><span style="font-family: Consolas;">length</span><span style="font-family: 宋体;">函数的形参个数</span></p>
<p><span style="font-family: 宋体;">解释：</span>foo()<span style="font-family: 宋体;">函数的运行结果返回了红色的</span><span style="font-family: Consolas;">{}</span><span style="font-family: 宋体;">对象，此时</span><span style="font-family: Consolas;">foo().info()</span><span style="font-family: 宋体;">语句表示红色</span><span style="font-family: Consolas;">{}</span><span style="font-family: 宋体;">对象打点调用</span><span style="font-family: Consolas;">info()</span><span style="font-family: 宋体;">函数。所以</span><span style="font-family: Consolas;">info</span><span style="font-family: 宋体;">函数中的</span><span style="font-family: Consolas;">this</span><span style="font-family: 宋体;">表示红色</span><span style="font-family: Consolas;">{}</span><span style="font-family: 宋体;">对象，而红色对象的</span><span style="font-family: Consolas;">length</span><span style="font-family: 宋体;">函数（就是绿色部分），也就是说，</span><span style="color: #ff0000;">getLength.call(this.length);<span style="font-family: 宋体;">表示蓝色函数运行，并且蓝色函数</span><span style="font-family: Consolas;">this</span><span style="font-family: 宋体;">指向绿色函数，所以表示绿色函数的形参长度。</span></span></p>
<hr />
<h2><strong>5.3<span style="font-family: 宋体;">题目</span><span style="font-family: 华文中宋;">3</span><span style="font-family: 宋体;">：</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> A(){
    </span><span style="color: #0000ff;">this</span>.m = 1<span style="color: #000000;">;
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> B(){
    </span><span style="color: #0000ff;">this</span>.m = 2<span style="color: #000000;">;
}
A.call(B);
B.call(A);
</span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
console.log(a.m </span>==<span style="color: #000000;"> B.m); 
console.log(b.m </span>== A.m); </pre>
</div>
<p><img src="./images/前端笔记之JavaScript面向对象（一）Object&amp;函数上下文&amp;构造函数&amp;原型链20.png" alt="" /></p>
<hr />
<h2><strong>5.4<span style="font-family: 宋体;">题目</span><span style="font-family: 华文中宋;">4</span><span style="font-family: 宋体;">：</span></strong></h2>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> Fun(){
    </span><span style="color: #0000ff;">this</span>.a = 5<span style="color: #000000;">;
    </span><span style="color: #ff0000;">function fun(){
        this.a = 10</span><span style="color: #000000;"><span style="color: #ff0000;">;
    }</span>
    fun.a </span>= 15<span style="color: #000000;">;
    </span><span style="color: #ff0000;">return</span><span style="color: #000000;"><span style="color: #ff0000;"> fun;</span>
}
</span><span style="color: #0000ff;">var</span> o = <span style="color: #0000ff;">new</span>(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Fun())();
console.log(o)
console.log(o.a);  </span><span style="color: #008000;">//</span><span style="color: #008000;">10</span></pre>
</div>
<p><span style="font-family: 宋体;">先执行内层</span>new Fun(),<span style="font-family: 宋体;">里面有</span><span style="font-family: Consolas;">return </span><span style="font-family: 宋体;">引用类型值（四步走失效），所以相当于红色</span><span style="font-family: Consolas;">fun</span><span style="font-family: 宋体;">函数被返回，此时红色</span><span style="font-family: Consolas;">fun</span><span style="font-family: 宋体;">函数身上有一属性</span><span style="font-family: Consolas;">a</span><span style="font-family: 宋体;">是</span><span style="font-family: Consolas;">15.</span></p>
<p><span style="font-family: 宋体;">外层</span>new ()<span style="font-family: 宋体;">实际上就是</span><span style="font-family: Consolas;">new</span><span style="font-family: 宋体;">红色函数，此时四步走，创建</span><span style="font-family: Consolas;">{}</span><span style="font-family: 宋体;">对象，给对象添加</span><span style="font-family: Consolas;">a</span><span style="font-family: 宋体;">属性为</span><span style="font-family: Consolas;">10</span><span style="font-family: 宋体;">，然后返回对象给</span><span style="font-family: Consolas;">o</span><span style="font-family: 宋体;">接收，</span><span style="font-family: Consolas;">o.a</span><span style="font-family: 宋体;">就是</span><span style="font-family: Consolas;">10</span><span style="font-family: 宋体;">。</span></p>
<hr />
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>