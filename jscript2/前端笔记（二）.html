<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修前端笔记（二）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>前端笔记（二）</center></div><div class='banquan'>原文出处:本文由博客园博主苹果π提供。<br/>
原文连接:https://www.cnblogs.com/pengxiangchong/p/11635521.html</div><br>
    <p>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由他的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p>变量解构赋值的用途：交换变量的值，从函数返回多个值，函数参数的定义，提取JSON数据，函数参数的默认值，遍历map解构，输入模块的指定方法。</p>
<p>&nbsp;</p>
<p>ES5中的数据结构，主要是用Array和Object。在ES6中主要新增了set和map数据结构。</p>
<p>能使用map的优先使用，不使用数组，考虑数据的唯一性，考虑使用set，不使用object。</p>
<p>&nbsp;</p>
<p>Symbol：功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用symbol（）函数来创建一个Symbol实例。每个symbol实例都是唯一的。当你比较两个Symbol实例的时候，将会返回false。</p>
<p>Symbol的用途：使用symbol来作为对象属性名，使用symbol来定义常量，使用symbol来定义类的私有属性和方法。</p>
<p>注册和获取全局Symbol</p>
<p>通常情况下，我们在一个浏览器窗口中，使用symbol（）函数定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用iframe），并需要这些window中使用的某些Symbol是同一个，那就不能使用Symbol（）函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是symbol.for()，它可以注册或获取一个window间全局的Symbol实例；</p>
<p>&nbsp;</p>
<p>参考网址：<a href="https://www.jianshu.com/p/f40a77bbd74e">https://www.jianshu.com/p/f40a77bbd74e</a></p>
<p>&nbsp;</p>
<p>去除数组的重复成员：[...new Set(array)]</p>
<p>去除字符串里面的重复字符：[...new Set('ababbc')].join('')</p>
<p>Array.from可以将set结构转为数组：const items = new Set([1, 2, 3, 4, 5]); const array = Array.from(items);</p>
<p>这就提供了去除数组重复成员的另一种方法。&nbsp; function dedupe(array) {&nbsp;&nbsp; return Array.from(new Set(array)); }&nbsp; dedupe([1, 1, 2, 3]) // [1, 2, 3]</p>
<p>&nbsp;</p>
<p>Set.prototype.keys()：返回键名的遍历器</p>
<p>Set.prototype.values()：返回键值的遍历器</p>
<p>Set.prototype.entries()：返回键值对的遍历器</p>
<p>Set.prototype.forEach()：使用回调函数遍历每个成员</p>
<p>&nbsp;</p>
<p>对象的扩展运算符：用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p>
<p>如果扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<p>扩展运算符还可以将字符串转为真正的数组，</p>
<p>[...'hello'] // [ "h", "e", "l", "l", "o" ]</p>
<p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>
<p>扩展运算符（spread）是三个点（&hellip;）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p>扩展运算符的应用：</p>
<p>1：合并数组2：与解构赋值结合使用</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>