<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修可能是全网最全的http面试答案' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>可能是全网最全的http面试答案</center></div><div class='banquan'>原文出处:本文由博客园博主程序员面试官提供。<br/>
原文连接:https://www.cnblogs.com/duxinyi/p/11676893.html</div><br>
    <h2 id="http有哪些方法">HTTP有哪些方法？</h2>
<ul>
<li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</li>
<li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li>
</ul>
<h2 id="这些方法的具体作用是什么">这些方法的具体作用是什么？</h2>
<ul>
<li>GET: 通常用于请求服务器发送某些资源</li>
<li>HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源</li>
<li>OPTIONS: 用于获取目的资源所支持的通信选项</li>
<li>POST: 发送数据给服务器</li>
<li>PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式</li>
<li>DELETE: 用于删除指定的资源</li>
<li>PATCH: 用于对资源进行部分修改</li>
<li>CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li>
<li>TRACE: 回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
<h2 id="get和post有什么区别">GET和POST有什么区别？</h2>
<ul>
<li>数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。</li>
<li>安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。</li>
<li>数据类型不同：GET只允许 ASCII 字符，而POST无限制</li>
<li>GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单</li>
<li>特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等</li>
</ul>
<h2 id="put和post都是给服务器发送新增资源有什么区别">PUT和POST都是给服务器发送新增资源，有什么区别？</h2>
<p>PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。</p>
<p>除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。</p>
<p>举个例子，我们在开发一个博客系统，当我们要创建一篇文章的时候往往用<code>POST https://www.jianshu.com/articles</code>，这个请求的语义是，在articles的资源集合下创建一篇新的文章，如果我们多次提交这个请求会创建多个文章，这是非幂等的。</p>
<p>而<code>PUT https://www.jianshu.com/articles/820357430</code>的语义是更新对应文章下的资源（比如修改作者名称等），这个URI指向的就是单一资源，而且是幂等的，比如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』</p>
<blockquote>
<p>ps: 『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性</p>
</blockquote>
<h2 id="put和patch都是给服务器发送修改资源有什么区别">PUT和PATCH都是给服务器发送修改资源，有什么区别？</h2>
<p>PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。</p>
<p>比如我们有一篇文章的地址<code>https://www.jianshu.com/articles/820357430</code>,这篇文章的可以表示为:</p>
<pre><code><code>article = {
    author: &#39;dxy&#39;,
    creationDate: &#39;2019-6-12&#39;,
    content: &#39;我写文章像蔡徐坤&#39;,
    id: 820357430
}</code></pre>
<p>当我们要修改文章的作者时，我们可以直接发送<code>PUT https://www.jianshu.com/articles/820357430</code>，这个时候的数据应该是:</p>
<pre><code><code>{
    author:&#39;蔡徐坤&#39;,
    creationDate: &#39;2019-6-12&#39;,
    content: &#39;我写文章像蔡徐坤&#39;,
    id: 820357430
}</code></pre>
<p>这种直接覆盖资源的修改方式应该用put，但是你觉得每次都带有这么多无用的信息，那么可以发送<code>PATCH https://www.jianshu.com/articles/820357430</code>，这个时候只需要:</p>
<pre><code><code>{
    author:&#39;蔡徐坤&#39;,
}</code></pre>
<h2 id="http的请求报文是什么样的">http的请求报文是什么样的？</h2>
<p>请求报文有4部分组成:</p>
<ul>
<li>请求行</li>
<li>请求头部</li>
<li>空行</li>
<li>请求体</li>
</ul>
<p><img src="./images/可能是全网最全的http面试答案0.png" alt="2019-06-14-11-24-10" /></p>
<ul>
<li>请求行包括：请求方法字段、URL字段、HTTP协议版本字段。它们用空格分隔。例如，GET /index.html HTTP/1.1。</li>
<li>请求头部:请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔</li>
</ul>
<ol>
<li>User-Agent：产生请求的浏览器类型。</li>
<li>Accept：客户端可识别的内容类型列表。</li>
<li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li>
</ol>
<ul>
<li>请求体: post put等请求携带的数据</li>
</ul>
<p><img src="./images/可能是全网最全的http面试答案1.png" alt="2019-06-14-11-33-37" /></p>
<h2 id="http的响应报文是什么样的">http的响应报文是什么样的？</h2>
<p>请求报文有4部分组成:</p>
<ul>
<li>响应行</li>
<li>响应头</li>
<li>空行</li>
<li>响应体</li>
</ul>
<p><img src="./images/可能是全网最全的http面试答案2.png" alt="2019-06-14-11-37-02" /></p>
<ul>
<li>响应行： 由协议版本，状态码和状态码的原因短语组成，例如<code>HTTP/1.1 200 OK</code>。</li>
<li>响应头：响应部首组成</li>
<li>响应体：服务器响应的数据</li>
</ul>
<h2 id="聊一聊http的部首有哪些">聊一聊HTTP的部首有哪些？</h2>
<blockquote>
<p>内容很多，重点看标『✨』内容</p>
</blockquote>
<p>通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部</p>
<ul>
<li>Cache-Control  控制缓存 ✨</li>
<li>Connection 连接管理、逐条首部 ✨</li>
<li>Upgrade  升级为其他协议</li>
<li>via 代理服务器的相关信息</li>
<li>Wraning 错误和警告通知</li>
<li>Transfor-Encoding 报文主体的传输编码格式 ✨</li>
<li>Trailer 报文末端的首部一览</li>
<li>Pragma 报文指令</li>
<li>Date 创建报文的日期</li>
</ul>
<p>请求首部字段（Reauest Header Fields）:客户端向服务器发送请求的报文时使用的首部</p>
<ul>
<li>Accept 客户端或者代理能够处理的媒体类型 ✨</li>
<li>Accept-Encoding 优先可处理的编码格式</li>
<li>Accept-Language 优先可处理的自然语言</li>
<li>Accept-Charset 优先可以处理的字符集</li>
<li>If-Match 比较实体标记（ETage） ✨</li>
<li>If-None-Match 比较实体标记（ETage）与 If-Match相反 ✨</li>
<li>If-Modified-Since 比较资源更新时间（Last-Modified）✨</li>
<li>If-Unmodified-Since比较资源更新时间（Last-Modified），与 If-Modified-Since相反 ✨</li>
<li>If-Rnages 资源未更新时发送实体byte的范围请求</li>
<li>Range 实体的字节范围请求 ✨</li>
<li>Authorization web的认证信息 ✨</li>
<li>Proxy-Authorization 代理服务器要求web认证信息</li>
<li>Host 请求资源所在服务器 ✨</li>
<li>From 用户的邮箱地址</li>
<li>User-Agent 客户端程序信息 ✨</li>
<li>Max-Forwrads 最大的逐跳次数</li>
<li>TE 传输编码的优先级</li>
<li>Referer 请求原始放的url</li>
<li>Expect 期待服务器的特定行为</li>
</ul>
<p>响应首部字段（Response Header Fields）:从服务器向客户端响应时使用的字段</p>
<ul>
<li>Accept-Ranges 能接受的字节范围</li>
<li>Age 推算资源创建经过时间</li>
<li>Location 令客户端重定向的URI ✨</li>
<li>vary  代理服务器的缓存信息</li>
<li>ETag 能够表示资源唯一资源的字符串 ✨</li>
<li>WWW-Authenticate 服务器要求客户端的验证信息</li>
<li>Proxy-Authenticate 代理服务器要求客户端的验证信息</li>
<li>Server 服务器的信息 ✨</li>
<li>Retry-After 和状态码503 一起使用的首部字段，表示下次请求服务器的时间</li>
</ul>
<p>实体首部字段（Entiy Header Fields）:针对请求报文和响应报文的实体部分使用首部</p>
<ul>
<li>Allow 资源可支持http请求的方法 ✨</li>
<li>Content-Language 实体的资源语言</li>
<li>Content-Encoding 实体的编码格式</li>
<li>Content-Length 实体的大小（字节）</li>
<li>Content-Type 实体媒体类型</li>
<li>Content-MD5 实体报文的摘要</li>
<li>Content-Location 代替资源的yri</li>
<li>Content-Rnages 实体主体的位置返回</li>
<li>Last-Modified 资源最后的修改资源 ✨</li>
<li>Expires 实体主体的过期资源 ✨</li>
</ul>
<h2 id="聊一聊http的状态码有哪些">聊一聊HTTP的状态码有哪些？</h2>
<p>2XX 成功</p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨</li>
<li>201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立</li>
<li>202 Accepted 请求已接受，但是还没执行，不保证完成请求</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>206 Partial Content，进行范围请求 ✨</li>
</ul>
<p>3XX 重定向</p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL ✨</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义相同</li>
</ul>
<p>4XX 客户端错误</p>
<ul>
<li>400 bad request，请求报文存在语法错误 ✨</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝 ✨</li>
<li>404 not found，表示在服务器上没有找到请求的资源 ✨</li>
<li>408 Request timeout, 客户端请求超时</li>
<li>409 Confict, 请求的资源可能引起冲突</li>
</ul>
<p>5XX 服务器错误</p>
<ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误 ✨</li>
<li>501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
<li>505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本</li>
</ul>
<h2 id="同样是重定向307303302的区别">同样是重定向307，303，302的区别？</h2>
<p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码又出来了两个303和307。</p>
<p>303明确表示客户端应当采用get方法获取资源，他会把POST请求变为GET请求进行重定向。<br />
307会遵照浏览器标准，不会从post变为get。</p>
<h2 id="http的keep-alive是干什么的">HTTP的keep-alive是干什么的？</h2>
<p>在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。</p>
<p>keep-alive的优点：</p>
<ul>
<li>较少的CPU和内存的使用（由于同时打开的连接的减少了）</li>
<li>允许请求和应答的HTTP管线化</li>
<li>降低拥塞控制 （TCP连接减少了）</li>
<li>减少了后续请求的延迟（无需再进行握手）</li>
<li>报告错误无需关闭TCP连</li>
</ul>
<h2 id="为什么有了http为什么还要https">为什么有了HTTP为什么还要HTTPS？</h2>
<p>https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。</p>
<h2 id="https是如何保证安全的">HTTPS是如何保证安全的？</h2>
<p>过程比较复杂，我们得先理解两个概念</p>
<p>对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密</p>
<p>对称加密虽然很简单性能也好，但是无法解决首次把秘钥发给对方的问题，很容易被hacker拦截秘钥。</p>
<p>非对称加密：</p>
<ol>
<li>私钥 + 公钥= 密钥对</li>
<li>即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密</li>
<li>因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方</li>
<li>然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密</li>
</ol>
<p>非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。</p>
<p>解决方案：</p>
<p>那么结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
<p>此时又带来一个问题，中间人问题：</p>
<p>如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。</p>
<p>所以这个时候需要一个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。</p>
<p>证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等</p>
<p><img src="./images/可能是全网最全的http面试答案3.png" alt="2019-06-14-12-30-18" /></p>
<p>但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。</p>
<p>数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。</p>
<p>当别人把他的证书发过来的时候,我再用同样的Hash算法,再次生成消息摘要，然后用CA的公钥对数字签名解密,得到CA创建的消息摘要,两者一比,就知道中间有没有被人篡改了。</p>
<p>这个时候就能最大程度保证通信的安全了。</p>
<h2 id="http2相对于http1.x有什么优势和特点">HTTP2相对于HTTP1.x有什么优势和特点？</h2>
<h3 id="二进制分帧">二进制分帧</h3>
<p>帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。</p>
<p>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID</p>
<p>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。</p>
<h3 id="服务器推送">服务器推送</h3>
<p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p>
<p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p>
<h3 id="头部压缩">头部压缩</h3>
<p>HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。</p>
<ul>
<li>HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送</li>
<li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li>
<li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li>
</ul>
<blockquote>
<p>你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量</p>
</blockquote>
<p><img src="./images/可能是全网最全的http面试答案4.png" alt="2019-06-14-12-52-59" /></p>
<h3 id="多路复用">多路复用</h3>
<p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p>
<p>HTTP2中：</p>
<ul>
<li>同域名下所有通信都在单个连接上完成。</li>
<li>单个连接可以承载任意数量的双向数据流。</li>
<li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装</li>
</ul>
<p><img src="./images/可能是全网最全的http面试答案5.png" alt="2019-06-14-12-58-50" /></p>
<blockquote>
<p>拓展阅读：<a href="https://zhuanlan.zhihu.com/p/30166894">HTTP/2特性及其在实际应用中的表现</a></p>
</blockquote>
<hr />
<h2 id="公众号">公众号</h2>
<p>想要实时关注笔者最新的文章和最新的文档更新请关注公众号<strong>程序员面试官</strong>,后续的文章会优先在公众号更新.</p>
<p><strong>简历模板:</strong> 关注公众号回复「模板」获取</p>
<p><strong>《前端面试手册》:</strong> 配套于本指南的突击手册,关注公众号回复「fed」获取</p>
<p><img src="./images/可能是全网最全的http面试答案6.png" alt="2019-08-12-03-18-41" /></p>
<blockquote>
<p>本文由博客一文多发平台 <a href="https://openwrite.cn?from=article_bottom">OpenWrite</a> 发布！</p>
</blockquote>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>