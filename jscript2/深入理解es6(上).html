<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修深入理解es6(上)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>深入理解es6(上)</center></div><div class='banquan'>原文出处:本文由博客园博主smile_or提供。<br/>
原文连接:https://www.cnblogs.com/sgs123/p/11481396.html</div><br>
    <h2 id="一let和const">一、let和const</h2>
<h3 id="let与var的区别">1、let与var的区别</h3>
<p>不存在变量提升<br />
块级作用域<br />
不允许重复声明</p>
<h3 id="const常量">2、const常量</h3>
<p>const与let一样，唯一区别在于声明的常量不能被修改</p>
<h2 id="二解构赋值">二、解构赋值</h2>
<p>es6按照一定模式，从数组和对象中提取值，对变量进行赋值，被称为解构</p>
<h3 id="数组的解构">1、数组的解构</h3>
<ul>
<li>&quot;模式匹配&quot;，只要等号两边的模式相同，左边的变量就会被赋予对应的值，如果右边不是数组就会报错</li>
<li>基本用法：</li>
</ul>
<pre><code><code>let [a, b, c] = [1, 2, 3] // a=1, b=2, c=3

let [a1, b1=2] = [1] // a1=1, b1=2 //指定默认值

let [d, [e], f] = [1, [2], 3] // 嵌套数组解构 d=1, e=2, f=3

let [g, ...h] = [1, 2, 3] // 数组拆分 g=1, h=[2, 3]

let [i,,j] = [1, 2, 3] // 不连续解构 i=1, j=3

let [k,l] = [1, 2, 3] // 不完全解构 k=1, l=2</code></pre>
<h3 id="对象的解构">2、对象的解构</h3>
<p>与数组不同的是，变量的解构没有顺序问题，变量必须与属性同名才能解构<br />
基本用法：</p>
<pre><code><code>let {a, b} = {a:&#39;aa&#39;, b:&#39;bb&#39;} //a=&#39;aa&#39; b=&#39;bb&#39;

//设置默认值
let {x, y = 5} = {x: 1}; //x= 1 y=5

//允许别名，a的值将失效
let {a:a1,b} = {a:&#39;aa&#39;, b:&#39;bb&#39;} //a1=&#39;aa&#39; b=&#39;bb&#39; 

let obj = {a:&#39;aa&#39;, b: {c:&#39;c&#39;}}
let {a, b:{c}} = obj // 嵌套解构 a=&#39;aa&#39; c=&#39;bb&#39;

</code></pre>
<h3 id="字符串的解构">3、字符串的解构</h3>
<pre><code><code>let [a, b, c] = &#39;hello&#39; // a=&#39;h&#39; b=&#39;e&#39; c=&#39;l&#39;</code></pre>
<h3 id="函数的解构">4、函数的解构</h3>
<pre><code><code>function say({name,age}){
    console.log(name + &#39;今年&#39; + age)
} 
say({name:&#39;小明&#39;,age:18})</code></pre>
<h2 id="三字符串的扩展">三、字符串的扩展</h2>
<h3 id="模板字符串">1、模板字符串</h3>
<p>用反引号（`）标识，字符串中嵌入变量用${}</p>
<h3 id="新增方法">2、新增方法</h3>
<p>查找字符串，返回布尔值</p>
<pre><code><code>let str = &#39;hello world&#39;
//返回布尔值，表示是否找到了参数字符串
str.includes(&#39;r&#39;)  //true 

//返回布尔值，表示参数字符串是否在原字符串的头部
str.startsWith(&#39;hello&#39;)  //true

//返回布尔值，表示参数字符串是否在原字符串的尾部
str.endsWith(&#39;d&#39;)  //true</code></pre>
<p>去空格</p>
<pre><code><code>let str = &#39;   hello world      &#39;
//消除首尾的空格
str.trim()  //&#39;hello world&#39;

//消除字符串头部的空格
str.trimStart()  //&#39;hello world   &#39;

//消除尾部的空格
str.trimEnd()  //&#39;   hello world&#39;</code></pre>
<h2 id="四数组的扩展">四、数组的扩展</h2>
<p>es5新增的方法：<br />
forEach、map、filter、some、every、reduce</p>
<h3 id="array.from将类似数组的对象转为数组">1、Array.from将类似数组的对象转为数组</h3>
<pre><code><code>//类似数组的对象
let obj = {
    0:&#39;a&#39;,
    1:&#39;b&#39;,
    2:&#39;c&#39;,
    length:3
}
//es5写法
var arr = [].slice.call(obj);
//es6写法
var arr1 = Array.from(obj);

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}</code></pre>
<h3 id="array.of方法用于将一组值转换为数组">2、Array.of方法用于将一组值，转换为数组</h3>
<pre><code><code>    Array.of(3, 11, 8) // [3,11,8]
    Array.of(3) // [3]</code></pre>
<h3 id="findfindindex查找符合条件的元素">3、find/findIndex查找符合条件的元素</h3>
<pre><code><code>//find方法找出第一个符合条件的数组成员
let arr = [1, 4, -5, 10];
let val = arr.find((item,index,arr)=&gt;{
    return item &gt; 1;
})
//val 4

//findIndex返回第一个符合条件的数组成员的位置
let index = arr.find((item,index,arr)=&gt;{
    return item &gt; 1;
})
//index 1</code></pre>
<h3 id="entrieskeysvalues用于遍历数组">4、entries(),keys(),values()用于遍历数组</h3>
<p>可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<pre><code><code>let arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]

//遍历数组的键名
for(let index of arr.keys()){
    console.log(index)
}
//0 1 2 

//遍历数组的键值
for(let value of arr.values()){
    console.log(value)
}
//&#39;a&#39; &#39;b&#39; &#39;c&#39;

//遍历数组的键值对
for(let [index,value] of arr.entries()){
    console.log(index,value)
}
//0 &#39;a&#39; 
//1 &#39;b&#39;
//2 &#39;c&#39;</code></pre>
<h3 id="includes表示是否包含某个值">5、includes()表示是否包含某个值</h3>
<pre><code><code>[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true

//第二个参数表示搜索的开始位置，负数表示倒数位置
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true</code></pre>
<h3 id="数组的扩展运算符-...">6、数组的扩展运算符 ...</h3>
<p>可以把数组展开成用逗号隔开的一组值</p>
<pre><code><code>let arr = [1,2,3,4,5,6,7]
//复制数组
let arr1 = [...arr]

//合并数组
let arr2 = [...arr,8] // [1,2,3,4,5,6,7,8]

//展开参数
Math.max(...arr) //7

//剩余参数(解构赋值)
let [a,...b] = arr
//a 1
//b [2,3,4,5,6,7]

//转Set (同时去重)
let arr3 = [...new Set(arr)]</code></pre>
<h2 id="五对象的扩展">五、对象的扩展</h2>
<h3 id="对象的简写">1、对象的简写</h3>
<ul>
<li>当属性名和属性值相同时，可以省略属性值</li>
<li>方法可以省略function</li>
<li>对象的属性名和方法名允许为变量或者表达式</li>
<li>例如：</li>
</ul>
<pre><code><code>let name = &#39;小明&#39;
let age =&quot;age1&quot;
let person = {
    name,
    [age]:18,
    [&#39;hei&#39;+&#39;ght&#39;]:180,
    sayName(){
        console.log(this.name)
    }
}
person.sayName();
console.log(person)</code></pre>
<h3 id="对象的扩展运算符-...">2、对象的扩展运算符 ...</h3>
<p>同数组扩展运算符，支持对象解构剩余参数，对象合并，复制对象</p>
<h3 id="object.is">3、Object.is()</h3>
<p>用来比较两个值是否严格相等,等同于 &quot;===&quot;</p>
<pre><code><code>//唯一不同之处
+0 === -0 //true
NaN === NaN //false
Object.is(+0, -0) // false
Object.is(NaN,NaN) //true</code></pre>
<h3 id="object.assign">4、Object.assign()</h3>
<ul>
<li>用于对象的合并,第一个参数是目标对象，后面的参数都是源对象</li>
<li>如果目标对象与源对象有同名属性，则后面会覆盖前面的属性</li>
</ul>
<pre><code><code>var obj1 = {a:1,b:2}
var obj2 = {b:3,c:4}
console.log(Object.assign(obj1,obj2))
//{a:1, b:3, c:4}

let obj = {a:1, b:2}
Object.assign(obj) === obj // true

//参数不是对象会转成对象再返回
typeof Object.assign(2) // &quot;object&quot;

//undefined和null无法转成对象,作为第一个参数会报错
Object.assign(undefined) // 报错
Object.assign(null) // 报错

Object.assign(obj, undefined) === obj // true
Object.assign(obj, null) === obj // true</code></pre>
<h3 id="object.setprototypeofobject.getprototypeof">5、Object.setPrototypeOf(),Object.getPrototypeOf()</h3>
<ul>
<li>Object.setPrototypeOf()用来设置一个对象的prototype对象</li>
<li>Object.getPrototypeOf()用于读取一个对象的原型对象</li>
</ul>
<pre><code><code>//设置obj对象上的__proto__原型对象为proto对象
let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);</code></pre>
<h3 id="object.keysobject.valuesobject.entries">6、Object.keys(),Object.values(),Object.entries()</h3>
<p>使用for...of可以遍历对象的键名，键值，键值对</p>
<pre><code><code>var obj = {
    a:1,
    b:2,
    c:3
}
//传统遍历对象
for(key in obj){
    console.log(key) //所有键值
    console.log(obj[key]) //所有键值
}

//es6遍历
//所有键名
for( let index of Object.keys(obj) ){
    console.log(index)
}
//所有键值
for( let value of Object.values(obj) ){
    console.log(value)
}
//所有键值对
for( let [index,value] of Object.entries(obj) ){
    console.log(index,value)
}</code></pre>
<h3 id="object.fromentries">7、Object.fromEntries()</h3>
<p>方法是Object.entries()的逆操作，用于将一个键值对数组转为对象</p>
<pre><code><code>Object.fromEntries([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
])
// { foo: &quot;bar&quot;, baz: 42 }

// 特别适合Map结构
const map = new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);
Object.fromEntries(map)
// { foo: true, bar: false }</code></pre>
<h2 id="六函数的扩展">六、函数的扩展</h2>
<h3 id="函数参数的默认值">1、函数参数的默认值</h3>
<p>如果传入了参数就使用传入的值，如果没有就使用默认值</p>
<pre><code><code>function sum(a=0, b=0){
    return a + b;
}
sum(); //0
sum(1); //1
sum(1,1) //2</code></pre>
<h3 id="rest参数">2、rest参数</h3>
<p>用于获取函数的多余参数，这样就不需要使用arguments对象</p>
<pre><code><code>function add(...value){
    console.log(value)
    //[1,2,3,4]
}
add(1,2,3,4)</code></pre>
<h3 id="箭头函数">3、箭头函数 =&gt;</h3>
<p>使用“箭头”（=&gt;）定义函数</p>
<ul>
<li>箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分<br />
</li>
<li>箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回</li>
<li>如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错</li>
</ul>
<pre><code><code>var f = v =&gt; v;

// 等同于
var f = function (v) {
  return v;
};</code></pre>
<h4 id="注意">注意：</h4>
<p>this指向外部作用域<br />
不可以new，也就是不能用作构造函数<br />
不可以使用argument对象，可以使用rest参数代替</p>
<p>参考至 <a href="http://es6.ruanyifeng.com/">阮一峰es6</a></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>